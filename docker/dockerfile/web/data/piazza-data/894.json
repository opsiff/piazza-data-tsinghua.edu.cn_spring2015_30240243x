{"aid": "j21zw8y1z6p6i4", "result": {"status": "active", "unique_views": 107, "request_instructor_me": false, "change_log": [{"data": "ioldecg7swh231", "anon": "no", "when": "2016-05-24T11:40:23Z", "uid": "i0ccfx63sir1e", "type": "create"}, {"data": "ioldgrly2qd5ia", "anon": "no", "when": "2016-05-24T11:42:16Z", "uid": "i0ccfx63sir1e", "type": "update"}, {"data": "ioldvvi7zfnm4", "anon": "no", "when": "2016-05-24T11:54:01Z", "uid": "i0ccfx63sir1e", "type": "update"}, {"uid": "hcrrjuyequh4bt", "data": "ioli2cfg1f41yn", "when": "2016-05-24T13:51:01Z", "to": "ioldecg4ftr230", "anon": "no", "type": "i_answer"}, {"data": "ioli388f9rq10p", "anon": "no", "when": "2016-05-24T13:51:43Z", "uid": "hcrrjuyequh4bt", "type": "i_answer_update"}, {"to": "ioldecg4ftr230", "anon": "full", "when": "2016-05-24T14:17:32Z", "type": "followup"}, {"to": "ioldecg4ftr230", "anon": "no", "when": "2016-05-25T04:02:58Z", "uid": "i0c9nvk0xzc2n3", "type": "followup"}, {"to": "ioldecg4ftr230", "anon": "full", "when": "2016-05-25T04:06:32Z", "type": "followup"}, {"data": "iomd664vu56wd", "anon": "no", "when": "2016-05-25T04:21:48Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "ioldecg4ftr230", "anon": "no", "when": "2016-05-25T04:31:33Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "ioldecg4ftr230", "anon": "no", "when": "2016-05-25T05:28:26Z", "uid": "i0ccfx63sir1e", "type": "feedback"}, {"data": "iomfkbzkiwb3jm", "anon": "no", "when": "2016-05-25T05:28:48Z", "uid": "i0ccfx63sir1e", "type": "update"}, {"to": "ioldecg4ftr230", "anon": "no", "when": "2017-04-28T04:16:56Z", "type": "feedback", "uid": "hdjonbiyfs62ie"}], "upvote_ids": [], "id": "ioldecg4ftr230", "bookmarked": 8, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-05-24T13:51:01Z", "type": "i_answer", "tag_endorse_arr": ["i0b2fq3ezjw50r", "i0ccfx63sir1e"], "id": "ioli2cfdqud1ym", "bucket_name": "Today", "config": {}, "tag_endorse": [{"name": "Liu Xiaohong", "admin": false, "photo": null, "us": false, "id": "i0ccfx63sir1e", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "email": "lxhlxhlxh555@gmail.com"}, {"name": "张明瑞 2013011391", "admin": false, "photo": "1421470584_35.png", "us": false, "id": "i0b2fq3ezjw50r", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "email": "zhangmr13@mails.tsinghua.edu.cn"}], "bucket_order": 2, "data": {"embed_links": []}, "children": [], "history": [{"content": "<p>CMU文章写的很详细。我个人理解是有3种&#xff0c;其解释是合理和正确的。</p>\n<p></p>\n<p>但我们的课上只讲了两种。</p>\n<ul><li>我们课课件的Hoare&#xff1a;就是该篇文章的Hoare</li><li>我们课课件的Hansen&#xff1a;应该是该篇文章的Mesa</li></ul>\n<p></p>\n<p>通过查找其他资料&#xff0c;CMU文章的三种取名方式更加普遍。</p>\n<p>我们课上没有讲到的内容&#xff0c;即CMU文章写的Brinch Hansen方式&#xff0c;我们不会考。我们主要考的还是对OS知识点的理解。</p>\n<p>操作系统博大精深&#xff0c;我们的课程内容还需进一步改进。</p>\n<p>谢谢&#xff01;</p>", "anon": "no", "created": "2016-05-24T13:51:43Z", "uid": "hcrrjuyequh4bt", "subject": ""}, {"content": "<p>CMU文章写的很详细。我个人理解是有3种&#xff0c;其解释也没有错。</p>\n<p></p>\n<p>但我们的课上只讲了两种。</p>\n<ul><li>我们课课件的Hoare&#xff1a;就是该篇文章的Hoare</li><li>我们课课件的Hansen&#xff1a;应该是该篇文章的Mesa</li></ul>\n<p></p>\n<p>通过查找其他资料&#xff0c;CMU文章的三种取名方式更加普遍。</p>\n<p>我们课上没有讲到的内容&#xff0c;即CMU文章写的Brinch Hansen方式&#xff0c;我们不会考。我们主要考的还是对OS知识点的理解。</p>\n<p>操作系统博大精深&#xff0c;我们的课程内容还需进一步改进。</p>\n<p>谢谢&#xff01;</p>", "anon": "no", "created": "2016-05-24T13:51:01Z", "uid": "hcrrjuyequh4bt", "subject": ""}]}, {"folders": [], "updated": "2016-05-24T14:17:32Z", "no_upvotes": 0, "created": "2016-05-24T14:17:32Z", "type": "followup", "no_answer": 0, "id": "iolj0fj4wqs17o", "anon": "full", "bucket_name": "Week 5/22 - 5/28", "config": {}, "bucket_order": 53, "data": null, "children": [], "subject": "<p>赞赞赞</p>"}, {"folders": [], "updated": "2016-05-25T04:02:58Z", "no_upvotes": 0, "uid": "i0c9nvk0xzc2n3", "created": "2016-05-25T04:02:58Z", "type": "followup", "no_answer": 0, "id": "iomchy2tjmn12u", "anon": "no", "bucket_name": "Week 5/22 - 5/28", "config": {}, "bucket_order": 53, "data": null, "children": [], "subject": "<p>真棒&#xff0c;为你的探究精神点赞&#xff01;</p>"}, {"folders": [], "updated": "2016-05-25T04:06:32Z", "no_upvotes": 0, "created": "2016-05-25T04:06:32Z", "type": "followup", "no_answer": 0, "id": "iomcmjmo9tl61n", "anon": "full", "bucket_name": "Week 5/22 - 5/28", "config": {}, "bucket_order": 53, "data": null, "children": [{"folders": [], "updated": "2016-05-25T05:28:26Z", "uid": "i0ccfx63sir1e", "created": "2016-05-25T05:28:26Z", "type": "feedback", "id": "iomfjv64sau3ao", "anon": "no", "bucket_name": "Week 5/22 - 5/28", "config": {}, "bucket_order": 53, "data": null, "children": [], "subject": "<p>嗯&#xff0c;已修正</p>"}], "subject": "<p>想吐槽不是以正视听嘛...</p>"}, {"folders": [], "updated": "2016-05-25T04:31:33Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-05-25T04:31:33Z", "type": "followup", "no_answer": 0, "id": "iomdipn3f344as", "anon": "no", "bucket_name": "Week 5/22 - 5/28", "config": {}, "bucket_order": 53, "data": null, "children": [{"folders": [], "updated": "2017-04-28T04:16:55Z", "uid": "hdjonbiyfs62ie", "created": "2017-04-28T04:16:55Z", "type": "feedback", "id": "j21bttp3wjk7hv", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>Mesa管程&#xff1a;占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程&#xff0c;当前进程继续执行&#xff0c;被唤醒放回入口队列队首等待当前进程释放管程访问权&#xff1b;</p>\n<p></p>\n<p>Hoare管程&#xff1a;占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程&#xff0c;当前进程进入唤醒队列等待&#xff0c;被唤醒进程继续执行直到释放管程访问权&#xff1b;管程空闲时&#xff0c;优先查看唤醒队列中的等待进程&#xff0c;唤醒队列中没有等待进程时再查看入口队列&#xff1b;</p>\n<p></p>\n<p>Hansen管程&#xff1a;占用管程的当前进程只在退出管程时释放占用资源并唤醒相应的等待进程&#xff0c;被唤醒进程继续执行直到释放管程访问权&#xff1b;</p>\n<p></p>\n<p>条件判断中while和if对释放处理中的执行顺序影响&#xff1a;<br />在Hansen和Mesa管程中&#xff0c;由于条件变量释放操作signal时并没有立即放弃管程访问权&#xff0c;资源的可用状态可能变化&#xff0c;需使用while()进行重新检查&#xff1b;<br />在Hoare管程中&#xff0c;由于条件变量释放操作signal同时表示立即放弃管程访问权&#xff0c;资源的可用状态保持不变&#xff0c;可使用if判断&#xff0c;不需要再次检查。</p>\n<p></p>\n<p>依据目前的理解&#xff0c;Hansen和Mesa管程在程序行为效果上来看&#xff0c;它们是一致的。</p>\n<p></p>\n<p>有兴趣的同学&#xff0c;可尝试这三种管程的代码实现&#xff0c;并确认或证伪这个判断。</p>"}], "subject": "<p>Liu Xiaohong的描述是正确的。我的视频需要更新了&#xff0c;我也需要更仔细地探研教学内容的科学性。谢谢&#xff01;</p>\n<p></p>\n<p>这里还有一处需要推敲的地方。即&#xff1a;限制signal时机的做法如何准确地再现在管程的实现代码中&#xff1f;前两种表现为while和if&#xff0c;第三种好像不能简单描述成也是if。有兴趣的同学可以在<strong>考试后</strong>和我一起来讨论。</p>\n<p></p>\n<p></p>\n<p></p>"}], "nr": 894, "bucket_order": 2, "type": "question", "folders": ["lecture18", "视频纠错", "文档纠错"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "tags": ["lecture18", "student", "文档纠错", "视频纠错"], "created": "2016-05-24T11:40:23Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1493393439817, "tag_good": [{"name": "Yu Chen", "admin": true, "photo": "1378950179_35.png", "us": false, "id": "hcrrjuyequh4bt", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "email": "yuchen@mail.tsinghua.edu.cn", "admin_permission": 10}, {"name": "Ruidong CAO", "admin": true, "photo": null, "us": false, "id": "hs2swpdtr91gu", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "email": "crdfrank@gmail.com", "admin_permission": 10}, {"name": "Albert Einstein(计32黄世宇)", "admin": false, "photo": "1411401155_35.png", "us": false, "id": "i0dz4pw39owu5", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "email": "18801216815@163.com"}, {"name": "Long Haomin", "admin": false, "photo": null, "us": false, "id": "i14g50r7ui12pn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "email": "cherudim9@gmail.com"}, {"name": "徐涵2013011355", "admin": false, "photo": null, "us": false, "id": "i1bzj2xilgm4uk", "class_sections": ["课程设计_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "email": "orangexuhan@163.com"}], "tag_good_arr": ["i14g50r7ui12pn", "i1bzj2xilgm4uk", "hs2swpdtr91gu", "hcrrjuyequh4bt", "i0dz4pw39owu5"], "history": [{"content": "<p></p>\n<p>昨晚我们班在寝室里交流操作系统&#xff0c;其中管程部分感觉还不太清楚&#xff0c;<strong>Hansen和Hoare的区别是什么&#xff1f;用while、if的原因是什么&#xff1f;</strong></p>\n<p></p>\n<p>今天看了一份cmu的这部分材料&#xff0c;与课件讲的有些地方不一样。希望老师给予点评&#xff0c;以正视听。</p>\n<p><a href=\"https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html\">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>\n<p></p>\n<p><strong>1、管程的定义</strong></p>\n<p></p>\n<p>A programmer can put functions/procedures/methods into this box and the monitor makes him a very simple guarantee: only one function within the monitor will execute at a time -- mutual exclusion will be guaranteed.</p>\n<p></p>\n<p>管程是一个黑盒&#xff0c;程序员往里扔的函数&#xff0c;它确保在同一时刻&#xff0c;只有一个函数在执行。即确保互斥。</p>\n<p></p>\n<p>既然同时只可能有一个程序在执行&#xff0c;自然也就保证了共享数据的同步安全。</p>\n<p></p>\n<p><strong>2、管程有三种语义</strong></p>\n<p></p>\n<p>Mesa Semantics&#xff0c;Hoare Semantics&#xff0c;Brinch Hanson Semantics</p>\n<p></p>\n<p>后面的分析涉及三个队列&#xff1a;<br />Wait Queue&#xff1a;等待队列<br />Entry Queue&#xff1a;可以理解为就绪队列<br />Signal Queue&#xff1a;执行signal操作后&#xff0c;线程放入该队列&#xff08;Hoare才有&#xff09;</p>\n<p></p>\n<p>Now let me suggest that while a second thread is running in the monitor, it frees a resource required by the first. It signals that the resource that the first thread is waiting for becomes available. What should happen? Should the first thread be immediately awakened or should the second thread finish first? This situation gives rise to different versions of monitor sematics.</p>\n<p></p>\n<p>后面的例子是这样的情形&#xff0c;看三种语义的处理方式&#xff1a;<br />线程A等待资源R&#xff0c;在wait队列&#xff0c;这时线程B signal资源R会发生什么&#xff1f;</p>\n<p></p>\n<p><strong>3、Mesa Semantics</strong></p>\n<p></p>\n<p>With Mesa semantics, when the first thread&#39;s resource becomes available, it is moved from the signal queue back to the entry queue. The second thread finishes executing, and the first thread will eventually be processes from the entry queue.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程A从wait队列放入entry队列&#xff0c;线程B继续执行。</p>\n<p></p>\n<p>课件中没有说明Mesa&#xff0c;但该描述就像课件的Hansen。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold109811e3/monitor_mesa.jpg\" width=\"514\" height=\"317\" /></p>\n<p></p>\n<p><strong>4、Hoare Semantics</strong></p>\n<p></p>\n<p>If the first thread&#39;s condition is satisfied, it should immediatly execute.</p>\n<p></p>\n<p>Hoare的思想是&#xff0c;如果线程资源满足了&#xff0c;就应该马上执行。</p>\n<p></p>\n<p>The second thread is put into a signal queue. When a thread exits the monitor, a thread from the signal queue is restarted. Only when the signal queue is empty, is the entry queue used. This approach is more compilcated, but leads to some nicer proofs.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程B放入signal队列&#xff0c;线程A执行。每次有线程退出时&#xff0c;先到signal队列中调度线程&#xff0c;如果signal队列空&#xff0c;才到entry队列调度线程。</p>\n<p></p>\n<p>这个和课件讲的Hoare一样。ucore代码也有类似signal队列的概念。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold9fguc9bw/monitor_hoare.jpg\" width=\"488\" height=\"324\" /></p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolddpkufmhw/屏幕快照_20160524_下午7.18.34.png\" width=\"158\" height=\"85\" /></p>\n<p></p>\n<p><strong>5、Hanson Semantics</strong></p>\n<p></p>\n<p>The Brinch Hansen monitor only allows a process or thread to signal upon exit from the monitor. At that point, the signaled process or thread can run; the signalling process has already left the monitor.</p>\n<p></p>\n<p>线程B退出的同时&#xff0c;signal资源R。&#xff08;应该就是说&#xff0c;过程中没有signal操作&#xff0c;退出的同时signal&#xff09;</p>\n<p></p>\n<p>课件没有讲过“signal upon exit”这种做法。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolda6h9g8er/monitor_bh.jpg\" width=\"475\" height=\"316\" /></p>\n<p></p>\n<p><strong>6、while和if</strong></p>\n<p></p>\n<ul><li>该篇文章的Hoare语义&#xff0c;因为立即转移控制权&#xff0c;用if即可。</li><li>该篇文章的Mesa语义&#xff08;是否为课件所说的Hansen&#xff1f;&#xff09;下&#xff0c;线程A放入就绪队列后&#xff0c;线程B没有立即移交控制权&#xff0c;线程B接下来的操作可能破坏线程A的条件&#xff0c;因此要用while保证。</li><li>该篇文章的Hansen语义&#xff1a;与Hoare一样立即转移控制权&#xff0c;用if即可。</li></ul>\n<p></p>\n<ul><li>课件的Hoare&#xff1a;就是该篇文章的Hoare&#xff0c;用if。</li><li>课件的Hansen&#xff1a;应该是该篇文章的Mesa&#xff0c;用while。</li></ul>\n<p></p>\n<p></p>\n<p>操作系统博大精深&#xff0c;百家争鸣&#xff0c;不同资料讲的可能不一样&#xff0c;希望老师和同学们批评指正。</p>\n<p></p>", "anon": "no", "created": "2016-05-25T05:28:48Z", "uid": "i0ccfx63sir1e", "subject": "管程的相关讨论"}, {"content": "<p></p>\n<p>昨晚我们班在寝室里交流操作系统&#xff0c;其中管程部分感觉还不太清楚&#xff0c;<strong>Hansen和Hoare的区别是什么&#xff1f;用while、if的原因是什么&#xff1f;</strong></p>\n<p></p>\n<p>今天看了一份cmu的这部分材料&#xff0c;与课件讲的有些地方不一样。希望老师给予点评&#xff0c;以示正听。</p>\n<p><a href=\"https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html\">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>\n<p></p>\n<p><strong>1、管程的定义</strong></p>\n<p></p>\n<p>A programmer can put functions/procedures/methods into this box and the monitor makes him a very simple guarantee: only one function within the monitor will execute at a time -- mutual exclusion will be guaranteed.</p>\n<p></p>\n<p>管程是一个黑盒&#xff0c;程序员往里扔的函数&#xff0c;它确保在同一时刻&#xff0c;只有一个函数在执行。即确保互斥。</p>\n<p></p>\n<p>既然同时只可能有一个程序在执行&#xff0c;自然也就保证了共享数据的同步安全。</p>\n<p></p>\n<p><strong>2、管程有三种语义</strong></p>\n<p></p>\n<p>Mesa Semantics&#xff0c;Hoare Semantics&#xff0c;Brinch Hanson Semantics</p>\n<p></p>\n<p>后面的分析涉及三个队列&#xff1a;<br />Wait Queue&#xff1a;等待队列<br />Entry Queue&#xff1a;可以理解为就绪队列<br />Signal Queue&#xff1a;执行signal操作后&#xff0c;线程放入该队列&#xff08;Hoare才有&#xff09;</p>\n<p></p>\n<p>Now let me suggest that while a second thread is running in the monitor, it frees a resource required by the first. It signals that the resource that the first thread is waiting for becomes available. What should happen? Should the first thread be immediately awakened or should the second thread finish first? This situation gives rise to different versions of monitor sematics.</p>\n<p></p>\n<p>后面的例子是这样的情形&#xff0c;看三种语义的处理方式&#xff1a;<br />线程A等待资源R&#xff0c;在wait队列&#xff0c;这时线程B signal资源R会发生什么&#xff1f;</p>\n<p></p>\n<p><strong>3、Mesa Semantics</strong></p>\n<p></p>\n<p>With Mesa semantics, when the first thread&#39;s resource becomes available, it is moved from the signal queue back to the entry queue. The second thread finishes executing, and the first thread will eventually be processes from the entry queue.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程A从wait队列放入entry队列&#xff0c;线程B继续执行。</p>\n<p></p>\n<p>课件中没有说明Mesa&#xff0c;但该描述就像课件的Hansen。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold109811e3/monitor_mesa.jpg\" width=\"514\" height=\"317\" /></p>\n<p></p>\n<p><strong>4、Hoare Semantics</strong></p>\n<p></p>\n<p>If the first thread&#39;s condition is satisfied, it should immediatly execute.</p>\n<p></p>\n<p>Hoare的思想是&#xff0c;如果线程资源满足了&#xff0c;就应该马上执行。</p>\n<p></p>\n<p>The second thread is put into a signal queue. When a thread exits the monitor, a thread from the signal queue is restarted. Only when the signal queue is empty, is the entry queue used. This approach is more compilcated, but leads to some nicer proofs.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程B放入signal队列&#xff0c;线程A执行。每次有线程退出时&#xff0c;先到signal队列中调度线程&#xff0c;如果signal队列空&#xff0c;才到entry队列调度线程。</p>\n<p></p>\n<p>这个和课件讲的Hoare一样。ucore代码也有类似signal队列的概念。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold9fguc9bw/monitor_hoare.jpg\" width=\"488\" height=\"324\" /></p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolddpkufmhw/屏幕快照_20160524_下午7.18.34.png\" width=\"158\" height=\"85\" /></p>\n<p></p>\n<p><strong>5、Hanson Semantics</strong></p>\n<p></p>\n<p>The Brinch Hansen monitor only allows a process or thread to signal upon exit from the monitor. At that point, the signaled process or thread can run; the signalling process has already left the monitor.</p>\n<p></p>\n<p>线程B退出的同时&#xff0c;signal资源R。&#xff08;应该就是说&#xff0c;过程中没有signal操作&#xff0c;退出的同时signal&#xff09;</p>\n<p></p>\n<p>课件没有讲过“signal upon exit”这种做法。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolda6h9g8er/monitor_bh.jpg\" width=\"475\" height=\"316\" /></p>\n<p></p>\n<p><strong>6、while和if</strong></p>\n<p></p>\n<ul><li>该篇文章的Hoare语义&#xff0c;因为立即转移控制权&#xff0c;用if即可。</li><li>该篇文章的Mesa语义&#xff08;是否为课件所说的Hansen&#xff1f;&#xff09;下&#xff0c;线程A放入就绪队列后&#xff0c;线程B没有立即移交控制权&#xff0c;线程B接下来的操作可能破坏线程A的条件&#xff0c;因此要用while保证。</li><li>该篇文章的Hansen语义&#xff1a;与Hoare一样立即转移控制权&#xff0c;用if即可。</li></ul>\n<p></p>\n<ul><li>课件的Hoare&#xff1a;就是该篇文章的Hoare&#xff0c;用if。</li><li>课件的Hansen&#xff1a;应该是该篇文章的Mesa&#xff0c;用while。</li></ul>\n<p></p>\n<p></p>\n<p>操作系统博大精深&#xff0c;百家争鸣&#xff0c;不同资料讲的可能不一样&#xff0c;希望老师和同学们批评指正。</p>\n<p></p>", "anon": "no", "created": "2016-05-25T04:21:48Z", "uid": "hdjonbiyfs62ie", "subject": "管程的相关讨论"}, {"content": "<p></p>\n<p>昨晚我们班在寝室里交流操作系统&#xff0c;其中管程部分感觉还不太清楚&#xff0c;<strong>Hansen和Hoare的区别是什么&#xff1f;用while、if的原因是什么&#xff1f;</strong></p>\n<p></p>\n<p>今天看了一份cmu的这部分材料&#xff0c;与课件讲的有些地方不一样。希望老师给予点评&#xff0c;以示正听。</p>\n<p><a href=\"https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html\">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>\n<p></p>\n<p><strong>1、管程的定义</strong></p>\n<p></p>\n<p>A programmer can put functions/procedures/methods into this box and the monitor makes him a very simple guarantee: only one function within the monitor will execute at a time -- mutual exclusion will be guaranteed.</p>\n<p></p>\n<p>管程是一个黑盒&#xff0c;程序员往里扔的函数&#xff0c;它确保在同一时刻&#xff0c;只有一个函数在执行。即确保互斥。</p>\n<p></p>\n<p>既然同时只可能有一个程序在执行&#xff0c;自然也就保证了共享数据的同步安全。</p>\n<p></p>\n<p><strong>2、管程有三种语义</strong></p>\n<p></p>\n<p>Mesa Semantics&#xff0c;Hoare Semantics&#xff0c;Brinch Hanson Semantics</p>\n<p></p>\n<p>后面的分析涉及三个队列&#xff1a;<br />Wait Queue&#xff1a;等待队列<br />Entry Queue&#xff1a;可以理解为就绪队列<br />Signal Queue&#xff1a;执行signal操作后&#xff0c;线程放入该队列&#xff08;Hoare才有&#xff09;</p>\n<p></p>\n<p>Now let me suggest that while a second thread is running in the monitor, it frees a resource required by the first. It signals that the resource that the first thread is waiting for becomes available. What should happen? Should the first thread be immediately awakened or should the second thread finish first? This situation gives rise to different versions of monitor sematics.</p>\n<p></p>\n<p>后面的例子是这样的情形&#xff0c;看三种语义的处理方式&#xff1a;<br />线程A等待资源R&#xff0c;在wait队列&#xff0c;这时线程B signal资源R会发生什么&#xff1f;</p>\n<p></p>\n<p><strong>3、Mesa Semantics</strong></p>\n<p></p>\n<p>With Mesa semantics, when the first thread&#39;s resource becomes available, it is moved from the signal queue back to the entry queue. The second thread finishes executing, and the first thread will eventually be processes from the entry queue.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程A从wait队列放入entry队列&#xff0c;线程B继续执行。</p>\n<p></p>\n<p>课件中没有说明Mesa&#xff0c;但该描述就像课件的Hansen。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold109811e3/monitor_mesa.jpg\" width=\"514\" height=\"317\" /></p>\n<p></p>\n<p><strong>4、Hoare Semantics</strong></p>\n<p></p>\n<p>If the first thread&#39;s condition is satisfied, it should immediatly execute.</p>\n<p></p>\n<p>Hoare的思想是&#xff0c;如果线程资源满足了&#xff0c;就应该马上执行。</p>\n<p></p>\n<p>The second thread is put into a signal queue. When a thread exits the monitor, a thread from the signal queue is restarted. Only when the signal queue is empty, is the entry queue used. This approach is more compilcated, but leads to some nicer proofs.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程B放入signal队列&#xff0c;线程A执行。每次有线程退出时&#xff0c;先到signal队列中调度线程&#xff0c;如果signal队列空&#xff0c;才到entry队列调度线程。</p>\n<p></p>\n<p>这个和课件讲的Hoare一样。ucore代码也有类似signal队列的概念。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold9fguc9bw/monitor_hoare.jpg\" width=\"488\" height=\"324\" /></p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolddpkufmhw/屏幕快照_20160524_下午7.18.34.png\" width=\"158\" height=\"85\" /></p>\n<p></p>\n<p><strong>5、Hanson Semantics</strong></p>\n<p></p>\n<p>The Brinch Hansen monitor only allows a process or thread to signal upon exit from the monitor. At that point, the signaled process or thread can run; the signalling process has already left the monitor.</p>\n<p></p>\n<p>线程B退出的同时&#xff0c;signal资源R。&#xff08;应该就是说&#xff0c;过程中没有signal操作&#xff0c;退出的同时signal&#xff09;</p>\n<p></p>\n<p>课件没有讲过“signal upon exit”这种做法。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolda6h9g8er/monitor_bh.jpg\" width=\"475\" height=\"316\" /></p>\n<p></p>\n<p><strong>6、while和if</strong></p>\n<p></p>\n<ul><li>该篇文章的Hoare语义&#xff0c;因为立即转移控制权&#xff0c;用if即可。</li><li>该篇文章的Mesa语义&#xff08;是否为课件所说的Hansen&#xff1f;&#xff09;下&#xff0c;线程A放入就绪队列后&#xff0c;线程B没有立即移交控制权&#xff0c;线程B接下来的操作可能破坏线程A的条件&#xff0c;因此要用while保证。</li><li>该篇文章的Hansen语义&#xff1a;与Hoare一样立即转移控制权&#xff0c;用if即可。</li></ul>\n<p></p>\n<ul><li>课件的Hoare&#xff1a;就是该篇文章的Hoare&#xff0c;用if。</li><li>课件的Hansen&#xff1a;应该是该篇文章的Mesa&#xff0c;用while。</li></ul>\n<p></p>\n<p></p>\n<p>操作系统博大精深&#xff0c;百家争鸣&#xff0c;不同资料讲的可能不一样&#xff0c;希望老师和同学们批评指正。</p>\n<p></p>", "anon": "no", "created": "2016-05-24T11:54:01Z", "uid": "i0ccfx63sir1e", "subject": "管程的相关讨论"}, {"content": "<p></p>\n<p>昨晚我们班在寝室里交流操作系统&#xff0c;其中管程部分感觉还不太清楚&#xff0c;<strong>Hansen和Hoare的区别是什么&#xff1f;用while、if的原因是什么&#xff1f;</strong></p>\n<p></p>\n<p>今天看了一份cmu的这部分材料&#xff0c;与课件讲的有些地方不一样。希望老师给予点评&#xff0c;以示正听。</p>\n<p><a href=\"https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html\">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>\n<p></p>\n<p><strong>1、管程的定义</strong></p>\n<p></p>\n<p>A programmer can put functions/procedures/methods into this box and the monitor makes him a very simple guarantee: only one function within the monitor will execute at a time -- mutual exclusion will be guaranteed.</p>\n<p></p>\n<p>管程是一个黑盒&#xff0c;程序员往里扔的函数&#xff0c;它确保在同一时刻&#xff0c;只有一个函数在执行。即确保互斥。</p>\n<p></p>\n<p>既然同时只可能有一个程序在执行&#xff0c;自然也就保证了共享数据的同步安全。</p>\n<p></p>\n<p><strong>2、管程有三种语义</strong></p>\n<p></p>\n<p>Mesa Semantics&#xff0c;Hoare Semantics&#xff0c;Brinch Hanson Semantics</p>\n<p></p>\n<p>后面的分析涉及三个队列&#xff1a;<br />Wait Queue&#xff1a;等待队列<br />Entry Queue&#xff1a;可以理解为就绪队列<br />Signal Queue&#xff1a;执行signal操作后&#xff0c;线程放入该队列&#xff08;Hoare才有&#xff09;</p>\n<p></p>\n<p>Now let me suggest that while a second thread is running in the monitor, it frees a resource required by the first. It signals that the resource that the first thread is waiting for becomes available. What should happen? Should the first thread be immediately awakened or should the second thread finish first? This situation gives rise to different versions of monitor sematics.</p>\n<p></p>\n<p>后面的例子这样的情形&#xff0c;看三种语义的处理方式&#xff1a;<br />线程A等待资源R&#xff0c;在wait队列&#xff1b;线程B signal资源R&#xff1b;会发生什么&#xff1f;</p>\n<p></p>\n<p><strong>3、Mesa Semantics</strong></p>\n<p></p>\n<p>With Mesa semantics, when the first thread&#39;s resource becomes available, it is moved from the signal queue back to the entry queue. The second thread finishes executing, and the first thread will eventually be processes from the entry queue.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程A从wait队列放入entry队列&#xff0c;线程B继续执行。</p>\n<p></p>\n<p>课件中没有说明Mesa&#xff0c;但该描述就像课件的Hansen。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold109811e3/monitor_mesa.jpg\" width=\"514\" height=\"317\" /></p>\n<p></p>\n<p><strong>4、Hoare Semantics</strong></p>\n<p></p>\n<p>If the first thread&#39;s condition is satisfied, it should immediatly execute.</p>\n<p></p>\n<p>Hoare的思想是&#xff0c;如果线程资源满足了&#xff0c;就应该马上执行。</p>\n<p></p>\n<p>The second thread is put into a signal queue. When a thread exits the monitor, a thread from the signal queue is restarted. Only when the signal queue is empty, is the entry queue used. This approach is more compilcated, but leads to some nicer proofs.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程B放入signal队列&#xff0c;线程A执行。每次有线程退出时&#xff0c;先到signal队列中调度线程&#xff0c;如果signal队列空&#xff0c;才到entry队列调度线程。</p>\n<p></p>\n<p>这个和课件讲的Hoare一样。ucore代码也有类似signal队列的概念。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold9fguc9bw/monitor_hoare.jpg\" width=\"488\" height=\"324\" /></p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolddpkufmhw/屏幕快照_20160524_下午7.18.34.png\" width=\"158\" height=\"85\" /></p>\n<p></p>\n<p><strong>5、Hanson Semantics</strong></p>\n<p></p>\n<p>The Brinch Hansen monitor only allows a process or thread to signal upon exit from the monitor. At that point, the signaled process or thread can run; the signalling process has already left the monitor.</p>\n<p></p>\n<p>线程B退出的同时&#xff0c;signal资源R。&#xff08;应该就是说&#xff0c;过程中没有signal操作&#xff0c;退出的同时signal&#xff09;</p>\n<p></p>\n<p>课件没有讲过“signal upon exit”这种做法。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolda6h9g8er/monitor_bh.jpg\" width=\"475\" height=\"316\" /></p>\n<p></p>\n<p><strong>6、while和if</strong></p>\n<p></p>\n<ul><li>该篇文章的Hoare语义&#xff0c;因为立即转移控制权&#xff0c;用if即可。</li><li>该篇文章的Mesa语义&#xff08;是否为课件所说的Hansen&#xff1f;&#xff09;下&#xff0c;线程A放入就绪队列后&#xff0c;线程B没有立即移交控制权&#xff0c;线程B接下来的操作可能破坏线程A的条件&#xff0c;因此要用while保证。</li><li>该篇文章的Hansen语义&#xff1a;与Hoare一样立即转移控制权&#xff0c;用if即可。</li></ul>\n<p></p>\n<ul><li>课件的Hoare&#xff1a;就是该篇文章的Hoare&#xff0c;用if。</li><li>课件的Hansen&#xff1a;应该是该篇文章的Mesa&#xff0c;用while。</li></ul>\n<p></p>\n<p></p>\n<p>操作系统博大精深&#xff0c;百家争鸣&#xff0c;不同资料讲的可能不一样&#xff0c;希望老师和同学们批评指正。</p>\n<p></p>", "anon": "no", "created": "2016-05-24T11:42:16Z", "uid": "i0ccfx63sir1e", "subject": "管程的相关讨论"}, {"content": "<p></p>\n<p>昨晚我们班在寝室里交流操作系统&#xff0c;其中管程部分感觉还不太清楚&#xff0c;<strong>Hansen和Hoare的区别是什么&#xff1f;用while、if的原因是什么&#xff1f;</strong></p>\n<p></p>\n<p>今天看了一份cmu的这部分材料&#xff0c;与课件讲的有些地方不一样。希望老师给予点评&#xff0c;以示正听。</p>\n<p><a href=\"https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html\">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>\n<p></p>\n<p><strong>1、管程的定义</strong></p>\n<p></p>\n<p>A programmer can put functions/procedures/methods into this box and the monitor makes him a very simple guarantee: only one function within the monitor will execute at a time -- mutual exclusion will be guaranteed.</p>\n<p></p>\n<p>管程是一个黑盒&#xff0c;程序员往里扔的函数&#xff0c;它确保在同一时刻&#xff0c;只有一个函数在执行。即确保互斥。</p>\n<p></p>\n<p>既然同时只可能有一个程序在执行&#xff0c;自然也就保证了共享数据的同步安全。</p>\n<p></p>\n<p><strong>2、管程有三种语义</strong></p>\n<p></p>\n<p>Mesa Semantics&#xff0c;Hoare Semantics&#xff0c;Brinch Hanson Semantics</p>\n<p></p>\n<p>后面的分析涉及三个队列&#xff1a;<br />Wait Queue&#xff1a;等待队列<br />Entry Queue&#xff1a;可以理解为就绪队列<br />Signal Queue&#xff1a;执行signal操作后&#xff0c;线程放入该队列&#xff08;Hoare才有&#xff09;</p>\n<p></p>\n<p>后面的例子这样的情形&#xff0c;看三种语义的处理方式&#xff1a;<br />线程A等待资源R&#xff0c;在wait队列&#xff1b;线程B signal资源R。</p>\n<p></p>\n<p><strong>3、Mesa Semantics</strong></p>\n<p></p>\n<p>With Mesa semantics, when the first thread&#39;s resource becomes available, it is moved from the signal queue back to the entry queue. The second thread finishes executing, and the first thread will eventually be processes from the entry queue.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程A从wait队列放入entry队列&#xff0c;线程B继续执行。</p>\n<p></p>\n<p>课件中没有说明Mesa&#xff0c;但该描述就像课件的Hansen。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold109811e3/monitor_mesa.jpg\" width=\"514\" height=\"317\" /></p>\n<p></p>\n<p><strong>4、Hoare Semantics</strong></p>\n<p></p>\n<p>If the first thread&#39;s condition is satisfied, it should immediatly execute.</p>\n<p></p>\n<p>Hoare的思想是&#xff0c;如果线程资源满足了&#xff0c;就应该马上执行。</p>\n<p></p>\n<p>The second thread is put into a signal queue. When a thread exits the monitor, a thread from the signal queue is restarted. Only when the signal queue is empty, is the entry queue used. This approach is more compilcated, but leads to some nicer proofs.</p>\n<p></p>\n<p>线程B signal资源R后&#xff0c;线程B放入signal队列&#xff0c;线程A执行。每次有线程退出时&#xff0c;先到signal队列中调度线程&#xff0c;如果signal队列空&#xff0c;才到entry队列调度线程。</p>\n<p></p>\n<p>这个和课件讲的Hoare一样。ucore代码也有类似signal队列的概念。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iold9fguc9bw/monitor_hoare.jpg\" width=\"488\" height=\"324\" /></p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolddpkufmhw/屏幕快照_20160524_下午7.18.34.png\" width=\"158\" height=\"85\" /></p>\n<p></p>\n<p><strong>5、Hanson Semantics</strong></p>\n<p></p>\n<p>The Brinch Hansen monitor only allows a process or thread to signal upon exit from the monitor. At that point, the signaled process or thread can run; the signalling process has already left the monitor.</p>\n<p></p>\n<p>线程B退出的同时&#xff0c;signal资源R。&#xff08;应该就是说&#xff0c;过程中没有signal操作&#xff0c;退出的同时signal&#xff09;</p>\n<p></p>\n<p>课件没有讲过“signal upon exit”这种做法。</p>\n<p></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/iolda6h9g8er/monitor_bh.jpg\" width=\"475\" height=\"316\" /></p>\n<p></p>\n<p><strong>6、while和if</strong></p>\n<p></p>\n<ul><li>该篇文章的Hoare语义&#xff0c;因为立即转移控制权&#xff0c;用if即可。</li><li>该篇文章的Mesa语义&#xff08;是否为课件所说的Hansen&#xff1f;&#xff09;下&#xff0c;线程A放入就绪队列后&#xff0c;线程B没有立即移交控制权&#xff0c;线程B接下来的操作可能破坏线程A的条件&#xff0c;因此要用while保证。</li><li>该篇文章的Hansen语义&#xff1a;与Hoare一样立即转移控制权&#xff0c;用if即可。</li></ul>\n<p></p>\n<ul><li>课件的Hoare&#xff1a;就是该篇文章的Hoare&#xff0c;用if。</li><li>课件的Hansen&#xff1a;应该是该篇文章的Mesa&#xff0c;用while。</li></ul>\n<p></p>\n<p></p>\n<p>操作系统博大精深&#xff0c;百家争鸣&#xff0c;不同资料讲的可能不一样&#xff0c;希望老师和同学们批评指正。</p>\n<p></p>", "anon": "no", "created": "2016-05-24T11:40:23Z", "uid": "i0ccfx63sir1e", "subject": "管程的相关讨论"}]}, "error": null}