{"aid": "iod0z3n6jzr69g", "result": {"folders": ["lecture19"], "unique_views": 70, "no_answer": 0, "change_log": [{"data": "io8kp1ryt4y5va", "anon": "no", "when": "2016-05-15T12:43:40Z", "uid": "i0iaabhcht167g", "type": "create"}, {"uid": "i0c90j8pjf56sn", "data": "io8opqvh4vf6rc", "when": "2016-05-15T14:36:11Z", "to": "io8kp1rw93n5v9", "anon": "no", "type": "s_answer"}, {"data": "io8oqad4jkh3uv", "anon": "no", "when": "2016-05-15T14:36:36Z", "uid": "i0c90j8pjf56sn", "type": "s_answer_update"}, {"uid": "hcrrjuyequh4bt", "data": "iocfo5doqcq6xm", "when": "2016-05-18T05:34:04Z", "to": "io8kp1rw93n5v9", "anon": "no", "type": "i_answer"}, {"data": "iocfp0air1h76l", "anon": "no", "when": "2016-05-18T05:34:44Z", "uid": "hcrrjuyequh4bt", "type": "i_answer_update"}, {"data": "iocfp8oixes7jd", "anon": "no", "when": "2016-05-18T05:34:55Z", "uid": "hcrrjuyequh4bt", "type": "i_answer_update"}, {"to": "io8kp1rw93n5v9", "anon": "no", "when": "2016-05-18T08:12:05Z", "uid": "i0c90j8pjf56sn", "type": "followup"}], "upvote_ids": [], "id": "io8kp1rw93n5v9", "bookmarked": 6, "no_answer_followup": 1, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-05-15T14:36:11Z", "config": {}, "tag_endorse_arr": ["hcrrjuyequh4bt"], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [{"admin_permission": 10, "admin": true, "photo": "1378950179_35.png", "us": false, "email": "yuchen@mail.tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "id": "hcrrjuyequh4bt", "name": "Yu Chen"}], "bucket_order": 2, "data": {"embed_links": []}, "id": "io8opqvdtwa6rb", "history": [{"content": "<p>如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p>就不会有这个问题。</p>\n<p></p>\n<p>所以我的理解是&#xff0c;尽管一个进程&#xff08;A&#xff09;signal释放了另一个进程&#xff08;B&#xff09;的资源后&#xff0c;B进程应当在用完后把控制权还给A&#xff08;next_count--&#xff09;&#xff0c;而不是继续使用。</p>\n<p>&#xff08;即使用权的交接以临界区为单位&#xff0c;而不是以进程为单位。&#xff09;</p>\n<p></p>\n<p>这就是之前陈渝老师说的</p>\n<p></p>\n<blockquote>\n<p>这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;</p>\n</blockquote>\n<p></p>\n<p></p>", "anon": "no", "subject": "", "uid": "i0c90j8pjf56sn", "created": "2016-05-15T14:36:36Z"}, {"content": "<p>我的理解是&#xff0c;如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p>就不会有这个问题。</p>\n<p></p>\n<p>所以我的理解是尽管一个进程&#xff08;A&#xff09;signal释放了另一个进程&#xff08;B&#xff09;的资源后&#xff0c;B进程应当在用完后把控制权还给A&#xff08;next_count--&#xff09;&#xff0c;而不是继续使用。</p>\n<p>&#xff08;即使用权的交接以临界区为单位&#xff0c;而不是以进程为单位。&#xff09;</p>\n<p></p>\n<p>这就是之前陈渝老师说的</p>\n<p></p>\n<blockquote>\n<p>这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;</p>\n</blockquote>\n<p></p>\n<p></p>", "anon": "no", "subject": "", "uid": "i0c90j8pjf56sn", "created": "2016-05-15T14:36:11Z"}]}, {"folders": [], "is_tag_endorse": false, "created": "2016-05-18T05:34:04Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "i_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "iocfo5dnr1k6xl", "history": [{"content": "<p>Q: 如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p></p>\n<p>我理解,如果加上上述语句&#xff0c;代码就不对了&#xff0c;因为如果执行了&#xff02; up(&amp;(mtp-&gt;mutex));&#xff02;OR&#xff02; up(&amp;(mtp-&gt;next));&#xff02; 则管程中函数应该只被一个进程执行的限制就被打破了&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;根据你列举的实例&#xff0c;next_count会大于1&#xff0e;　</p>", "anon": "no", "subject": "", "uid": "hcrrjuyequh4bt", "created": "2016-05-18T05:34:55Z"}, {"content": "<p>Q: 如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p></p>\n<p>我理解,如果加上上述语句&#xff0c;代码就不对了&#xff0c;因为如果执行了&#xff02; up(&amp;(mtp-&gt;mutex));&#xff02;OR&#xff02; up(&amp;(mtp-&gt;next));&#xff02; 则管程中函数应该只被一个进程执行的限制就被打破了&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;根据你的列举的实例&#xff0c;next_count会大于1&#xff0e;　</p>", "anon": "no", "subject": "", "uid": "hcrrjuyequh4bt", "created": "2016-05-18T05:34:44Z"}, {"content": "<p>Q: 如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p></p>\n<p>我理解,如果加上上述语句&#xff0c;代码就不对了&#xff0c;因为如果执行了&#xff02; up(&amp;(mtp-&gt;mutex));&#xff02;OR&#xff02; up(&amp;(mtp-&gt;next));&#xff02; 则管程中函数应该只被一个进程执行的限制就被打破了&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;根据你的举例&#xff0c;next_count会大于1&#xff0e;　</p>", "anon": "no", "subject": "", "uid": "hcrrjuyequh4bt", "created": "2016-05-18T05:34:04Z"}]}, {"folders": [], "updated": "2016-05-18T08:12:05Z", "no_upvotes": 0, "uid": "i0c90j8pjf56sn", "created": "2016-05-18T08:12:05Z", "type": "followup", "no_answer": 1, "id": "ioclbcy3lie60", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>我的意思是以临界区为单位&#xff0c;所以释放之后还要再acquire一次mutex</p>"}], "request_instructor_me": false, "nr": 866, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lecture19", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-05-15T12:43:40Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1463585427762, "tag_good": [{"admin_permission": 10, "admin": true, "photo": "1378950179_35.png", "us": false, "email": "yuchen@mail.tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "id": "hcrrjuyequh4bt", "name": "Yu Chen"}], "tag_good_arr": ["hcrrjuyequh4bt"], "history": [{"content": "<p>在完成lab7的时候突然考虑到ucore实现中一种情况可能会导致管程next_count大于1&#xff0c;但课上课下老师和同学说next_count不会大于1&#xff08;我之前也一直认为不会大于1&#xff09;</p>\n<p>构造这种情况需要使用3个线程a,b,c、2个条件c1,c2&#xff0c;对应函数大概如下</p>\n<ul><li>func_a(): wait(c1)</li><li>func_b(): wait(c2) signal(c1)</li><li>func_c(): signal(c2&#xff09;</li></ul>\n<p></p>\n<p>假设abc依次执行。</p>\n<ol><li>线程a遇到条件c1阻塞&#xff0c;于是在wait中关闭互斥锁。</li><li>线程b进入&#xff0c;遇到条件c2阻塞&#xff0c;并在wait中关闭互斥锁。</li><li>线程c进入&#xff0c;在signal函数中up条件c2的信号量&#xff0c;并down信号量next阻塞&#xff08;Hoare机制&#xff09;&#xff0c;next_count为1</li><li>线程b继续执行&#xff0c;在signal函数中由于c1被线程a需求&#xff0c;于是线程b会up条件c1的信号量&#xff0c;并down信号量next阻塞&#xff0c;此时&#xff0c;next被down了两次&#xff0c;对应next_count为2</li><li>线程a结束&#xff0c;结束时唤醒线程b&#xff0c;唤醒后next_count减为1</li><li>线程b结束&#xff0c;结束时唤醒线程c&#xff0c;唤醒后next_count为0</li><li>线程c结束&#xff0c;关闭互斥锁</li></ol>\n<p></p>", "anon": "no", "subject": "关于ucore管程实现中next_count的想法", "uid": "i0iaabhcht167g", "created": "2016-05-15T12:43:40Z"}]}, "error": null}