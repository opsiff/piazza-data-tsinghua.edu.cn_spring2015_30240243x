{"aid": "j2pqkca4m2y1j6", "result": {"status": "active", "unique_views": 43, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-04-24T03:59:44Z", "data": "j1vlgaw5cb6566", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:01:26Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:01:35Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:01:53Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:01:56Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:02:06Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:02:15Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:02:27Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:02:36Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:02:45Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-24T04:03:01Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T00:54:38Z", "type": "feedback", "uid": "izb0cbqbyzd6wf"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T00:55:47Z", "type": "feedback", "uid": "ie7xy0nh1811ls"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:05:16Z", "type": "feedback", "uid": "itiooztjq0i1fk"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:05:48Z", "type": "feedback", "uid": "ie7xy1yxmql1n8"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:13:46Z", "type": "feedback", "uid": "izb0cbqbyzd6wf"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:18:19Z", "type": "feedback", "uid": "ie7xy1yxmql1n8"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:28:02Z", "type": "feedback", "uid": "ie7xxz4di3o1ke"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:28:12Z", "type": "feedback", "uid": "ie7xy6ut1rx1rv"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T01:32:10Z", "type": "feedback", "uid": "ierwkwdnmr42ta"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-04-25T03:07:48Z", "type": "feedback", "uid": "ie7xy49etbi1pg"}, {"to": "j1vlgaw2fk5565", "anon": "no", "when": "2017-05-04T03:57:48Z", "type": "feedback", "uid": "ie7xy8gtpwk1t5"}], "upvote_ids": [], "id": "j1vlgaw2fk5565", "bookmarked": 10, "tags": ["2017", "instructor-note", "lecture17", "课堂问答"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2017-04-24T04:01:26Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:01:26Z", "type": "followup", "no_answer": 0, "id": "j1vlii14jw94gz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T01:05:16Z", "uid": "itiooztjq0i1fk", "created": "2017-04-25T01:05:16Z", "type": "feedback", "id": "j1wunssuc5waw", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>答&#xff1a; 有误. 有一进程 i 进入临界区后退出临界区&#xff0c;这时把turn 改为 j &#xff0c; 那么这时进程 i 再次想进去临界区就不可以的&#xff08;因为turn为j 进程id为i&#xff09;&#xff0c;所以有误。</p>"}], "subject": "<p>选择“第4小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:01:35Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:01:35Z", "type": "followup", "no_answer": 0, "id": "j1vliow2jrh4kn", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T01:32:10Z", "uid": "ierwkwdnmr42ta", "created": "2017-04-25T01:32:10Z", "type": "feedback", "id": "j1wvme51ts1vg", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p><code>错误。</code></p>\n<p><code>flags[i] = FREE 且 flags[j] = FREE, 两个进程都通过了while循环&#xff0c;然后flags[i] = BUSY 且 flags[j] = BUSY. 然后两个进程同时进入了临界区。</code></p>"}], "subject": "<p>选择“第5小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:01:53Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:01:53Z", "type": "followup", "no_answer": 0, "id": "j1vlj2hcliq2qf", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T00:54:38Z", "uid": "izb0cbqbyzd6wf", "created": "2017-04-25T00:54:38Z", "type": "feedback", "id": "j1wua4fkbq94mz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>错的. </p>\n<p></p>\n<p>两边都执行 Flags[i] = BUSY.</p>\n<p></p>\n<p>然后两边后面的 while 都是死循环.</p>"}, {"folders": [], "updated": "2017-04-25T00:55:47Z", "uid": "ie7xy0nh1811ls", "created": "2017-04-25T00:55:47Z", "type": "feedback", "id": "j1wublq5ly33r1", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>这种同步机制不可行。</p>\n<p>如果进程i先执行flags[i] = BUSY&#xff0c;接下来切换到进程j&#xff0c;进程j执行flags[i] = BUSY&#xff0c;此时无论之后是否发生进程切换&#xff0c;两个进程都会卡在while(flags[i] == BUSY)。</p>"}], "subject": "<p>选择“第6小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:01:56Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:01:56Z", "type": "followup", "no_answer": 0, "id": "j1vlj58frqe4tx", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T01:05:48Z", "uid": "ie7xy1yxmql1n8", "created": "2017-04-25T01:05:48Z", "type": "feedback", "id": "j1wuohl2x7fv7", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>这里主要是没有机制来区分开i和j的状态&#xff0c;也就是i和j有可能一直保持运行于同一行&#xff0c;即便delay a while是一段随机的时间&#xff0c;也无法排除这一点。所以&#xff0c;有可能所有的都不断地位于这个循环之中&#xff0c;导致死锁</p>"}, {"folders": [], "updated": "2017-04-25T01:18:19Z", "uid": "ie7xy1yxmql1n8", "created": "2017-04-25T01:18:19Z", "type": "feedback", "id": "j1wv4l4mfpv7db", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>比如这样一种情况&#xff0c;i和j都从代码第一行开始&#xff0c;i运行一行后切换到j运行&#xff0c;然后j也只运行一行就切换到i&#xff0c;以此方式执行下去&#xff0c;最终会导致两者都在while循环中永远出不去&#xff0c;具体执行为&#xff1a;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i ENTRY -&gt; j ENTRY -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 进入while -&gt; j 进入 while -&gt;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i delay a while -&gt; j delay a while -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 又进入while -&gt; j 又进入while......</p>"}], "subject": "<p>选择“第7小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:02:06Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:02:06Z", "type": "followup", "no_answer": 0, "id": "j1vljckc9wi6z8", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T01:28:12Z", "uid": "ie7xy6ut1rx1rv", "created": "2017-04-25T01:28:12Z", "type": "feedback", "id": "j1wvhadtfbs5kt", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>这个算法没有错。</p>\n<p>假设同时有多个进程尝试进入临界区&#xff0c;如果此时有一个Flag先于其他被设置为busy&#xff0c;则该进程顺利进入临界区&#xff0c;其他进程都会陷入循环里。假设有多个Flag同时被设置为busy&#xff0c;那么多个进程同时进入循环&#xff0c;但非进程i会进入小循环从而释放自己的Flag&#xff0c;从而进程退出大循环&#xff0c;只有进程i进入了临界区。因此当临界区空闲时有且仅有一个程序进入临界区。</p>\n<p></p>\n<p>退出的时候会释放自己的flag&#xff0c;并将turn设置为其他程序的进程号&#xff0c;从而允许其他进程进入临界区。</p>"}], "subject": "<p>选择“第8小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:02:15Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:02:15Z", "type": "followup", "no_answer": 0, "id": "j1vljk1kqoj7cy", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T01:28:02Z", "uid": "ie7xxz4di3o1ke", "created": "2017-04-25T01:28:02Z", "type": "feedback", "id": "j1wvh2qzqkr5hj", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p><div>\n<blockquote style=\"color:#777777\">\n<p>此题针对二进程切换。turn的取值只有i和j。<br />while循环中的第二个条件turn != i等价于turn == j&#xff0c;即与peterson算法相同。<br />因此可以解决二进程切换问题。</p>\n</blockquote>\n<p><em>在Peterson算法中&#xff0c;想要进入临界区&#xff0c;必须出while循环。</em></p>\n<p>单进程时&#xff1a;</p>\n<ul><li>对于process i&#xff0c;flag[j]=free&#xff0c;顺利进入临界区。</li></ul>\n<p>双进程时&#xff1a;</p>\n<ol><li>如果process i 先执行了flag[i]=busy&#xff0c;然后切换到j&#xff0c;j执行到while时&#xff0c;turn=i&#xff0c;卡在while进不去。切换到i时&#xff0c;也卡在while无法进入。再切换到j时&#xff0c;j可以进入。即使此临界过程中再切到i&#xff0c;i仍然因为turn=j而无法进入&#xff0c;直到flag[j]=free。</li><li>如果process i 限制性了flag[i]=busy&#xff0c;然后切换到j&#xff0c;j执行了flag[j]=true就切换回来&#xff0c;切换到i&#xff0c;i卡在while。切换到j&#xff0c;j卡在while。切换回i&#xff0c;i可以进入。此时即使切换回j&#xff0c;仍然不可以进入&#xff0c;直到flag[i]=free。</li><li>如果process i 先执行了flag[i]=busy和turn=j&#xff0c;切换到j&#xff0c;j执行到while时&#xff0c;卡住。切换回i&#xff0c;i可以进入。切换到j&#xff0c;j仍然不可进入直到flag[i]=free。</li><li>如果process i 先执行了flag[i]=busy和turn=j&#xff0c;切换到j&#xff0c;j执行了flag[j]=true就切换回来。i卡住。切换到j&#xff0c;j进入临界区。i不可进入直到flag[j]=true。</li></ol>\n<p>总结&#xff1a;</p>\n<ul><li>如果没来得及立flag&#xff0c;则视为单进程情况。</li><li>若立了flag&#xff0c;则turn最终有一个仲裁写入顺序。最后写入的进程将卡住。切换到另外一个进程执行&#xff0c;在此过程中&#xff0c;刚才被卡住的进程无法进入临界区&#xff08;因为turn不满足&#xff09;&#xff0c;直到执行的进程free its flag.</li></ul>\n<div>​</div>\n</div>"}], "subject": "<p>选择“第9小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:02:27Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:02:27Z", "type": "followup", "no_answer": 0, "id": "j1vljsrc4a1562", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-05-04T03:57:48Z", "uid": "ie7xy8gtpwk1t5", "created": "2017-05-04T03:57:48Z", "type": "feedback", "id": "j29vscmx6ro1gm", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p></p><p>我觉得是正确的。如有错误&#xff0c;请指正</p>\n<ol><li>\n<p>一般情况&#xff1a;只有最接近 turn 的一个进程能执行到(1). 执行到 (2) 时 所有进程的 index 指向该进程&#xff0c;该进程退出 Repeat 进入临界区执行。</p>\n</li><li>\n<p>特殊情况&#xff1a;存在多个进程执行到 (1)&#xff0c;假设&#xff1a;</p>\n<ol><li>\n<p>当前turn=0&#xff0c;全idle</p>\n</li><li>\n<p>index=2 的进程 P2 先执行到 (1), flags[2] = ACTIVE</p>\n</li><li>\n<p>随后 index=1 的进程 P1 执行到 (1), flags[1] = ACTIVE</p>\n</li><li>\n<p>P2 执行到 (2), 局部变量 index = 1</p>\n</li><li>\n<p>随后 P1 执行到 (2), 局部变量 index = 2</p>\n</li><li>\n<p>P1、P2 都不满足 until 的退出条件&#xff0c;但此时 flags[1] != IDLE&#xff0c;P2 的下一次循环会被卡在 (1) 之前&#xff0c;回到一般情况。</p>\n</li><li>\n<p>由于这种情况不能无限发生&#xff0c;因此最终将有一进程进入临界区。</p>\n</li></ol></li></ol>\n<pre>  repeat {\n  ​\n          /* announce that we need the resource */\n          flags[i] = WAITING;\n  ​\n          /* scan processes from the one with the turn up to ourselves. */\n          /* repeat if necessary until the scan finds all processes idle */\n          index = turn;\n          while (index != i) {\n              if (flag[index] != IDLE) index = turn;\n              else index = index&#43;1 mod n;\n          }\n  ​\n          /* now tentatively claim the resource */\n          flags[i] = ACTIVE;\n  (1)\n          /* find the first active process besides ourselves, if any */\n          index = 0;\n          while ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {\n              index = index&#43;1;\n          }\n  (2)\n      /* if there were no other active processes, AND if we have the turn\n         or else whoever has it is idle, then proceed.  Otherwise, repeat\n         the whole sequence. */\n      } until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));</pre>"}], "subject": "<p>选择“第10小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:02:36Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:02:36Z", "type": "followup", "no_answer": 0, "id": "j1vlk034cqx2jv", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T01:13:46Z", "uid": "izb0cbqbyzd6wf", "created": "2017-04-25T01:13:46Z", "type": "feedback", "id": "j1wuyq5j4jm78s", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>错的.</p>\n<p></p>\n<p>用一个 flag 来记录每个进程检查所有其它进程锁检查到第几个了.</p>\n<p></p>\n<p>用 turn 表示检查到这一步的最后一个进程是不是自己.</p>\n<p></p>\n<p>每次标完之后等有别的进程都没有检查到我当前的进度, 或者是已经有进程比我快了, 然后就去标下个进程.</p>\n<p></p>\n<p>如果当前进程已经检查完所有其它进程就能进临界区了.</p>\n<p></p>\n<p>如果每次 标 flag - 等待 都是原子操作那么毫无问题.</p>\n<p></p>\n<p>可能出现问题的地方在于, 如果<strong>多于两个</strong>进程都首先把 flags[i] 设为最大, 然后再进入 wait. 这时候 trun 只能是其中一个的 pid. 那么另外的至少两个进程就都进临界区去执行了.</p>\n<p></p>\n<p>补充: 只有两个的时候是正确的.</p>\n<p></p>\n<p>numprocs = 2</p>\n<p></p>\n<p>那么 count 就是 0.</p>\n<p></p>\n<p>分几种情况讨论. 第二个在 wait, 枚举第一个执行到哪里.</p>\n<p></p>\n<ol><li>第一个执行到 flags[i] = count 前面: flags[1] = -1 &lt; count. 可以进临界区. 这时候 turn[2] = 2, flags[1] = 0. 第一个等待直到第二个执行 flags[2] = -1; 没有问题.</li><li>第一个执行到 flags[i] = count 后面: 第二个要等一下, 然后第一个执行 turn[0] = 1, 第二个就可以进临界区了. 然后和上面一样.</li><li>第一个执行到 turn[count] = i 后面: 第二个直接进了. 第一个等第二个完.</li><li>两个换顺序之后是一样的.</li></ol>\n<p></p>\n<p>所以在我能枚举到的情况里都是对的. 所以我姑且认为它是对的.</p>\n<p></p>\n<p></p>"}], "subject": "<p>选择“第11小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:02:45Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:02:45Z", "type": "followup", "no_answer": 0, "id": "j1vlk6xgdd45ce", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2017-04-25T03:07:48Z", "uid": "ie7xy49etbi1pg", "created": "2017-04-25T03:07:48Z", "type": "feedback", "id": "j1wz1dcqx4m7k", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>该算法是正确的&#xff0c;考虑死锁和多个进程进入临界区这两类错误&#xff1a;</p>\n<p>        死锁&#xff1a;</p>\n<p>                可能的死锁点&#xff08;检查点&#xff09;有 ①</p>\n<pre><code>while (choosing[j]) {}</code></pre>\n<p>                                         ②</p>\n<pre><code> if ((num[j] &gt; 0) &amp;&amp;\n          ((num[j] &lt; num[i]) ||\n          (num[j] == num[i]) &amp;&amp; (j &lt; i))) {\n            while (num[j] &gt; 0) {}\n        }</code></pre>\n<p>           1.进程死锁在①&#xff1a;</p>\n<p>                  这是不可能的&#xff0c;因为执行到①处时必然已经执行</p>\n<pre><code>choosing[i] = FALSE;</code></pre>\n<p>           2.进程分别死锁在①&#xff0c;②&#xff1a;</p>\n<p>                  同上&#xff0c;死锁在①是不会发生的。</p>\n<p>           3.进程死锁在②&#xff1a;</p>\n<p>                  在②死锁&#xff0c;首先要满足(num[j] &gt; 0)&#xff0c;这个由num[i] = max(num[0], ..., num[n-1]) &#43; 1;是保证满足的。</p>\n<p>                  其次还要满足(num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))&#xff0c;如果num最小值唯一&#xff0c;则该最小值使得其不满足该条件&#xff0c;拥有该最小值的进程不会被死锁。如果最小值不唯一&#xff0c;则后一个条件必然不被满足&#xff0c;因为不存在序号相同的两个进程&#xff0c;序号最小的进程不会被阻塞。所以不可能有多个进程同时满足该条件&#xff0c;也就不会死锁。</p>\n<p>           所以死锁是不会发生的。</p>\n<p></p>\n<p></p>\n<p><code>   多个进程进入临界区&#xff1a;</code></p>\n<p>         考虑一个进程j进入临界区后&#xff0c;另一个进程i如何跨过检查点进入临界区。</p>\n<p>         检查点①&#xff1a;</p>\n<p>                i抵达该检查点以后&#xff0c;j可能已经执行了</p>\n<pre><code>choosing[i] = FALSE;</code></pre>\n<p>               所以该检查点不能阻挡其他进程。</p>\n<p>        关键在于i,j能否同时通过检查点②&#xff1a;</p>\n<p>               首先看第一个条件(num[j] &gt; 0)&#xff0c;如果j已经通过②&#xff0c;那么num[j] = max(num[0], ..., num[n-1]) &#43; 1;必然已经得以执行&#xff0c;对于i&#xff0c;这个条件是满足的。</p>\n<p>               第二个条件(num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))。如果j通过时num[i]未被赋值&#xff0c;则当num[i]被赋值的时候由于num[j]已经被赋值&#xff0c;所以num[i] &gt; num[j]&#xff0c;这时i会被阻塞。如果j通过时num[i]已经赋值&#xff0c;则由于j能通过&#xff0c;必有num[i] &gt;= num[j]。如果 num[i] &gt; num[j], 则i会被阻塞。如果num[i] == num[j]&#xff0c;因为j能通过&#xff0c;所以 j  &lt;= i。又 j != i&#xff0c;所以j &lt; i&#xff0c;所以i会被阻塞。</p>\n<p>              综上&#xff0c;在j已经通过②时&#xff0c;其他进程将不能通过②&#xff0c;因此也不会发生多个进程进入临界区的错误。</p>\n<p></p>\n<p></p>\n<p></p>"}], "subject": "<p>选择“第12小题”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2017-04-24T04:03:01Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-04-24T04:03:01Z", "type": "followup", "no_answer": 0, "id": "j1vlkiuyfma333", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>选择“第13小题”的同学的回答结果写在此贴后面。</p>"}], "nr": 1060, "bucket_order": 2, "type": "note", "folders": ["2017", "lecture17", "课堂问答"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-04-24T03:59:44Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1494828955948, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>请两人一组完成“第十七讲 同步互斥”中指定小题的回答在此贴中回复&#xff0c;要求每个小组完成约定的两个小题。</p>\n<p></p>\n<p>题目&#xff1a;</p>\n<p></p>\n<p><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html</a> -&gt; 视频相关思考题 -&gt; 17.4 基于软件的同步方法</p>\n<p></p>\n<p>第4至12题&#xff1a;每个小组选做一个自己有兴趣的小题&#xff1b;</p>\n<p>第13题&#xff1a;每个小组必须完成&#xff1b;</p>", "anon": "no", "created": "2017-04-24T03:59:44Z", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十七讲课堂实践练习"}]}, "error": null}