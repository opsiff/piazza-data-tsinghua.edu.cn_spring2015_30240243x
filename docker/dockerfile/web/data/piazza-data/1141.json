{"aid": "jef9rc8631q5jt", "result": {"status": "active", "unique_views": 42, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2018-03-05T15:44:33Z", "data": "jeeec166wee4ig", "uid": "hdjonbiyfs62ie"}, {"to": "jeeec163fj74if", "anon": "no", "when": "2018-03-06T01:20:16Z", "type": "followup", "uid": "im0vq5pac4t1xa"}], "upvote_ids": [], "id": "jeeec163fj74if", "bookmarked": 2, "tags": ["2018", "instructor-note", "lecture3", "课堂问答"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2018-03-06T01:20:16Z", "no_upvotes": 0, "uid": "im0vq5pac4t1xa", "created": "2018-03-06T01:20:16Z", "type": "followup", "no_answer": 1, "id": "jeeywfdosv54qm", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>系统调用基本流程和中断处理相同&#xff0c;只是需要将系统调用号和传入的参数分别存入eax开始的寄存器中&#xff0c;在中断处理时会被压入栈中组成struct trapframe(user/libs/syscall.c), 随后中断处理中&#xff0c;根据栈中的寄存器值&#xff0c;使用函数指针数组调用对应的处理函数。其结果存入tf_regs.reg_eax(kern/syscall/syscall.c)&#xff0c;在中断返回时被返回到eax中&#xff0c;作为返回值。至此即完成全部调用过程。</p>"}], "nr": 1141, "bucket_order": 2, "type": "note", "folders": ["2018", "lecture3", "课堂问答"], "no_answer_followup": 1, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2018-03-05T15:44:33Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1520317455270, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>通过静态代码分析&#xff0c;举例描述ucore系统调用过程&#xff0c;及调用参数和返回值的传递方法。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/02-1-spoc-discussion.md#%E7%BB%83%E4%B9%A0%E4%BA%8C\">https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/02-1-spoc-discussion.md#%E7%BB%83%E4%B9%A0%E4%BA%8C</a></p>\n<p></p>", "anon": "no", "created": "2018-03-05T15:44:33Z", "uid": "hdjonbiyfs62ie", "subject": "2018春季-第三讲课堂实践练习二"}]}, "error": null}