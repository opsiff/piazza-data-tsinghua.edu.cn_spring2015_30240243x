{"aid": "igkp1ndkt8h4c8", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 3, "request_instructor": 0, "history": [{"uid": "hcrrjuyequh4bt", "anon": "no", "created": "2015-03-12T14:51:24Z", "content": "<p>QQ群中的大魔导师提问&#xff1a;</p>\n<p>lab1中tools/function.mk中有许多处出现</p>\n<pre>“$$$$(dir $$$$&#64;)”</pre>\n<p>这样的语句&#xff0c;请问是什么意思&#xff1f;</p>\n<p></p>\n<p>哪位&#xff08;特别是助教&#xff09;能够给出比较清楚的解释&#xff1f;</p>", "subject": "lab1中tools/function.mk中语句的理解&#xff1f;"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "created": "2015-03-12T14:50:16Z", "content": "<p>QQ群中的大魔导师提问&#xff1a;</p>\n<p>lab1中tools/function.mk中有许多处出现“$$$$(dir $$$$&#64;)”这样的语句&#xff0c;请问是什么意思&#xff1f;</p>\n<p></p>\n<p>哪位&#xff08;特别是助教&#xff09;能够给出比较清楚的解释&#xff1f;</p>", "subject": "lab1中tools/function.mk中的“$$$$(dir $$$$&#64;)”语句的理解&#xff1f;"}], "s_edits": [], "is_bookmarked": false, "tag_good_arr": ["hcrrjuyequh4bt"], "request_instructor_me": false, "my_favorite": false, "t": 1446634861976, "children": [{"is_tag_endorse": false, "created": "2015-03-13T02:01:27Z", "id": "i76xuq4eiwy1ky", "tag_endorse": [{"name": "Yu Chen", "id": "hcrrjuyequh4bt", "role": "instructor", "facebook_id": null, "photo": "1378950179_35.png", "admin": true, "us": false}], "folders": [], "history": [{"uid": "hdjoucuyb836fq", "anon": "no", "created": "2015-03-13T02:04:38Z", "content": "<p>以下内容涉及make的内部机制&#xff0c;只作为有兴趣的同学了解之用&#xff0c;与本课程的练习、考试等一概无关。</p>\n<p></p>\n<p>一、关于Makefile中$的使用<br /><br />Makefile中的$用于展开$后面的内容&#xff0c;$后面可以跟的内容包括&#xff1a;<br />   a. 变量名&#xff0c;如$(CFLAGS)&#xff0c;展开后获得变量的值&#xff1b;<br />   b. 函数调用&#xff0c;如$(dir obj/main.c)&#xff0c;展开时先递归展开所有参数&#xff0c;然后展开函数定义&#xff1b;<br />   c. 自动化变量&#xff08;Automatic Variable&#xff09;&#xff0c;如$&#64;、$&lt;。<br /><br />展开过程主要包括两个阶段[1]&#xff1a;<br />   a. 第一阶段&#xff08;read-in&#xff09;展开变量定义&#xff0c;ifdefs以及规则的目标和依赖项&#xff1b;<br />   b. 第二阶段&#xff08;target-update&#xff09;展开规则的规则体&#xff0c;此时自动化变量才有效。<br /><br />根据上面的过程&#xff0c;展开依赖项时&#xff0c;自动化变量还没有定义&#xff0c;所以出现在规则依赖项里的自动化变量是无效的。然而&#xff0c;GNU make支持在上面的两个阶段中间插入一个名为Secondary Expansion的额外阶段&#xff0c;这个阶段在定义自动化变量的情况下对依赖项进行再次展开[2]&#xff0c;使得诸如$&#64;这样的自动化变量可以在依赖项中使用。Secondary Expansion的使能需要额<br />外定义空目标.SECONDEXPANSION&#xff0c;参见tools/function.mk的第三行。</p>\n<p></p>\n<p>二、关于eval函数参数的展开<br /><br />eval函数的参数会被展开两次[3]&#xff1a;<br />   a. eval函数先对函数参数进行展开&#xff0c;这是第一次&#xff08;其它函数也会这么做&#xff09;&#xff1b;<br />   b. eval用makefile的语法解析展开后的结果&#xff0c;在此过程中还会进行一次展开。<br /><br />三、关于$$的使用\n\n可以看到&#xff0c;makefile中的一个表达式可能会经历多次展开&#xff0c;而有的变量需要特定的展开时机&#xff08;例如依赖项中的自动化变量必须在Second Expansion时展开&#xff09;。$$经过一次展开后得到$&#xff0c;可以用于延后变量/函数调用被展开的时刻。以ucore function.mk中的cc_template为例&#xff1a;cc_template中所定义的规则&#xff0c;在依赖项中使用了自动化变量$&#64;&#xff0c;因而这个变量必须在Second Expansion阶段展开&#xff1b;而cc_template中的内容会被至少展开三次&#xff1a;第一次作为eval的参数&#xff08;在do_cc_compile中&#xff09;&#xff0c;第二次作为makefile源代码&#xff08;eval函数的效果&#xff09;&#xff0c;这两次都在read-in阶段进行&#xff1b;第三次则是Second Expansion。$$$$(dir $$$$&#64;)在第一次展开后得到$$(dir $$&#64;)&#xff0c;第二次展开后得到$(dir $&#64;)&#xff0c;第三次展开才能得到我们所需要的内容&#xff0c;即目标所在的目录。</p>\n<p></p>\n<p>References</p>\n<p>[1] http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles<br />[2] http://www.gnu.org/software/make/manual/make.html#Secondary-Expansion<br />[3] http://www.gnu.org/software/make/manual/make.html#Eval-Function</p>", "subject": ""}, {"uid": "hdjoucuyb836fq", "anon": "no", "created": "2015-03-13T02:02:37Z", "content": "<p>以下内容涉及make的内部机制&#xff0c;只作为有兴趣的同学了解之用&#xff0c;与本课程的练习、考试等一概无关。</p>\n<p></p>\n<p>一、关于Makefile中$的使用<br /><br />Makefile中的$用于展开$后面的内容&#xff0c;$后面可以跟的内容包括&#xff1a;<br />   a. 变量名&#xff0c;如$(CFLAGS)&#xff0c;展开后获得变量的值&#xff1b;<br />   b. 函数调用&#xff0c;如$(dir obj/main.c)&#xff0c;展开时先递归展开所有参数&#xff0c;然后展开函数定义&#xff1b;<br />   c. 自动化变量&#xff08;Automatic Variable&#xff09;&#xff0c;如$&#64;、$&lt;。<br /><br />展开过程主要包括两个阶段[1]&#xff1a;<br />   a. 第一阶段&#xff08;read-in&#xff09;展开变量定义&#xff0c;ifdefs以及规则的目标和依赖项&#xff1b;<br />   b. 第二阶段&#xff08;target-update&#xff09;展开规则的规则体&#xff0c;此时自动化变量才有效。<br /><br />根据上面的过程&#xff0c;展开依赖项时&#xff0c;自动化变量还没有定义&#xff0c;所以出现在规则依赖项里的自动化变量是无效的。然而&#xff0c;GNU make支持在上面的两个阶段中间插入一个名为Secondary Expansion的额外阶段&#xff0c;这个阶段在定义自动化变量的情况下对依赖项进行再次展开[2]&#xff0c;使得诸如$&#64;这样的自动化变量可以在依赖项中使用。Secondary Expansion的使能需要额<br />外定义空目标.SECONDEXPANSION&#xff0c;参见tools/function.mk的第三行。</p>\n<p></p>\n<p>二、关于eval函数参数的展开<br /><br />eval函数的参数会被展开两次[3]&#xff1a;<br />   a. eval函数先对函数参数进行展开&#xff0c;这是第一次&#xff08;其它函数也会这么做&#xff09;&#xff1b;<br />   b. eval用makefile的语法解析展开后的结果&#xff0c;在此过程中还会进行一次展开。<br /><br />三、关于$$的使用\n\n可以看到&#xff0c;makefile中的一个表达式可能会经历多次展开&#xff0c;而有的变量需要特定的展开时机&#xff08;例如依赖项中的自动化变量必须在Second Expansion时展开&#xff09;。$$经过一次展开后得到$&#xff0c;可以用于延后变量/函数调用被展开的时刻。以ucore function.mk中的cc_template为例&#xff1a;</p>\n<p></p>\n<pre>define cc_template<br />$(call todep,$(1),$(4)): $(1) | $$$$(dir $$$$&#64;)<br />        &#64;$(2) -I$$(dir $(1)) $(3) -MM $$&lt; -MT &#34;$$(patsubst %.d,%.o,$$&#64;) $$&#64;&#34;&gt; $$&#64;<br />$(call toobj,$(1),$(4)): $(1) | $$$$(dir $$$$&#64;)<br />        &#64;echo &#43; cc $$&lt;\n        $(V)$(2) -I$$(dir $(1)) $(3) -c $$&lt; -o $$&#64;<br />ALLOBJS &#43;= $$(call toobj,$(1),$(4))\nendef\n\ndefine do_cc_compile\n$(foreach f,$(1),$(eval $(call cc_template,$(f),$(2),$(3),$(4))))\nendef&lt;tt&gt;&lt;/tt&gt;\n\n\n&lt;tt&gt;cc_template中所定义的规则&#xff0c;在依赖项中使用了自动化变量$&#64;&#xff0c;因而这个变量必须在Second Expansion阶段展开&#xff1b;而cc_template中的内容会被至少展开三次&#xff1a;第一次作为eval 的参数&#xff0c;第二次作为makefile源代码&#xff08;eval函数的效果&#xff09;&#xff0c;这两次都在read-in阶段进行&#xff1b;第三次则是Second Expansion。&lt;/tt&gt;\n$$$$(dir $$$$&#64;)在第一次展开后得到$$(dir $$&#64;)&#xff0c;第二次&lt;br /&gt;展开后得到$(dir $&#64;)&#xff0c;第三次展开恰好在Second Expansion阶段&#xff0c;只有这样才能得到我们所需要的内容&#xff0c;即目标所在的目录。&lt;br /&gt;&lt;br /&gt;References&lt;br /&gt;[1] http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles&lt;br /&gt;[2] http://www.gnu.org/software/make/manual/make.html#Secondary-Expansion&lt;br /&gt;[3] http://www.gnu.org/software/make/manual/make.html#Eval-Function&lt;/p&gt;&lt;/tt&gt;&lt;/p&gt;</pre>", "subject": ""}, {"uid": "hdjoucuyb836fq", "anon": "no", "created": "2015-03-13T02:01:28Z", "content": "<p>以下内容涉及make的内部机制&#xff0c;只作为有兴趣的同学了解之用&#xff0c;与本课程的练习、考试等一概无关。</p>\n<p></p>\n<p>一、关于Makefile中$的使用<br /><br />Makefile中的$用于展开$后面的内容&#xff0c;$后面可以跟的内容包括&#xff1a;<br />   a. 变量名&#xff0c;如$(CFLAGS)&#xff0c;展开后获得变量的值&#xff1b;<br />   b. 函数调用&#xff0c;如$(dir obj/main.c)&#xff0c;展开时先递归展开所有参数&#xff0c;然后展开函数定义&#xff1b;<br />   c. 自动化变量&#xff08;Automatic Variable&#xff09;&#xff0c;如$&#64;、$&lt;。<br /><br />展开过程主要包括两个阶段[1]&#xff1a;<br />   a. 第一阶段&#xff08;read-in&#xff09;展开变量定义&#xff0c;ifdefs以及规则的目标和依赖项&#xff1b;<br />   b. 第二阶段&#xff08;target-update&#xff09;展开规则的规则体&#xff0c;此时自动化变量才有效。<br /><br />根据上面的过程&#xff0c;展开依赖项时&#xff0c;自动化变量还没有定义&#xff0c;所以出现在规则依赖项里的自动化变量是无效的。然而&#xff0c;GNU make支持在上面的两个阶段中间插入一个名为Secondary Expansion的额外阶段&#xff0c;这个阶段在定义自动化变量的情况下对依赖项进行再次展开[2]&#xff0c;使得诸如$&#64;这样的自动化变量可以在依赖项中使用。Secondary Expansion的使能需要额<br />外定义空目标.SECONDEXPANSION&#xff0c;参见tools/function.mk的第三行。</p>\n<p></p>\n<p>二、关于eval函数参数的展开<br /><br />eval函数的参数会被展开两次[3]&#xff1a;<br />   a. eval函数先对函数参数进行展开&#xff0c;这是第一次&#xff08;其它函数也会这么做&#xff09;&#xff1b;<br />   b. eval用makefile的语法解析展开后的结果&#xff0c;在此过程中还会进行一次展开。<br /><br />三、关于$$的使用\n\n可以看到&#xff0c;makefile中的一个表达式可能会经历多次展开&#xff0c;而有的变量需要特定的展开时机&#xff08;例如依赖项中的自动化变量必须在Second Expansion时展开&#xff09;。$$经过一次展开后得到$&#xff0c;可以用于延后变量/函数调用被展开的时刻。以ucore function.mk中的cc_template为例&#xff1a;</p>\n<p><br /><tt>define cc_template</tt><br /><tt>$(call todep,$(1),$(4)): $(1) | $$$$(dir $$$$&#64;)</tt><br /><tt>        &#64;$(2) -I$$(dir $(1)) $(3) -MM $$&lt; -MT &#34;$$(patsubst %.d,%.o,$$&#64;) $$&#64;&#34;&gt; $$&#64;</tt><br /><tt>$(call toobj,$(1),$(4)): $(1) | $$$$(dir $$$$&#64;)</tt><br /><tt>        &#64;echo &#43; cc $$&lt;\n&lt;tt&gt;        $(V)$(2) -I&lt;/tt&gt;$$(dir $(1)) $(3) -c $$&lt; -o $$&#64;</tt><br /><tt>ALLOBJS &#43;= $$(call toobj,$(1),$(4))\n&lt;tt&gt;endef&lt;/tt&gt;\n\n&lt;tt&gt;define do_cc_compile&lt;/tt&gt;\n&lt;tt&gt;$(foreach f,$(1),$(eval $(call cc_template,$(f),$(2),$(3),$(4))))&lt;/tt&gt;\n&lt;tt&gt;endef&lt;/tt&gt;\n\ncc_template中所定义的规则&#xff0c;在依赖项中使用了自动化变量$&#64;&#xff0c;因而这个变量必须在Second Expansion阶段展开&#xff1b;而cc_template中的内容会被至少展开三次&#xff1a;第一次作为eval\n的参数&#xff0c;第二次作为makefile源代码&#xff08;eval函数的效果&#xff09;&#xff0c;这两次都在read-in阶段进行&#xff1b;第三次则是Second Expansion。$$$$(dir $$$$&#64;)在第一次展开后得到$$(dir $$&#64;)&#xff0c;第二次&lt;br /&gt;展开后得到$(dir $&#64;)&#xff0c;第三次展开恰好在Second Expansion阶段&#xff0c;只有这样才能得到我们所需要的内容&#xff0c;即目标所在的目录。&lt;br /&gt;&lt;br /&gt;References&lt;br /&gt;[1] http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles&lt;br /&gt;[2] http://www.gnu.org/software/make/manual/make.html#Secondary-Expansion&lt;br /&gt;[3] http://www.gnu.org/software/make/manual/make.html#Eval-Function&lt;/p&gt;</tt></p>", "subject": ""}], "config": {}, "data": {"embed_links": []}, "bucket_order": 2, "bucket_name": "Today", "tag_endorse_arr": ["hcrrjuyequh4bt"], "children": [], "type": "i_answer"}], "type": "question", "unique_views": 76, "created": "2015-03-12T14:50:16Z", "id": "i769vkk0bwi6r1", "no_answer": 0, "nr": 89, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["lab1"], "bucket_order": 2, "change_log": [{"uid": "hcrrjuyequh4bt", "when": "2015-03-12T14:50:16Z", "data": "i769vkk2k4f6r2", "anon": "no", "type": "create"}, {"uid": "hcrrjuyequh4bt", "when": "2015-03-12T14:51:24Z", "data": "i769x11zqdt667", "anon": "no", "type": "update"}, {"uid": "hdjoucuyb836fq", "when": "2015-03-13T02:01:28Z", "data": "i76xuq4hham1kz", "to": "i769vkk0bwi6r1", "anon": "no", "type": "i_answer"}, {"uid": "hdjoucuyb836fq", "when": "2015-03-13T02:02:37Z", "data": "i76xw7yv8xo18i", "anon": "no", "type": "i_answer_update"}, {"uid": "hdjoucuyb836fq", "when": "2015-03-13T02:04:38Z", "data": "i76xyt2vz7g5nr", "anon": "no", "type": "i_answer_update"}], "bucket_name": "Today", "tags": ["instructor-question", "lab1"], "no_answer_followup": 0, "num_favorites": 0, "tag_good": [{"name": "Yu Chen", "id": "hcrrjuyequh4bt", "role": "instructor", "facebook_id": null, "photo": "1378950179_35.png", "admin": true, "us": false}]}}