{"aid": "j0zezylomqf1ww", "result": {"status": "active", "unique_views": 13, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-04-01T02:50:18Z", "data": "j0ynufcf57p3t9", "uid": "ie7xxyhe7dp1jr"}], "upvote_ids": [], "id": "j0ynufbkrxv3t8", "bookmarked": 4, "tags": ["2017", "lecture12", "student"], "i_edits": [], "is_bookmarked": false, "children": [], "nr": 1029, "bucket_order": 2, "type": "note", "folders": ["2017", "lecture12"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-04-01T02:50:18Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1491060626412, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p></p><pre>// proc_run - make process &#34;proc&#34; running on cpu\n// NOTE: before call switch_to, should load  base addr of &#34;proc&#34;&#39;s new PDT\nvoid\nproc_run(struct proc_struct *proc) {\n    if (proc != current) {\n        bool intr_flag;\n        struct proc_struct *prev = current, *next = proc;\n        local_intr_save(intr_flag);\n        {\n            current = proc;\n            load_esp0(next-&gt;kstack &#43; KSTACKSIZE);<br />            // (1)\n            lcr3(next-&gt;cr3);\n            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br />            // (2)\n        }\n        local_intr_restore(intr_flag);\n    }\n}</pre>\n<p>在没仔细分析的情况下&#xff0c;粗略一看&#xff1a;似乎在进程切换的切换的时候&#xff0c;好像是永远会从上一个进程的 (1) 处进入上下文切换的过程 switch_to&#xff0c;切换完后&#xff0c;好像总会回下一个进程的 (2) 处&#xff0c;继续执行&#xff0c;因此似乎没有必要 eip。</p>\n<p></p>\n<p>但上面的分析是<strong>不对</strong>的&#xff0c;对于 fork 后的生成子进程</p>\n<p></p>\n<pre>// copy_thread - setup the trapframe on the  process&#39;s kernel stack top and\n//             - setup the kernel entry point and stack of process\nstatic void\ncopy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;\n    *(proc-&gt;tf) = *tf;\n    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;\n    proc-&gt;tf-&gt;tf_esp = esp;\n    proc-&gt;tf-&gt;tf_eflags |= FL_IF;\n\n    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);\n}</pre>\n<p><br />会将其 context.eip 设置到 forkret。当从别的进程 A 切入刚 fork 好但还没跑过的子进程 B 时&#xff0c;会从前面的 A 进程的 (1) 处进入&#xff0c;随后不会返回 B 进程的 (2)&#xff0c;而是直接飞到 B 进程的 forkret&#xff0c;forkret 调用 forkrets&#xff0c;forkrets 假装是从中断中返回。根据 trap 帧的内容从中断返回后&#xff0c;就设置好了 fork 好的子进程的上下文&#xff0c;并开始执行了。<br /><br /><strong>可见&#xff0c;context.eip 对于 fork 后的新线程意义重大&#xff0c;不得不保存。</strong></p>\n<p></p>\n<p></p>", "anon": "no", "created": "2017-04-01T02:50:18Z", "uid": "ie7xxyhe7dp1jr", "subject": "switch_to 是否有必要保存 eip"}]}, "error": null}