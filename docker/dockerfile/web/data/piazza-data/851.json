{"aid": "izsjtmmahcw2l8", "result": {"status": "active", "unique_views": 121, "request_instructor_me": false, "change_log": [{"data": "inx9xs58vk41ie", "anon": "no", "when": "2016-05-07T14:57:03Z", "uid": "hdjonbiyfs62ie", "type": "create"}, {"data": "inzble326kk6ln", "anon": "no", "when": "2016-05-09T01:18:57Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"data": "inzbnrapqtp669", "anon": "no", "when": "2016-05-09T01:20:47Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"data": "inzbrdku6o41fj", "anon": "no", "when": "2016-05-09T01:23:36Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T01:25:41Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T01:25:55Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T01:26:04Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T01:38:15Z", "uid": "i0gl5kctugw3xi", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T01:58:32Z", "uid": "ie7xy71bn7b1s2", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T03:20:51Z", "uid": "ic226rac4j5jw", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T04:06:12Z", "uid": "ikvcvqz0jx17m1", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T04:56:19Z", "uid": "i0ayxqk6wry734", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T05:19:42Z", "uid": "i6ub5at2geM", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T12:38:30Z", "uid": "ikvcvp62fcm7ka", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-09T15:53:58Z", "uid": "i0yuo4o74sx70w", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T01:56:02Z", "uid": "i0zaci5voig5h", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T04:57:20Z", "uid": "i0gkdbms5ie20o", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T09:19:24Z", "uid": "i6ub4vwhQXd", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T09:24:33Z", "uid": "i18riqkwrl225m", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T09:30:48Z", "uid": "i0gkdbms5ie20o", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T09:48:35Z", "uid": "i1bzj2xilgm4uk", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T09:54:21Z", "uid": "im4yagyfl3chl", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T09:55:02Z", "uid": "i0brpl1lbyui6", "type": "followup"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T10:23:14Z", "uid": "i0ccqbaxwdz75c", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T10:56:21Z", "uid": "i70lz5f0QKm", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T11:07:45Z", "uid": "i21zpwab2z775p", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T11:09:37Z", "uid": "i0brpl1lbyui6", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T11:28:15Z", "uid": "i242q8ug7vw40x", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T11:39:08Z", "uid": "i11v1az5sf83l2", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T12:39:30Z", "uid": "i6w84pnmjCQ", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-10T13:36:55Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "inx9xs549ic1id", "anon": "no", "when": "2016-05-22T09:45:31Z", "uid": "i0hjdkesg9c5z7", "type": "feedback"}, {"data": "ior9o2io5312z6", "anon": "no", "when": "2016-05-28T14:42:36Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"type": "update", "anon": "no", "when": "2017-03-02T08:02:21Z", "data": "izs3s69czaw3gy", "uid": "hdjonbiyfs62ie"}], "upvote_ids": [], "id": "inx9xs549ic1id", "bookmarked": 24, "tags": ["2016", "instructor-note", "lecture19", "lecture20", "所有老师和助教", "清华学生", "课堂问答", "课程设计"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-05-09T01:25:41Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-05-09T01:25:41Z", "type": "followup", "no_answer": 0, "id": "inzbu284xdv2ha", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [{"folders": [], "updated": "2016-05-09T01:58:32Z", "uid": "ie7xy71bn7b1s2", "created": "2016-05-09T01:58:32Z", "type": "feedback", "id": "inzd0b11ws53d7", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>Hooare管程:</p>\n<p>https://github.com/gjc13/ucore_os_lab/commit/9d0ad3847f2956da9e199af822ba4c63e1ad8a5e</p>\n<p>Hasen管程</p>\n<p>https://github.com/gjc13/ucore_os_lab/tree/lab7-hasen</p>"}, {"folders": [], "updated": "2016-05-09T04:56:19Z", "uid": "i0ayxqk6wry734", "created": "2016-05-09T04:56:19Z", "type": "feedback", "id": "inzjcxd58d72t", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>沈哲言 2013011371 叶子鹏 2013011404</p>\n<p><a href=\"https://github.com/Silver-Shen/OS_LAB/tree/4de6b5095c194ce4de1d104e1547036bd2f3d38d/labcodes_answer/lab7_result/kern/sync\" target=\"_blank\">github仓库</a></p>\n<p>&#xff08;1&#xff09;cvp-&gt;count的含义是因为等待这个条件变量而睡眠的进程数&#xff0c;不可能小于零&#xff0c;但可能大于1&#xff0c;如果有多个进程请求这个条件变量的资源或者等待它的事件&#xff0c;那么cvp-&gt;count会大于1</p>\n<p>&#xff08;2&#xff09;cvp-&gt;owner-&gt;next_count的含义是因为调用了cond_signal而睡眠的进程数&#xff0c;在ucore中&#xff0c;采用了霍尔管程的实现即进程在调用signal之后会把自身挂起&#xff0c;next_count就会递增&#xff1b;它不可能小于零&#xff0c;但可能大于1</p>\n<p>&#xff08;3&#xff09;目前ucore中采用了Hoare管程&#xff0c;另一种实现间github仓库</p>"}, {"folders": [], "updated": "2016-05-09T05:19:42Z", "uid": "i6ub5at2geM", "created": "2016-05-09T05:19:42Z", "type": "feedback", "id": "inzk6zlyc7g4b", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>代码和报告&#xff1a;</p>\n<p><a href=\"https://github.com/rafaeljin/os_exercises/tree/master/all/hoare_and_hansen\">https://github.com/rafaeljin/os_exercises/tree/master/all/hoare_and_hansen</a></p>\n<p>2012080059 jjy </p>\n<p>2012011321 zy</p>"}, {"folders": [], "updated": "2016-05-09T15:53:58Z", "uid": "i0yuo4o74sx70w", "created": "2016-05-09T15:53:58Z", "type": "feedback", "id": "io06uo3lvm1306", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>张浩天 2013011416  郑兆衡 2013011389</p>\n<p><br />(1)cvp-&gt;count是指当前正在等待cvp这个条件变量而处于睡眠状态的进程数目。</p>\n<p>    它不可能小于0&#xff0c;因为它初始为0&#xff0c;之后每次调用cond_wait&#xff0c;它都只会先加1后减1&#xff0c;因此始终大于等于0。</p>\n<p>    它可能大于1&#xff0c;比如多个进程请求这个条件变量的资源&#xff0c;但都得不到满足时&#xff0c;它们依次调用cond_wait进入睡眠状态&#xff0c;而count就依次增加。</p>\n<p>(2)cvp-&gt;owner-&gt;next_count是指调用了cond_signal&#xff0c;唤醒了之前等待的进程后自己进入等待状态的进程数目。</p>\n<p>     它不可能小于0&#xff0c;因为它初始为0&#xff0c;之后每次调用cond_signal&#xff0c;它都只会先加1后减1&#xff0c;因此始终大于等于0.</p>\n<p>     它可能大于1&#xff0c;比如多个进程依次调用cond_signal, 并且自己唤醒别人后都进入等待&#xff0c;那么next_count就会依次增加大于1。</p>\n<p>(3)目前的ucore管程代码采用Hoare管程&#xff0c;Hansen管程的实现如下&#xff0c;修改cond_wait和cond_signal函数</p>\n<pre>void <br />cond_signal (condvar_t *cvp) {<br />   cprintf(&#34;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  <br />     if(cvp-&gt;count&gt;0) <br />        up(&amp;(cvp-&gt;sem));<br />   cprintf(&#34;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br />}</pre>\n<p>由于Hansen管程中调用cond_signal的进程先将自己执行完毕&#xff0c;才切换到被唤醒的进程&#xff0c;因此就不再需要记录到底是哪个进程唤醒了别人后自己进入等待</p>\n<pre>void<br />cond_wait (condvar_t *cvp) {<br />    cprintf(&#34;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br />      cvp-&gt;count&#43;&#43;;<br />      up(&amp;(cvp-&gt;owner-&gt;mutex));<br />      down(&amp;(cvp-&gt;sem));<br />      down(&amp;(cvp-&gt;owner-&gt;mutex));<br />      cvp-&gt;count --;<br />    cprintf(&#34;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br />}</pre>\n<p>同样的&#xff0c;在cond_wait中也不再需要去唤醒那个 唤醒了自己的进程。</p>\n<p>这里需要特别注意的是&#xff1a;在挂起自己之前要先释放mutex&#xff0c;唤醒之后继续执行需要再申请mutex&#xff0c;观察Hoare的实现会发现它有释放mutex&#xff0c;</p>\n<p>但没有申请mutex。这是因为Hoare中调用cond_signal的那个进程还没来得及释放锁就切换到了等待的进程&#xff0c;因此不需要再申请mutex。</p>\n<p></p>"}, {"folders": [], "updated": "2016-05-10T01:56:02Z", "uid": "i0zaci5voig5h", "created": "2016-05-10T01:56:02Z", "type": "feedback", "id": "io0scxafmlr5so", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>朱新瑞 2013011411 朱俸民 2012011894</p>\n<p>&#xff08;1&#xff09;cvp-&gt;count是等待条件变量而睡眠的进程数&#xff0c;所以不可能小于0&#xff0c;但可能会大于1&#xff08;有多个进程去等待条件变量&#xff09;</p>\n<p>&#xff08;2&#xff09;cvp-&gt;owner-&gt;next_count的是因为cond_signal而睡眠的进程数&#xff0c;在ucore中&#xff0c;采用了Hoare管程的实现&#xff0c;进程在调用signal之后&#xff0c;自身会挂起&#xff0c;next_count就会递增。同样不可能小于0&#xff0c;应该会大于1</p>\n<p>&#xff08;3&#xff09;目前ucore中采用了Hoare管程&#xff0c;然后Hansen管程见https://github.com/paulzfm/os_course_spoc_exercises/tree/master/lab7_result</p>"}, {"folders": [], "updated": "2016-05-10T04:57:20Z", "uid": "i0gkdbms5ie20o", "created": "2016-05-10T04:57:20Z", "type": "feedback", "id": "io0yu2uh6406fn", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>贺子松 2013011296</p>\n<p>乔奕 2013011324</p>\n<p>ucore使用的是hoare管程&#xff0c;我们要实现hansen管程&#xff0c;代码如下</p>\n<p></p>\n<p><a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0gkdbms5ie20o/io0ytz6b7627/monitor.c\" target=\"_blank\">monitor.c</a></p>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2016-05-10T10:23:14Z", "uid": "i0ccqbaxwdz75c", "created": "2016-05-10T10:23:14Z", "type": "feedback", "id": "io1ah74qj16wv", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p><a href=\"https://github.com/HollaTsinghua/OS-lecture-19\">https://github.com/HollaTsinghua/OS-lecture-19</a></p>\n<p>何乐 2013011351 郭栋 2013011334</p>"}, {"folders": [], "updated": "2016-05-10T11:07:45Z", "uid": "i21zpwab2z775p", "created": "2016-05-10T11:07:45Z", "type": "feedback", "id": "io1c2fxg7adaz", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>马志明 2013011395 王启圣 2013011409</p>\n<p>ucore中原来实现的是hoare&#xff0c;实现的hansen如下&#xff1a;</p>\n<p><a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i21zpwab2z775p/io1c1hi1ylux/monitor.c\" target=\"_blank\">monitor.c</a></p>"}, {"folders": [], "updated": "2016-05-10T11:28:15Z", "uid": "i242q8ug7vw40x", "created": "2016-05-10T11:28:15Z", "type": "feedback", "id": "io1cst8daa62b8", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>2013011302 % 3 == 1 李奕昕</p>\n<p>2013011356 董豪宇</p>\n<p>目前ucore中使用的是hoare管程 与hansen管程不同之处在于 hoare管程在signal之后会立即放弃管程而hansen不会 因此对于hansen管程中的signal操作 只需要简单的:</p>\n<pre>void cond_signal (condvar_t *cvp) { \n     \tif(cvp-&gt;count&gt;0) {\n        \tup(&amp;(cvp-&gt;sem));<br />\t}\n}</pre>\n<p>因为自己一定会执行完 所以不用考虑用</p>\n<pre>down(&amp;(cvp-&gt;owner-&gt;next));</pre>\n<p>去排队这件事 所以自然不会有next_count的变化</p>\n<p>对于wait操作 已经没有了next队列之类的事</p>\n<pre>void cond_wait (condvar_t *cvp) {\n\tcvp-&gt;count&#43;&#43;;<br />\tup(&amp;(cvp-&gt;owner-&gt;mutex));<br />\tdown(&amp;(cvp-&gt;sem));<br />\tdown(&amp;(cvp-&gt;owner-&gt;mutex));<br />\tcvp-&gt;count --;\n}</pre>\n<p>但是由于signal不马上唤起wait的进程(没有钦定...) 所以管程的访问权还是要自己去抢</p>"}, {"folders": [], "updated": "2016-05-10T11:39:08Z", "uid": "i11v1az5sf83l2", "created": "2016-05-10T11:39:08Z", "type": "feedback", "id": "io1d6stklvy57b", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p><br />2013011308 林婕茵<br />2013011310 余翔</p>\n<p><a href=\"https://github.com/yxfish13/os_homework/blob/master/12_1/report.md\" target=\"_blank\">report.md</a></p>"}, {"folders": [], "updated": "2016-05-10T12:39:30Z", "uid": "i6w84pnmjCQ", "created": "2016-05-10T12:39:30Z", "type": "feedback", "id": "io1fcfvyakwsa", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p><tt>ucore中使用的是Hoare管程。Hoare管程<tt>蕴涵了调度</tt>的意味&#xff0c;signal之后立即wait(next)。而Hansen管程则不管这些事情。</tt><tt>所以Hansen的signal函数实现如下&#xff1a;</tt></p>\n<pre>void <br />cond_signal (condvar_t *cvp) {<br />    cprintf(&#34;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  <br /><br />    // No need to down next.<br />    if(cvp-&gt;count&gt;0) {<br />        up(&amp;(cvp-&gt;sem));<br />    }<br />    cprintf(&#34;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br />}</pre>\n<p><tt>wait函数实现如下&#xff1a;</tt></p>\n<pre>void\ncond_wait (condvar_t *cvp) {\n    cprintf(&#34;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);<br /><br />    // No need to consider about next.\n    cvp-&gt;count &#43;&#43;;\n    up(&amp;(cvp-&gt;owner-&gt;mutex));\n    down(&amp;(cvp-&gt;sem));\n    down(&amp;(cvp-&gt;owner-&gt;mutex));\n    cvp-&gt;count --;\n    cprintf(&#34;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\\n&#34;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);\n}</pre>\n<p></p>\n<p></p>"}], "subject": "<p>选择做“1&#xff09;第十九讲小组思考题(2)”的同学的回答结果写在此贴后面。</p>\n<p></p>"}, {"folders": [], "updated": "2016-05-09T01:25:55Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-05-09T01:25:55Z", "type": "followup", "no_answer": 0, "id": "inzbucjyr0b226", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [{"folders": [], "updated": "2016-05-09T01:38:15Z", "uid": "i0gl5kctugw3xi", "created": "2016-05-09T01:38:15Z", "type": "feedback", "id": "inzca7t9dy91qa", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>2013011402 钱迪晨 2013011413 高思达</p>\n<p></p>\n<p>基于原框架实现的代码&#xff1a;</p>\n<p><a href=\"https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/bankers-homework.py\">https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/bankers-homework.py</a><a href=\"https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/bankers-homework.py\"></a><a href=\"https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/bankers-homework.py\" target=\"_blank\"></a></p>\n<p>注意&#xff0c;原框架代码中的CalcNeed函数并不值得信任&#xff0c;实际上只有一开始初始化的时候可以用。之后进程运行完毕后&#xff0c;必须手动把Need清0&#xff0c;而不能通过这个接口。</p>\n<p></p>\n<p>原框架代码之所以看起来有点冗余&#xff0c;主要是因为矩阵运算的写法不够精炼。既然已经import了numpy的包&#xff0c;完全有更精炼的矩阵运算写法。</p>\n<p></p>\n<p>另外值得注意的一点是Execute函数中探索执行序列的方法。虽然一开始生成了所有的排列&#xff0c;但实际上并不是要探索所有的排列找一个可行的。</p>\n<p>基本的写法是&#xff0c;每次顺序遍历所有进程&#xff0c;找当前没执行的进程中有没有可以做的。这样的问题是&#xff0c;每次都从头开始找&#xff0c;排在前面的进程更有可能先被执行&#xff0c;这样在较后面的遍历中&#xff0c;就要等到遍历到很后面时才能找到可以执行的进程。</p>\n<p>但是&#xff0c;如果是每次遍历不同的排列&#xff0c;较后面的遍历&#xff0c;也能较快找到可以执行的进程。</p>\n<p>&#xff08;这个解释极其牵强&#xff09;</p>\n<p></p>\n<p>最后需要注意的是&#xff0c;原始框架中一旦发现当前没有可执行进程时&#xff0c;就立即返回失败了。这乍一看是比较令人疑惑的&#xff0c;因为当前只是用贪心策略尝试了一条路径&#xff0c;这时的失败为什么能够直接推出全局不存在执行路径&#xff1f;事实上&#xff0c;这并不是一个我们之前常见的搜索问题&#xff0c;失败并不需要回溯。因为在这个问题中&#xff0c;每走一步&#xff0c;即每成功执行一个进程&#xff0c;都会释放一批资源&#xff0c;也就是增大之后成功的可能性&#xff08;而之前我们常见的搜索问题&#xff0c;都是减少这种可能性&#xff09;。正因如此&#xff0c;无论何时我们发现走不动了&#xff0c;都能推定全局不存在可行的执行序列。</p>\n<p></p>\n<p>输出结果&#xff1a;</p>\n<p><a href=\"https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/output.txt\">https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/output.txt</a><a href=\"https://github.com/nathenqian/ucore_spoc/blob/master/spoc_20/output.txt\" target=\"_blank\"></a></p>\n<p>注意&#xff0c;上面的输出结果采用的是和SPOC题目描述中一样的测试用例。</p>\n<p>SPOC题目描述中给出的参考输出是有问题的&#xff0c;因为最后的四个进程的测例并没有修改procnum。</p>\n<p>这也体现出了框架代码实现上的问题&#xff0c;既然可以从分配矩阵得到进程数&#xff0c;就没必要手动设置一个全局变量了。这样容易出错。</p>"}, {"folders": [], "updated": "2016-05-09T03:20:51Z", "uid": "ic226rac4j5jw", "created": "2016-05-09T03:20:51Z", "type": "feedback", "id": "inzfy5ngalu64b", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>高博 2012012139</p>\n<p>赵涵 2012011383</p>\n<p>对程序做了改进。</p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/blob/master/all/bankers.md\" target=\"_blank\">Report</a></p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/blob/master/all/bankers-homework.py\" target=\"_blank\">banker-code</a></p>\n<p></p>"}, {"folders": [], "updated": "2016-05-09T04:06:12Z", "uid": "ikvcvqz0jx17m1", "created": "2016-05-09T04:06:12Z", "type": "feedback", "id": "inzhkh6sf9o1bh", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>2012011333 俞寒轩</p>\n<p>2012011306 肖迪</p>\n<p></p>\n<p><a href=\"https://github.com/yuhx/OS_homework/blob/master/lec20.py\" target=\"_blank\">code</a></p>\n<p></p>\n<p>除了YOUR CODE部分&#xff0c;还修改了Execute函数。</p>"}, {"folders": [], "updated": "2016-05-09T12:38:30Z", "uid": "ikvcvp62fcm7ka", "created": "2016-05-09T12:38:30Z", "type": "feedback", "id": "inzzvb4og282qw", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>周恩泽</p>\n<p>尚智伟</p>\n<p><a href=\"https://github.com/Zhouenze/oslab/blob/master/Banker/lec20spoc.py\" target=\"_blank\">code</a></p>\n<p>被注释掉的测试也解注释并通过了&#xff0c;注意需要先加一句修改procnum</p>"}, {"folders": [], "updated": "2016-05-10T09:19:24Z", "uid": "i6ub4vwhQXd", "created": "2016-05-10T09:19:24Z", "type": "feedback", "id": "io1873uzutby", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>徐捷 2012011371&#xff0c;赖国堃 2012011372</p>\n<p></p>\n<p><a href=\"https://github.com/EternalAnswer/os_course_spoc_exercises/blob/master/all/spoc_answers/banker.py\" target=\"_blank\">code</a></p>"}, {"folders": [], "updated": "2016-05-10T09:24:33Z", "uid": "i18riqkwrl225m", "created": "2016-05-10T09:24:33Z", "type": "feedback", "id": "io18dqjh1jv64k", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>2013011297 杨青霖</p>\n<p><a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i18riqkwrl225m/io18d60m6gme/bankershomework.py\" target=\"_blank\">bankershomework.py</a></p>"}, {"folders": [], "updated": "2016-05-10T09:30:48Z", "uid": "i0gkdbms5ie20o", "created": "2016-05-10T09:30:48Z", "type": "feedback", "id": "io18lrri8lj5kv", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>贺子松 2013011296</p>\n<p>乔奕 2013011324</p>\n<p></p>\n<p><a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0gkdbms5ie20o/io18j3ort1in/bankershomework.py\" target=\"_blank\">bankers-homework.py</a></p>\n<p></p>\n<p>可以通过原测例和注释掉的测例&#xff0c;输出和参考输出一致。</p>\n<p>注意在ExecuteProcess的第二段需要手动置need为0&#xff0c;并重新计算avaliable</p>\n<p>注意所有的Calc函数都不会修改这些矩阵&#xff0c;需要再赋值。</p>\n<p></p>"}, {"folders": [], "updated": "2016-05-10T09:48:35Z", "uid": "i1bzj2xilgm4uk", "created": "2016-05-10T09:48:35Z", "type": "feedback", "id": "io198n3xc2x185", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>2013011355徐涵</p>\n<p>2013011339白家松</p>\n<p></p>\n<p><a href=\"https://github.com/orangexuhan/os_spoc_answer/blob/master/lec19%2620.py\" target=\"_blank\">spoc_answer</a></p>\n<p>测试注释掉的的测例时&#xff0c;最后一组需要将procnum置为4</p>"}, {"folders": [], "updated": "2016-05-10T09:54:21Z", "uid": "im4yagyfl3chl", "created": "2016-05-10T09:54:21Z", "type": "feedback", "id": "io19g1jjw357b9", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p><a href=\"https://github.com/kwafok/tsinghua_ucore_lab_exercise/blob/master/ucore_lab/some-exercise-and-code/lec20/banker.py\">https://github.com/kwafok/tsinghua_ucore_lab_exercise/blob/master/ucore_lab/some-exercise-and-code/lec20/banker.py</a></p>\n<p></p>\n<p>只改了your code 部分&#xff08;TempSafeCheckAfterRelease、ExecuteProcess&#xff09;</p>\n<p>通过原测例和注释掉的测例&#xff0c;输出和参考输出一致。</p>\n<p></p>"}, {"folders": [], "updated": "2016-05-10T10:56:21Z", "uid": "i70lz5f0QKm", "created": "2016-05-10T10:56:21Z", "type": "feedback", "id": "io1bnshf3rwon", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p></p>\n<p>2012011307 黄必胜</p>\n<p><a href=\"https://github.com/hbisheng/Spoc_exercise/blob/master/08-1-banker-algorithm.py\" target=\"_blank\">08-1-banker-algorithm.py</a></p>\n<p></p>\n<p>第三组测例的参考输出应该有误~</p>"}, {"folders": [], "updated": "2016-05-10T13:36:55Z", "uid": "ikx8y1dzPrM", "created": "2016-05-10T13:36:55Z", "type": "feedback", "id": "io1heaa6naz3x7", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>2014010527 krajna 交晚了...</p>\n<p>https://github.com/hatikvah/ucore_os/tree/master/spoc_answer/banker</p>"}], "subject": "<p>选择做“2&#xff09;第二十讲小组思考题(1)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-05-09T01:26:04Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-05-09T01:26:04Z", "type": "followup", "no_answer": 0, "id": "inzbujc7ycq2e1", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [{"folders": [], "updated": "2016-05-10T11:09:37Z", "uid": "i0brpl1lbyui6", "created": "2016-05-10T11:09:37Z", "type": "feedback", "id": "io1c4u5mcuc37i", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>杨明 2013011412 谢琛睿 2013011406</p>\n<p>1. 管道</p>\n<p>管道常用于一个进程中两个线程间的通信&#xff0c;或者是父子进程间的通信&#xff0c;是一个允许<strong>单向信息传递的通信设备&#xff08;写入端与读出端&#xff09;</strong>。管道是串行设备&#xff0c;从管道中读取的数据保持被写入时的数据&#xff08;FIFO&#xff09;。管道的容量有限&#xff1a;</p>\n<p></p>\n<div><code>[syscom&#64;sysbase0-0 linux]$ ulimit -a</code></div>\n<div><code>core file size          (blocks, -c) 0</code></div>\n<div><code>data seg size           (kbytes, -d) unlimited</code></div>\n<div><code>scheduling priority             (-e) 0</code></div>\n<div><code>file size               (blocks, -f) unlimited</code></div>\n<div><code>pending signals                 (-i) 16204</code></div>\n<div><code>max locked memory       (kbytes, -l) 64</code></div>\n<div><code>max memory size         (kbytes, -m) unlimited</code></div>\n<div><code>open files                      (-n) 1024</code></div>\n<div><code><b>pipe size            (512 bytes, -p) 8</b></code></div>\n<div><code>POSIX message queues     (bytes, -q) 819200</code></div>\n<div><code>real-</code><code>time</code> <code>priority              (-r) 0</code></div>\n<div><code>stack size              (kbytes, -s) 8192</code></div>\n<div><code>cpu </code><code>time</code>               <code>(seconds, -t) unlimited</code></div>\n<div><code>max user processes              (-u) 1024</code></div>\n<div><code>virtual</code> <code>memory          (kbytes, -v) unlimited</code></div>\n<div><code>file locks                      (-x) unlimited</code></div>\n<p></p>\n<p></p>\n<p>linux中pipe最大尺度是64kb, 原子操作的最大尺寸为4kb(上面加粗的pipe size行)。如果写入速度过快&#xff0c;则写入端进程会被阻塞&#xff0c;直到管道中出现更多空间为止。</p>\n<p>父子进程间管道通信代码请见github。</p>\n<p> </p>\n<p>2. 消息队列</p>\n<p>消息队列就是消息的列表&#xff0c;读取消息时&#xff0c;可以根据消息标号对消息进行筛选。消息是异步的&#xff0c;发送方不必等待接受方检查它所受到的消息就可以继续工作下去&#xff0c;而接收方如果没有收到消息也无需等待</p>\n<p>linux中消息的定义:</p>\n<table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><td>\n<div><code>struct</code> <code>msgstru{</code></div>\n<div><code>    </code><code>long</code> <code>mtype; </code><code>//大于0</code></div>\n<div><code>    </code><code>char</code> <code>mtext[512];</code></div>\n<div><code>};</code></div>\n</td></tr></tbody></table>\n<p>------ Messages: Limits -------- <br />max queues system wide = 32000 【系统最多的消息队列数量&#xff08;最多支持同时32000 个消息队列&#xff09;】<br />max size of message (bytes) = 8192  【单个消息的最大字节数】<br />default max size of queue (bytes) = 16384  【默认的单个队列的大小16384】</p>\n<p>进程间消息队列代码请见github。</p>\n<p> </p>\n<p>3. 共享内存</p>\n<p>共享内存机制使得多进程可以访问同一块内存空间&#xff0c;最快。但需要辅助的通信机制&#xff0c;如信号量。共享内存的尺度限制为18446744073692774399字节&#xff08;接近2的64次方&#xff0c;就是全部虚拟内存空间&#xff0c;运行命令cat /proc/sys/kernel/shmmax可获知&#xff09;。</p>\n<p>进程间共享内存通信代码请见github。&#xff08;reader负责读出&#xff0c;writer负责写入&#xff0c;分别同时运行&#xff09;</p>\n<p> </p>\n<p>注&#xff1a;github的程序可以引入C计时器timer&#xff0c;定时将运行结果输出到文件&#xff0c;就可以具体分析验证3种通信方法的feature。</p>\n<p>github链接&#xff1a;<a href=\"https://github.com/ZOROYANG/interprocess_communication\" target=\"_blank\">https://github.com/ZOROYANG/interprocess_communication</a></p>"}, {"folders": [], "updated": "2016-05-22T09:45:31Z", "uid": "i0hjdkesg9c5z7", "created": "2016-05-22T09:45:31Z", "type": "feedback", "id": "ioieexb6k6p2m2", "anon": "no", "bucket_name": "Week 5/22 - 5/28", "config": {}, "bucket_order": 45, "data": null, "children": [], "subject": "<p></p>\n<p>王苏 2013011301</p>\n<p>王哲 2013012443</p>\n<p></p>\n<p><a href=\"https://github.com/wangsu13/OS/blob/master/20.md\" target=\"_blank\">report</a></p>\n<p></p>"}], "subject": "<p>选择做“3&#xff09;第二十讲小组思考题(4)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-05-10T09:55:02Z", "no_upvotes": 0, "uid": "i0brpl1lbyui6", "created": "2016-05-10T09:55:02Z", "type": "followup", "no_answer": 0, "id": "io19gxctdkmcs", "anon": "no", "bucket_name": "Week 5/8 - 5/14", "config": {}, "bucket_order": 47, "data": null, "children": [], "subject": "<p>杨明 2013011412 谢琛睿 2013011406</p>\n<p>1. 管道</p>\n<p>管道常用于一个进程中两个线程间的通信&#xff0c;或者是父子进程间的通信&#xff0c;是一个允许<strong>单向信息传递的通信设备&#xff08;写入端与读出端&#xff09;</strong>。管道是串行设备&#xff0c;从管道中读取的数据保持被写入时的数据&#xff08;FIFO&#xff09;。管道的容量有限&#xff1a;</p>\n<p></p>\n<div><code>[syscom&#64;sysbase0-0 linux]$ ulimit -a</code></div>\n<div><code>core file size          (blocks, -c) 0</code></div>\n<div><code>data seg size           (kbytes, -d) unlimited</code></div>\n<div><code>scheduling priority             (-e) 0</code></div>\n<div><code>file size               (blocks, -f) unlimited</code></div>\n<div><code>pending signals                 (-i) 16204</code></div>\n<div><code>max locked memory       (kbytes, -l) 64</code></div>\n<div><code>max memory size         (kbytes, -m) unlimited</code></div>\n<div><code>open files                      (-n) 1024</code></div>\n<div><code><b>pipe size            (512 bytes, -p) 8</b></code></div>\n<div><code>POSIX message queues     (bytes, -q) 819200</code></div>\n<div><code>real-</code><code>time</code> <code>priority              (-r) 0</code></div>\n<div><code>stack size              (kbytes, -s) 8192</code></div>\n<div><code>cpu </code><code>time</code>               <code>(seconds, -t) unlimited</code></div>\n<div><code>max user processes              (-u) 1024</code></div>\n<div><code>virtual</code> <code>memory          (kbytes, -v) unlimited</code></div>\n<div><code>file locks                      (-x) unlimited</code></div>\n<p></p>\n<p></p>\n<p>linux中pipe最大尺度是64kb, 原子操作的最大尺寸为4kb(上面加粗的pipe size行)。如果写入速度过快&#xff0c;则写入端进程会被阻塞&#xff0c;直到管道中出现更多空间为止。</p>\n<p>父子进程间管道通信代码请见github。</p>\n<p> </p>\n<p>2. 消息队列</p>\n<p>消息队列就是消息的列表&#xff0c;读取消息时&#xff0c;可以根据消息标号对消息进行筛选。消息是异步的&#xff0c;发送方不必等待接受方检查它所受到的消息就可以继续工作下去&#xff0c;而接收方如果没有收到消息也无需等待</p>\n<p>linux中消息的定义:</p>\n<table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><td>\n<div>\n<div><code>struct</code> <code>msgstru{</code></div>\n<div><code>    </code><code>long</code> <code>mtype; </code><code>//大于0</code></div>\n<div><code>    </code><code>char</code> <code>mtext[512];</code></div>\n<div><code>};</code></div>\n</div>\n</td></tr></tbody></table>\n<p>------ Messages: Limits -------- <br />max queues system wide = 32000 【系统最多的消息队列数量&#xff08;最多支持同时32000 个消息队列&#xff09;】<br />max size of message (bytes) = 8192  【单个消息的最大字节数】<br />default max size of queue (bytes) = 16384  【默认的单个队列的大小16384】</p>\n<p>进程间消息队列代码请见github。</p>\n<p> </p>\n<p>3. 共享内存</p>\n<p>共享内存机制使得多进程可以访问同一块内存空间&#xff0c;最快。但需要辅助的通信机制&#xff0c;如信号量。共享内存的尺度限制为18446744073692774399字节&#xff08;接近2的64次方&#xff0c;就是全部虚拟内存空间&#xff0c;运行命令cat /proc/sys/kernel/shmmax可获知&#xff09;。</p>\n<p>进程间共享内存通信代码请见github。&#xff08;reader负责读出&#xff0c;writer负责写入&#xff0c;分别同时运行&#xff09;</p>\n<p> </p>\n<p>注&#xff1a;github的程序可以引入C计时器timer&#xff0c;定时将运行结果输出到文件&#xff0c;就可以具体分析验证3种通信方法的feature。</p>\n<p>github链接&#xff1a;<a href=\"https://github.com/ZOROYANG/interprocess_communication\" target=\"_blank\">https://github.com/ZOROYANG/interprocess_communication</a></p>"}], "nr": 851, "bucket_order": 2, "type": "note", "folders": ["lecture19", "lecture20", "课堂问答", "2016", "所有老师和助教", "清华学生", "课程设计"], "no_answer_followup": 0, "num_favorites": 1, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-05-07T14:57:03Z", "is_tag_good": false, "config": {"feed_groups": "所有老师和助教_i5j09fnsl7k5x0||清华学生_i5j09fnsl7k5x0||课程设计_i5j09fnsl7k5x0"}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1488468683458, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>请向勇班的同学把第十九讲和第二十讲中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>第十九讲和第二十讲的回答的截止时间是明天&#xff08;20160510&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p><br />1&#xff09;第十九讲小组思考题(2)&#xff1a;给出ucore中没有实现的管程模型&#xff08;Hansen管程或Hoare管程&#xff09;。<br />2&#xff09;第二十讲小组思考题(1)&#xff1a;完成和改进银行家算法的实现。<br />3&#xff09;第二十讲小组思考题(4)&#xff1a;测试三种通信机制的性能。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p></p>\n<p>选择做“1&#xff09;第十九讲小组思考题(2)”的同学<br />郭嘉丞</p>\n<p></p>\n<p>选择做“2&#xff09;第二十讲小组思考题(1)”的同学<br />2013011402 钱迪晨 2013011413 高思达<br />高博 2012012139 赵涵 2012011383</p>\n<p></p>\n<p>选择做“3&#xff09;第二十讲小组思考题(4)”的同学<br />杨明 2013011412 谢琛睿 2013011406</p>", "anon": "no", "created": "2017-03-02T08:02:21Z", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第十九讲和第二十讲 课堂思考题回答-向勇班"}, {"content": "<p>请向勇班的同学把第十九讲和第二十讲中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>第十九讲和第二十讲的回答的截止时间是明天&#xff08;20160510&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p><br />1&#xff09;第十九讲小组思考题(2)&#xff1a;给出ucore中没有实现的管程模型&#xff08;Hansen管程或Hoare管程&#xff09;。<br />2&#xff09;第二十讲小组思考题(1)&#xff1a;完成和改进银行家算法的实现。<br />3&#xff09;第二十讲小组思考题(4)&#xff1a;测试三种通信机制的性能。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p></p>\n<p>选择做“1&#xff09;第十九讲小组思考题(2)”的同学<br />郭嘉丞</p>\n<p></p>\n<p>选择做“2&#xff09;第二十讲小组思考题(1)”的同学<br />2013011402 钱迪晨 2013011413 高思达<br />高博 2012012139 赵涵 2012011383</p>\n<p></p>\n<p>选择做“3&#xff09;第二十讲小组思考题(4)”的同学<br />杨明 2013011412 谢琛睿 2013011406</p>", "anon": "no", "created": "2016-05-28T14:42:36Z", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第十九讲和第二十讲 课堂思考题回答-向勇班"}, {"content": "<p>请向勇班的同学把第十九讲和第二十讲中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>第十九讲和第二十讲的回答的截止时间是明天&#xff08;20160510&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p><br />1&#xff09;第十九讲小组思考题(2)&#xff1a;给出ucore中没有实现的管程模型&#xff08;Hansen管程或Hoare管程&#xff09;。<br />2&#xff09;第二十讲小组思考题(1)&#xff1a;完成和改进银行家算法的实现。<br />3&#xff09;第二十讲小组思考题(4)&#xff1a;测试三种通信机制的性能。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "created": "2016-05-09T01:23:36Z", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第十九讲和第二十讲 课堂思考题回答-向勇班"}, {"content": "<p>请向勇班的同学把第十九讲和第二十讲中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>第十九讲和第二十讲的回答的截止时间是明天&#xff08;20160510&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p><br />1&#xff09;第十九讲小组思考题(2)&#xff1a;给出Hansen管程和Hoare管程的实现。<br />2&#xff09;第二十讲小组思考题(1)&#xff1a;完成和改进银行家算法的实现。<br />3&#xff09;第二十讲小组思考题(4)&#xff1a;测试三种通信机制的性能。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "created": "2016-05-09T01:20:47Z", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第十九讲和第二十讲 课堂思考题回答-向勇班"}, {"content": "<p>请向勇班的同学把第十九讲和第二十讲中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>第十九讲和第二十讲的回答的截止时间是明天&#xff08;20160510&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;</p>\n<p><br />1&#xff09;第十九讲小组思考题(2)&#xff1a;给出Hansen管程和Hoare管程的实现。<br />2&#xff09;第二十讲小组思考题(1)&#xff1a;完成和改进银行家算法的实现。<br />3&#xff09;第二十讲小组思考题(4)&#xff1a;测试三种通信机制的性能。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "created": "2016-05-09T01:18:57Z", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第十九讲和第二十讲 课堂思考题回答-向勇班"}, {"content": "<p>请向勇班的同学把“第二十讲 死锁和进程通信”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>第二十讲的回答的截止时间是明天&#xff08;20160510&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;</p>\n<p></p>\n<p>小组思考题(1)&#xff1a;实现银行家算法。要求每个同学独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/08-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "created": "2016-05-07T14:57:03Z", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二十讲 课堂思考题回答-向勇班"}]}, "error": null}