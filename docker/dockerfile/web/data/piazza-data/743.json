{"aid": "imm5m5ppnps1jv", "result": {"folders": ["lecture11", "课堂问答"], "unique_views": 74, "no_answer": 0, "change_log": [{"data": "imbbow8iqqe115", "anon": "no", "when": "2016-03-28T01:35:30Z", "uid": "i1jd60b7orl10p", "type": "create"}, {"uid": "i0f9pvv0uxm6ko", "data": "imbhqdacj0253k", "when": "2016-03-28T04:24:36Z", "to": "imbbow8e4w3114", "anon": "no", "type": "s_answer"}, {"data": "imbjbcp4xa6682", "anon": "no", "when": "2016-03-28T05:08:55Z", "uid": "i0f9pvv0uxm6ko", "type": "s_answer_update"}, {"data": "imbn9ny5s2n553", "anon": "no", "when": "2016-03-28T06:59:35Z", "uid": "i0gl5kctugw3xi", "type": "update"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-01T13:21:55Z", "uid": "ikx8y1dzPrM", "type": "followup"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T02:36:58Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T04:50:11Z", "uid": "i0ayxqk6wry734", "type": "followup"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T06:43:07Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T07:00:43Z", "uid": "i0ayxqk6wry734", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T07:10:32Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T11:14:59Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T15:20:15Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-03T18:12:03Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "imbbow8e4w3114", "anon": "no", "when": "2016-04-04T01:57:45Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}], "upvote_ids": [], "id": "imbbow8e4w3114", "bookmarked": 8, "no_answer_followup": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-28T04:24:36Z", "config": {}, "tag_endorse_arr": ["i1jd60b7orl10p", "hdjonbiyfs62ie"], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [{"name": "李云龙", "admin": false, "photo": null, "us": false, "email": "liunyong@gmail.com", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "id": "i1jd60b7orl10p"}, {"admin_permission": 10, "admin": true, "photo": null, "us": false, "email": "xyong@tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "id": "hdjonbiyfs62ie", "name": "Yong XIANG"}], "bucket_order": 2, "data": {"embed_links": []}, "id": "imbhqdaa1xi53i", "history": [{"content": "<p>先从调用switch_to处说起吧&#xff0c;</p>\n<pre>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n<p>代码是这样的&#xff0c;prev是上一个进程的上下文&#xff0c;next是本进程的上下文。</p>\n<p></p>\n<p>由于这个函数是汇编写的&#xff0c;这里就涉及到x86下C语言对栈帧的使用&#xff0c;这里只介绍相关的少许知识&#xff0c;以下是C调用完switch_to以后的栈帧情况&#xff1a;</p>\n<p></p>\n<p>           --高地址</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  return address            |    ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>现在我们来看位于switch.S中的代码&#xff0c;第一部分是保存现场</p>\n<pre>    movl 4(%esp), %eax          # esp&#43;4的位置即为prev-&gt;context&#xff0c;这句话把这个指针放入了eax中\n    popl 0(%eax)                # 由于esp所在的位置是返回地址&#xff0c;其实在进程切换的角度来看&#xff0c;这个地址就是原进程恢复后该执行的地址&#xff0c;所以把它保存到prev-&gt;context中eip对应的位置。\n    movl %esp, 4(%eax)\t\t# 保存esp&#xff0c;之后的类似&#xff0c;这里的保存顺序很重要&#xff0c;必须按照context的结构来&#xff0c;具体见附录的context结构体描述&#xff0c;这里默认这个顺序是合理的就行了\n    movl %ebx, 8(%eax)\t\t# 保存ebx&#xff0c;以下略\n    movl %ecx, 12(%eax)\n    movl %edx, 16(%eax)\n    movl %esi, 20(%eax)\n    movl %edi, 24(%eax)\n    movl %ebp, 28(%eax)</pre>\n<p></p>\n<p>现在&#xff0c;由于popl了返回地址&#xff0c;栈帧是这样的&#xff1a;</p>\n<p></p>\n<p>        ----高地址</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |   ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>所以恢复现场是这样的&#xff0c;依旧注意一下恢复顺序&#xff1a;</p>\n<pre>    movl 4(%esp), %eax          # 现在的esp&#43;4对应于next-&gt;context&#xff0c;把这个指针放入eax中\n    # 按context结构来恢复现场                         \t   \n    movl 28(%eax), %ebp\t\t\n    movl 24(%eax), %edi\n    movl 20(%eax), %esi\n    movl 16(%eax), %edx\n    movl 12(%eax), %ecx\n    movl 8(%eax), %ebx\n    movl 4(%eax), %esp</pre>\n<p></p>\n<p>这样以来现场保存和恢复工作就做好了&#xff0c;最后剩跳转到新的进程&#xff1a;</p>\n<pre>    pushl 0(%eax)               # 把next-&gt;context中的eip压入栈\n    ret</pre>\n<p></p>\n<p>注意到我们先弹出了一个原进程的返回地址&#xff0c;现在又压入了一个新进程的返回地址&#xff0c;switch_to没有破坏栈帧结构。</p>\n<p></p>\n<p></p>\n<p>附&#xff1a;</p>\n<p>context类型和在内存中的存放</p>\n<pre>struct context {\n    uint32_t eip;\n    uint32_t esp;\n    uint32_t ebx;\n    uint32_t ecx;\n    uint32_t edx;\n    uint32_t esi;\n    uint32_t edi;\n    uint32_t ebp;\n};</pre>\n<p>在内存中的存放&#xff1a;</p>\n<p>-----------------</p>\n<p>|  context.ebp |     高地址</p>\n<p>-----------------</p>\n<p>|  context.edi   | </p>\n<p>-----------------</p>\n<p>|  context.esi   | </p>\n<p>-----------------</p>\n<p>|  context.eip   | </p>\n<p>-----------------</p>\n<p>|  context.edx  | </p>\n<p>-----------------</p>\n<p>|  context.ecx  | </p>\n<p>-----------------</p>\n<p>|  context.ebx  | </p>\n<p>-----------------</p>\n<p>|  context.esp  | </p>\n<p>-----------------</p>\n<p>|  context.eip   |   低地址</p>\n<p>-----------------</p>", "anon": "no", "subject": "", "uid": "i0f9pvv0uxm6ko", "created": "2016-03-28T05:08:55Z"}, {"content": "<p>先从调用switch_to处说起吧&#xff0c;</p>\n<pre>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n<p>代码是这样的&#xff0c;prev是上一个进程的上下文&#xff0c;next是本进程的上下文。</p>\n<p></p>\n<p>由于这个函数是汇编写的&#xff0c;这里就涉及到x86下C语言对栈帧的使用&#xff0c;这里只介绍相关的少许知识&#xff0c;以下是C调用完switch_to以后的栈帧情况&#xff1a;</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  return address            |    ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>现在我们来看位于switch.S中的代码&#xff0c;第一部分是保存现场</p>\n<pre>    movl 4(%esp), %eax          # esp&#43;4的位置即为prev-&gt;context&#xff0c;这句话把这个指针放入了eax中\n    popl 0(%eax)                # 由于esp所在的位置是返回地址&#xff0c;其实在进程切换的角度来看&#xff0c;这个地址就是原进程恢复后该执行的地址&#xff0c;所以把它保存到prev-&gt;context中eip对应的位置。\n    movl %esp, 4(%eax)\t\t# 保存esp&#xff0c;之后的类似&#xff0c;这里的保存顺序很重要&#xff0c;必须按照context的结构来&#xff0c;具体见附录的context结构体描述&#xff0c;这里默认这个顺序是合理的就行了\n    movl %ebx, 8(%eax)\t\t# 保存ebx&#xff0c;以下略\n    movl %ecx, 12(%eax)\n    movl %edx, 16(%eax)\n    movl %esi, 20(%eax)\n    movl %edi, 24(%eax)\n    movl %ebp, 28(%eax)</pre>\n<p></p>\n<p>现在&#xff0c;由于popl了返回地址&#xff0c;栈帧是这样的&#xff1a;</p>\n<p>----------------------------</p>\n<p>|  arg1: next-&gt;context    |</p>\n<p>----------------------------</p>\n<p>|  arg0: prev-&gt;context    |   ---&gt; esp</p>\n<p>----------------------------</p>\n<p></p>\n<p>所以恢复现场是这样的&#xff0c;依旧注意一下恢复顺序&#xff1a;</p>\n<pre>    movl 4(%esp), %eax          # 现在的esp&#43;4对应于next-&gt;context&#xff0c;把这个指针放入eax中\n    # 按context结构来恢复现场                         \t   \n    movl 28(%eax), %ebp\t\t\n    movl 24(%eax), %edi\n    movl 20(%eax), %esi\n    movl 16(%eax), %edx\n    movl 12(%eax), %ecx\n    movl 8(%eax), %ebx\n    movl 4(%eax), %esp</pre>\n<p></p>\n<p>这样以来现场保存和恢复工作就做好了&#xff0c;最后剩跳转到新的进程&#xff1a;</p>\n<pre>    pushl 0(%eax)               # 把next-&gt;context中的eip压入栈\n    ret</pre>\n<p></p>\n<p>注意到我们先弹出了一个原进程的返回地址&#xff0c;现在又压入了一个新进程的返回地址&#xff0c;switch_to没有破坏栈帧结构。</p>\n<p></p>\n<p></p>\n<p>附&#xff1a;</p>\n<p>context类型和在内存中的存放</p>\n<pre>struct context {\n    uint32_t eip;\n    uint32_t esp;\n    uint32_t ebx;\n    uint32_t ecx;\n    uint32_t edx;\n    uint32_t esi;\n    uint32_t edi;\n    uint32_t ebp;\n};</pre>\n<p></p>", "anon": "no", "subject": "", "uid": "i0f9pvv0uxm6ko", "created": "2016-03-28T04:24:36Z"}]}, {"folders": [], "updated": "2016-04-01T13:21:55Z", "no_upvotes": 0, "uid": "ikx8y1dzPrM", "created": "2016-04-01T13:21:55Z", "type": "followup", "no_answer": 0, "id": "imhqor8uqa93vk", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-04-03T02:36:58Z", "uid": "hdjonbiyfs62ie", "created": "2016-04-03T02:36:58Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imjyj2531w4311", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>是的。</p>"}, {"folders": [], "updated": "2016-04-03T11:14:59Z", "uid": "ikx8y1dzPrM", "created": "2016-04-03T11:14:59Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imkh18boouu3qi", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>&#64;Instructor 那么有这样一个问题&#xff0c;这个进程被切换走的时候上下文中保存的esp指向调用switch_to时压栈的from参数&#xff0c;而eip指向</p>\n<p>call switch_to的下一条指令。当该进程被切换回来的时候&#xff0c;switch_to最后一行ret会使得该进程执行call switch_to的后一条指令&#xff0c;而此时如果要想使得该进程感受不到switch带来的痕迹&#xff0c;应该esp也指向switch_to压栈前的位置&#xff0c;即为from&#43;8。我认为在保存上下文的时候要有mov [eax&#43;4],esp add dword ptr [eax&#43;4] ,0x08 (不会AT&amp;T,写Intel格式了)。</p>"}, {"folders": [], "updated": "2016-04-03T15:20:15Z", "uid": "hdjonbiyfs62ie", "created": "2016-04-03T15:20:15Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imkpsnhqih3gn", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>在switch_to中esp只受压栈和出栈操作的影响&#xff0c;没有你说的这个差值。你可以单步跟踪一下&#xff0c;进程切换的上下文保存的context结构中&#xff0c;eip到底在哪。</p>\n<p></p>\n<p>如果可能&#xff0c;请把你的跟踪结果附在本帖后面&#xff0c;并描述你的理解。</p>"}, {"folders": [], "updated": "2016-04-03T18:12:03Z", "uid": "ikx8y1dzPrM", "created": "2016-04-03T18:12:03Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imkvxkkmcj44s6", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>&#64;instructor 我看了一下反汇编然后跟踪了一下&#xff0c;现在理解是这样的&#xff1a;</p>\n<p>1.context.eip是call switch_to的下一条汇编指令这个想的是对的。</p>\n<p>2.context.esp是caller的堆栈的调用switch_to之前的位置&#xff0c;也是caller调用switch_to之后的esp的位置&#xff0c;因为在整个函数</p>\n<p>调用过程中&#xff0c;esp是不发生变化的&#xff0c;参数的传递是改变 (offset)%ebp静态实现的&#xff0c;也就是esp一开始就下降足够大的空间&#xff0c;在esp</p>\n<p>的紧挨的上方的内存修改数据达到传递参数的目的。在switch_to里面由于pop了一次&#xff0c;将sub 4的esp增加4&#xff0c;达到switch_to返回后</p>\n<p>的状态&#xff0c;因此在进程切换回来的时候&#xff0c;eip,esp均为好像从switch_to返回后一样的状态&#xff0c;其他寄存器也都保持了switch_to</p>\n<p>调用前的状态&#xff0c;只有eax会发生改变。</p>\n<p>那么有这样一个问题&#xff0c;如果eax切换前保存了某些重要信息而切换回来的时候变化了&#xff0c;就会发生问题&#xff0c;但是在ucore汇编代码中不会</p>\n<p>出现这种问题&#xff0c;因为切换回来后eax被赋值了。</p>\n<p></p>"}, {"folders": [], "updated": "2016-04-04T01:57:45Z", "uid": "hdjonbiyfs62ie", "created": "2016-04-04T01:57:45Z", "type": "feedback", "id": "imlckgtojpc5ze", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>关于堆栈的分析应该是较为全面和准确的。</p>\n<p></p>\n<p>关于eax的事&#xff0c;执行这段代码时&#xff0c;系统已在内核&#xff0c;应该保护的寄存器都已做过保存了。</p>"}], "subject": "<p>&#64;作者  问一下switch_to中对from保存的上下文是schedule()中switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));这一行代码的上下文么&#xff1f;</p>"}, {"folders": [], "updated": "2016-04-03T04:50:11Z", "no_upvotes": 0, "uid": "i0ayxqk6wry734", "created": "2016-04-03T04:50:11Z", "type": "followup", "d-bucket": "Yesterday", "id": "imk3adshq594ko", "anon": "no", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-03T06:43:07Z", "uid": "hdjonbiyfs62ie", "created": "2016-04-03T06:43:07Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imk7blq5zpwl5", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>压栈对应当前运行进程&#xff0c;出栈对应下一个运行进程。</p>\n<p></p>\n<p>你可以把这两进程的变化理解成&#xff0c;当前运行进程的压栈和它在下一次被调度后再次变成当前进程时的情况。这两次操作的栈就是同一个了。这样应该会好理解一些。</p>"}, {"folders": [], "updated": "2016-04-03T07:00:43Z", "uid": "i0ayxqk6wry734", "created": "2016-04-03T07:00:43Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imk7y8ulpw1sk", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>嗯这个我明白了&#xff0c;以及switch这个函数到底是在哪个进程的内核栈做的&#xff1f;</p>\n<p>注意到proc_run在switch之前是lcr3以及改过tss.esp0的&#xff0c;这个tss的内核栈和当前运行过程中的内核栈有关系吗&#xff1f;</p>"}, {"folders": [], "updated": "2016-04-03T07:10:32Z", "uid": "hdjonbiyfs62ie", "created": "2016-04-03T07:10:32Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imk8avb164d53d", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>你可以在这几个函数中通过查询当前的CR3和堆栈状态来了解当前进程和内核栈的信息&#xff0c;从而确定进程切换指令的位置和影响。</p>\n<p></p>\n<p>如果有兴趣&#xff0c;把你的跟踪结果附在本帖后面&#xff0c;并描述你的理解。</p>"}], "subject": "<p>话说弹出和压入返回地址不是在一个栈上做的吧&#xff1f;</p>\n<p>注意到你在压入新返回地址时修改过esp了&#xff0c;栈应该切换过才对&#xff1f;</p>"}], "request_instructor_me": false, "nr": 743, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lecture11", "student", "课堂问答"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-28T01:35:30Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1459783852909, "tag_good": [{"admin_permission": 10, "admin": true, "photo": null, "us": false, "email": "xyong@tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "id": "hdjonbiyfs62ie", "name": "Yong XIANG"}], "tag_good_arr": ["hdjonbiyfs62ie"], "history": [{"content": "<p>/lab4/kern/process/switch.S文件中&#xff0c;</p>\n<p></p>\n<p>如何理解这段代码&#xff1f;</p>\n<p>代码中两个部分即保存现场和恢复现场是怎样对应链接的&#xff1f;</p>\n<p>C代码是如何与汇编代码对接的&#xff1f;</p>", "anon": "no", "subject": "课堂提问 进程切换代码", "uid": "i0gl5kctugw3xi", "created": "2016-03-28T06:59:35Z"}, {"content": "<p>/lab4/kern/process/switch.S文件中&#xff0c;</p>\n<p></p>\n<p>如何理解这段代码&#xff1f;</p>\n<p>代码中两个部分即保存现场和恢复现场是怎样对应链接的&#xff1f;</p>", "anon": "no", "subject": "课堂提问 进程切换代码", "uid": "i1jd60b7orl10p", "created": "2016-03-28T01:35:30Z"}]}, "error": null}