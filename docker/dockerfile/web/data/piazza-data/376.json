{"aid": "igkps891yyhax", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 5, "request_instructor": 0, "history": [{"uid": "i6rse620tbL", "anon": "no", "created": "2015-05-02T00:58:36Z", "content": "<p>kernel panic at kern/mm/default_pmm.c:359:<br />    assertion failed: (p0 = alloc_page()) == p2 - 1</p>\n<p>以上为错误信息。</p>\n<p></p>\n<p>这是我的代码&#xff1a;</p>\n<p></p>\n<p>static struct Page * bf_alloc_pages(size_t n) {</p>\n<p>         int flag=0;</p>\n<p>   assert(n &gt; 0);</p>\n<p>   if (n &gt; nr_free)</p>\n<p>       return NULL;</p>\n<p>   list_entry_t *le, *len, *minle;</p>\n<p>         le = &amp;free_list;</p>\n<p>         minle = &amp;free_list;</p>\n<p>         struct Page *minp = le2page(minle, page_link);</p>\n<p>         while((le = list_next(le)) != &amp;free_list) {</p>\n<p>                   struct Page *p = le2page(le, page_link);</p>\n<p>                   if(p-&gt;property &gt;= n ) {</p>\n<p>                            if(minp-&gt;property <strong>&gt;</strong> p-&gt;property){</p>\n<p>                                     minp = p;</p>\n<p>                                     minle = le;</p>\n<p>                            }</p>\n<p>                            flag = 1;</p>\n<p>                   }</p>\n<p>         }</p>\n<p>         le = minle;</p>\n<p>         if(flag == 1) {  </p>\n<p>                   int i;</p>\n<p>                   for(i=0; i&lt;n; i&#43;&#43;) {</p>\n<p>                            len = list_next(le);</p>\n<p>                            struct Page *pp = le2page(le, page_link);</p>\n<p>                            SetPageReserved(pp);</p>\n<p>                            ClearPageProperty(pp);</p>\n<p>                            list_del(le);</p>\n<p>                            le = len;</p>\n<p>                   }</p>\n<p>                   if(minp-&gt;property &gt; n)</p>\n<p>                            (le2page(le, page_link))-&gt;property = minp-&gt;property - n;</p>\n<p>                   ClearPageProperty(minp);</p>\n<p>                   SetPageReserved(minp);</p>\n<p>                   nr_free -= n;</p>\n<p>                   return minp;</p>\n<p>         }</p>\n<p>         return NULL;</p>\n<p>}</p>\n<p></p>\n<p>default_check()函数中出错代码附近的代码为&#xff1a;</p>\n<p>struct Page *p0 = alloc_pages(5), *p1, *p2;<br />    assert(p0 != NULL);<br />    assert(!PageProperty(p0));<br /> <br />    list_entry_t free_list_store = free_list;<br />    list_init(&amp;free_list);<br />    assert(list_empty(&amp;free_list));<br />    assert(alloc_page() == NULL);</p>\n<p>    unsigned int nr_free_store = nr_free;<br />    nr_free = 0;</p>\n<p>    free_pages(p0 &#43; 2, 3);<br />    assert(alloc_pages(4) == NULL);<br />    assert(PageProperty(p0 &#43; 2) &amp;&amp; p0[2].property == 3);<br />    assert((p1 = alloc_pages(3)) != NULL);<br />    assert(alloc_page() == NULL);<br />    assert(p0 &#43; 2 == p1);</p>\n<p>    p2 = p0 &#43; 1;<br />    free_page(p0);<br />    free_pages(p1, 3);<br />    assert(PageProperty(p0) &amp;&amp; p0-&gt;property == 1);<br />    assert(PageProperty(p1) &amp;&amp; p1-&gt;property == 3);<br />    <strong>assert((p0 = alloc_page()) == p2 - 1); //出错</strong></p>\n<p><strong></strong></p>\n<p><strong>没有分析出来&#xff0c;这一块检查的是什么错误&#xff0c;为什么p0要等于p2-1&#xff1f;</strong></p>", "subject": "实现Best/Worst fit 算法时&#xff0c;default_check()出现错误"}], "s_edits": [], "is_bookmarked": false, "tag_good_arr": [], "request_instructor_me": false, "my_favorite": false, "t": 1446636102085, "children": [{"is_tag_endorse": false, "created": "2015-05-02T01:11:20Z", "id": "i96c2ukgawz7ga", "tag_endorse": [{"name": "Darin", "id": "i6rse620tbL", "role": "student", "facebook_id": null, "photo": null, "admin": false, "us": false}], "folders": [], "history": [{"uid": "i72xyao1QhO", "anon": "no", "created": "2015-05-02T01:11:20Z", "content": "<p>实现别的算法的时候怎么还用first_fit的检测方法, 肯定是有问题的啊, 检测的函数得自己重新写, 这个检测函数是专门针对first_fit的</p>", "subject": ""}], "config": {}, "data": {"embed_links": []}, "bucket_order": 2, "bucket_name": "Today", "tag_endorse_arr": ["i6rse620tbL"], "children": [], "type": "s_answer"}, {"uid": "i6rse620tbL", "no_answer": 0, "created": "2015-05-02T02:14:18Z", "id": "i96ebto07w11d8", "updated": "2015-05-02T02:14:18Z", "subject": "<p>我也在怀疑这个&#xff0c;问题是&#xff0c;我不是太明白&#xff0c;最先匹配的检测算法&#xff0c;都检测了哪些问题&#xff0c;尤其是在这出错的那一句&#xff0c;是检测什么东西&#xff1f;</p>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 5, "bucket_name": "Last week", "no_upvotes": 0, "children": [{"uid": "hxu22d7okof4c1", "created": "2015-05-06T17:01:24Z", "id": "i9czs28dieyj", "updated": "2015-05-06T17:01:24Z", "subject": "<p>既然已知是最先匹配&#xff0c;那么每次分配/释放后的地址大小关系都是可以手算出来的&#xff0c;没有什么随机因素&#xff0c;随他怎么检测吧&#xff0c;只要有一个正确的最先匹配算法通过了检测&#xff0c;就能说明检测函数是正确的。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "children": [], "type": "feedback"}], "type": "followup"}], "type": "question", "unique_views": 45, "created": "2015-05-02T00:58:36Z", "id": "i96bmhdgh5s2mb", "no_answer": 0, "nr": 376, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["lab2"], "bucket_order": 2, "change_log": [{"uid": "i6rse620tbL", "when": "2015-05-02T00:58:36Z", "data": "i96bmhdjx2o2mc", "anon": "no", "type": "create"}, {"uid": "i72xyao1QhO", "when": "2015-05-02T01:11:20Z", "data": "i96c2uklf227gb", "to": "i96bmhdgh5s2mb", "anon": "no", "type": "s_answer"}, {"uid": "i6rse620tbL", "when": "2015-05-02T02:14:18Z", "to": "i96bmhdgh5s2mb", "anon": "no", "type": "followup"}, {"uid": "hxu22d7okof4c1", "when": "2015-05-06T17:01:24Z", "to": "i96bmhdgh5s2mb", "anon": "no", "type": "feedback"}], "bucket_name": "Today", "tags": ["lab2", "student"], "no_answer_followup": 0, "num_favorites": 0, "tag_good": []}}