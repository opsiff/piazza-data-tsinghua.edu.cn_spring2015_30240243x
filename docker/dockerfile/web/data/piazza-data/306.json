{"aid": "igkpkkzndqrj", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 6, "request_instructor": 0, "history": [{"uid": "i70finilY0O", "anon": "no", "created": "2015-04-15T11:05:25Z", "content": "<p>陈老师在学堂在线视频中讲lab1的challenge实质是在内核栈中模拟出内核到用户的切换和用户到内核的切换。我的问题是lab1_switch_to_user执行后把esp-8,内核栈中的tf_es,tf_ds,tf_ss都付值为USER_DS,但是tf_esp应该怎么付值,参考答案中的switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;不理解。还有*((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;这句也不理解</p>", "subject": "关于lab1的特权切换问题"}], "s_edits": [], "is_bookmarked": false, "tag_good_arr": [], "request_instructor_me": false, "my_favorite": false, "t": 1446635745347, "children": [{"is_tag_endorse": false, "created": "2015-04-16T03:39:20Z", "id": "i8jmbjsxf912k2", "tag_endorse": [], "folders": [], "history": [{"uid": "hs2swpdtr91gu", "anon": "no", "created": "2015-04-16T03:39:20Z", "content": "<p>tf_esp在struct trapframe中的偏移正好是sizeof(struct trapframe) - 8。</p>\n<p>*((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u这一句完成了trapframe的赋值&#xff0c;(uint32_t *)tf是一个指针&#xff0c;即将tf指向的那个trapframe的前一个trapframe赋值为switchk2u</p>", "subject": ""}], "config": {}, "data": {"embed_links": []}, "bucket_order": 2, "bucket_name": "Today", "tag_endorse_arr": [], "children": [], "type": "i_answer"}, {"is_tag_endorse": false, "created": "2015-04-16T15:54:46Z", "id": "i8kclbzef8e2xi", "tag_endorse": [], "folders": [], "history": [{"uid": "i6rgfjo5j1r6c", "anon": "no", "created": "2015-04-16T15:55:52Z", "content": "<p>在trapentry.s中有处理中断的总入口。它在栈中模拟了一个trapframe结构&#xff0c;并用push %esp来实现了一个指针&#xff0c;作为参数调用trapdispatch。返回之后再把所有的参数弹出回复原状。所以我们只需要修改trapframe结构中的cs和esp等的变量即可实现切换特权级。</p>\n<p></p>\n<p>但是&#xff0c;这个切换并不是对称的。从内核态切换到用户态&#xff0c;比从用户态切换到内核态&#xff0c;栈中少了cs和esp两个元素。这个是因为在内核态的时候调用中断并没有发生特权级转换&#xff0c;而在用户态的时候调用中断则出现了特权级转换&#xff08;中断是在内核处理的&#xff09;。这样的话导致了内核态的trapframe不是完整的&#xff0c;它少了cs和esp。所以我们不能直接修改参数中的trapframe&#xff0c;它只是一个被虚拟出来的结构。</p>\n<p></p>\n<p>从内核态切换到用户态的时候&#xff0c;参数的trapframe不是完整的&#xff0c;而我们返回的时候需要返回一个完整的包含cs和esp的trapframe&#xff0c;从而让iret觉得这是一个特权级切换&#xff0c;然后正常进入到用户态。由于参数少了cs和esp&#xff0c;我们切换到用户态的时候&#xff0c;新建一个trapframe实例&#xff0c;它的esp要设置成离trapframe指针相差sizeof(trapframe)-8的位置&#xff0c;才能在返回的时候回到正常的位置。</p>\n<p></p>\n<p>同理从用户态切换到内核态的时候&#xff0c;参数是一个完整的trapframe&#xff0c;但是我们需要返回一个不完整trapframe的指针。所以切换到内核态的时候&#xff0c;需要一个trapframe&#xff0c;它的指针头距离压栈前的栈顶为sizeof(trapframe)-8。</p>\n<p></p>\n<p>所以为了实现的方便&#xff0c;这两种情况分别用了一个实例和一个指针&#xff0c;这个指针设置好之后再把数据搬过去。</p>\n<p></p>\n<p>值得注意的是&#xff0c;最后一句话的效果非常的神奇。由于在调用trapdispatch之前有一句push %esp&#xff0c;所以输入参数作为地址减去8字节之后&#xff0c;就是自己所在的地址。然后让这个地址中的数改为我们想要返回的trapframe的指针&#xff0c;在返回之后经过汇编代码的pop %esp即可把esp移过去trapframe中&#xff0c;让它pop的时候把我们修改过的寄存器的值放进寄存器中&#xff0c;之后再经过一次iret把%esp复原&#xff0c;即可不被察觉地切换特权级。</p>", "subject": ""}, {"uid": "i6rgfjo5j1r6c", "anon": "no", "created": "2015-04-16T15:54:46Z", "content": "<p>在trapentry.s中有处理中断的总入口。它在栈中模拟了一个trapframe结构&#xff0c;并用push %esp来实现了一个指针&#xff0c;作为参数调用trapdispatch。<br />返回之后再把所有的参数弹出回复原状。所以我们只需要修改trapframe结构中的cs和esp等的变量即可实现切换特权级。</p>\n<p>但是&#xff0c;这个切换并不是对称的。从内核态切换到用户态&#xff0c;比从用户态切换到内核态&#xff0c;栈中少了cs和esp两个元素。<br />这个是因为在内核态的时候调用中断并没有发生特权级转换&#xff0c;而在用户态的时候调用中断则出现了特权级转换&#xff08;中断是在内核处理的&#xff09;。<br />这样的话导致了内核态的trapframe不是完整的&#xff0c;它少了cs和esp。所以我们不能直接修改参数中的trapframe&#xff0c;它只是一个被虚拟出来的结构。</p>\n<p>从内核态切换到用户态的时候&#xff0c;参数的trapframe不是完整的&#xff0c;而我们返回的时候需要返回一个完整的包含cs和esp的trapframe&#xff0c;从而让iret觉得<br />这是一个特权级切换&#xff0c;然后正常进入到用户态。由于参数少了cs和esp&#xff0c;我们切换到用户态的时候&#xff0c;新建一个trapframe实例&#xff0c;<br />它的esp要设置成离trapframe指针相差sizeof(trapframe)-8的位置&#xff0c;才能在返回的时候回到正常的位置。</p>\n<p>同理从用户态切换到内核态的时候&#xff0c;参数是一个完整的trapframe&#xff0c;但是我们需要返回一个不完整trapframe的指针。<br />所以切换到内核态的时候&#xff0c;需要一个trapframe&#xff0c;它的指针头距离压栈前的栈顶为sizeof(trapframe)-8。</p>\n<p>所以为了实现的方便&#xff0c;这两种情况分别用了一个实例和一个指针&#xff0c;这个指针设置好之后再把数据搬过去。</p>\n<p>值得注意的是&#xff0c;最后一句话的效果非常的神奇。由于在调用trapdispatch之前有一句push %esp&#xff0c;所以输入参数作为地址减去8字节之后&#xff0c;就是自己所在的地址。<br />然后让这个地址中的数改为我们想要返回的trapframe的指针&#xff0c;在返回之后经过汇编代码的pop %esp即可把esp移过去trapframe中&#xff0c;<br />让它pop的时候把我们修改过的寄存器的值放进寄存器中&#xff0c;之后再经过一次iret把%esp复原&#xff0c;即可不被察觉地切换特权级。</p>", "subject": ""}], "config": {}, "data": {"embed_links": []}, "bucket_order": 2, "bucket_name": "Today", "tag_endorse_arr": [], "children": [], "type": "s_answer"}, {"uid": "i7v6ov4srIK", "no_answer": 1, "created": "2015-06-19T09:26:54Z", "id": "ib3ex23yz7t6jf", "updated": "2015-06-19T09:26:54Z", "subject": "<p>用户态切换回内核态不用memmove那一段也可以的吧?</p>\n<p>只需要把tf的几个段寄存器改成内核的就可以了, 因为trap进来的时候就已经带了完整的frame, memmove没有作用.</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}], "type": "question", "unique_views": 65, "created": "2015-04-15T11:05:25Z", "id": "i8imtd1farc27i", "no_answer": 0, "nr": 306, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["lab1"], "bucket_order": 2, "change_log": [{"uid": "i70finilY0O", "when": "2015-04-15T11:05:25Z", "data": "i8imtd1kjiq27j", "anon": "no", "type": "create"}, {"uid": "hs2swpdtr91gu", "when": "2015-04-16T03:39:20Z", "data": "i8jmbjt1o6v2k3", "to": "i8imtd1farc27i", "anon": "no", "type": "i_answer"}, {"uid": "i6rgfjo5j1r6c", "when": "2015-04-16T15:54:46Z", "data": "i8kclbzf3h62xj", "to": "i8imtd1farc27i", "anon": "no", "type": "s_answer"}, {"uid": "i6rgfjo5j1r6c", "when": "2015-04-16T15:55:52Z", "data": "i8kcmr05wr42jm", "anon": "no", "type": "s_answer_update"}, {"uid": "i7v6ov4srIK", "when": "2015-06-19T09:26:55Z", "to": "i8imtd1farc27i", "anon": "no", "type": "followup"}], "bucket_name": "Today", "tags": ["lab1", "student"], "no_answer_followup": 1, "num_favorites": 2, "tag_good": []}}