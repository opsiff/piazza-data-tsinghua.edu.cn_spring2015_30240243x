{"aid": "iztz8o6q8kspv", "result": {"status": "active", "unique_views": 16, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-03-03T08:49:09Z", "data": "iztkw7c1x8w77g", "uid": "ie7xy9yltfs1uq"}, {"uid": "ie7xy9yltfs1uq", "type": "s_answer", "when": "2017-03-03T09:10:25Z", "to": "iztkw7by6pe77f", "anon": "no", "data": "iztlnjrs19l6f9"}, {"to": "iztkw7by6pe77f", "anon": "no", "when": "2017-03-03T14:23:49Z", "type": "followup", "uid": "ie7xy8iscsw1t7"}], "upvote_ids": [], "id": "iztkw7by6pe77f", "bookmarked": 5, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2017-03-03T09:10:25Z", "type": "s_answer", "tag_endorse_arr": [], "id": "iztlnjrpp9i6f8", "bucket_name": "Today", "config": {}, "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "children": [], "history": [{"content": "<p>目前感觉是gdb只加载了kernel&#xff0c;还在实模式类似的问题&#xff0c;但具体的还不太清楚</p>", "anon": "no", "created": "2017-03-03T09:10:25Z", "uid": "ie7xy9yltfs1uq", "subject": ""}]}, {"folders": [], "updated": "2017-03-03T14:23:49Z", "no_upvotes": 0, "uid": "ie7xy8iscsw1t7", "created": "2017-03-03T14:23:49Z", "type": "followup", "no_answer": 1, "id": "iztwul797fe5hs", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>我感觉在gdb中打印的$PC的值是$EIP的值&#xff0c;但是实际执行的指令地址是base&#43;EIP&#xff0c;就出现了$pc值“不正确”的现象。停在执行第一条指令之前的时候&#xff0c;虽然gdb显示的$pc=0x0000fff0&#xff0c;但是运行si命令之后会发现执行的命令其实是0xfffffff0处的跳转指令。</p>"}], "nr": 997, "bucket_order": 2, "type": "question", "folders": ["lab1"], "no_answer_followup": 1, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "tags": ["lab1", "student"], "created": "2017-03-03T08:49:09Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1488555045746, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>想做的是停在BIOS第一条指令处并查看一些寄存器的信息&#xff0c;为此进行了以下操作&#xff1a;</p>\n<p></p>\n<p>在Makefile中加入以下代码&#xff1a;</p>\n<pre>lab1-mon: $(UCOREIMG)\n\t$(V)$(TERMINAL) -e &#34;$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $&lt; -serial null&#34;\n\t$(V)sleep 2\n\t$(V)$(TERMINAL) -e &#34;gdb -q -x tools/lab1init&#34;</pre>\n<p>其中的-monitor stdio -hda参数会启动qemu的monitor&#xff0c;可以在其中显示一些信息&#xff1b;</p>\n<p>在tools/lab1init文件中加入以下初始化gdb的代码&#xff1a;</p>\n<pre>file bin/kernel<br />set architecture i386<br />target remote :1234</pre>\n<p>这时运行</p>\n<pre>make lab1-mon</pre>\n<p>应当会启动一个qemu、一个qemu的monitor、一个gdb的命令行&#xff0c;并且停在执行第一条指令之前。</p>\n<p>这时如果查看当前pc及之后的汇编代码&#xff0c;在gdb命令行和monitor中分别运行</p>\n<pre>x /10i $pc</pre>\n<p>会发现结果不一样&#xff0c;理论上这时$pc应是0xfffffff0&#xff0c;gdb显示的却是0x0000fff0&#xff1a;</p>\n<pre>(gdb) x /10i $pc\n=&gt; 0xfff0:\tadd    %al,(%eax)\n   0xfff2:\tadd    %al,(%eax)\n   0xfff4:\tadd    %al,(%eax)\n   0xfff6:\tadd    %al,(%eax)\n   0xfff8:\tadd    %al,(%eax)\n   0xfffa:\tadd    %al,(%eax)\n   0xfffc:\tadd    %al,(%eax)\n   0xfffe:\tadd    %al,(%eax)\n   0x10000:\tadd    %al,(%eax)\n   0x10002:\tadd    %al,(%eax)</pre>\n<p>monitor显示是正确的预期结果&#xff1a;</p>\n<pre>(qemu) x /10i $pc\n0xfffffff0:  ljmp   $0xf000,$0xe05b\n0xfffffff5:  xor    %dh,0x322f\n0xfffffff9:  xor    (%bx),%bp\n0xfffffffb:  cmp    %di,(%bx,%di)\n0xfffffffd:  add    %bh,%ah\n0xffffffff:  add    %al,(%bx,%si)\n0x00000001:  add    %al,(%bx,%si)\n0x00000003:  add    %al,(%bx,%si)\n0x00000005:  add    %al,(%bx,%si)\n0x00000007:  add    %al,(%bx,%si)</pre>\n<p></p>\n<p>实际测试中还发现如果在gdb中设置断点为32位的地址处&#xff0c;比如0xfe05b&#xff0c;gdb会显示停到了低16位的地址处0xe05b&#xff0c;并且继续用si单步执行的话也执行不下去。所以猜测gdb对于32位的内存地址设置断点还有显示会有一些问题&#xff1f;这样的话对于之后在gdb中调试可能会产生一些影响&#xff0c;是否可能需要在gdb中进行某些设置或者是其他什么原因&#xff1f;</p>", "anon": "no", "created": "2017-03-03T08:49:09Z", "uid": "ie7xy9yltfs1uq", "subject": "gdb的寄存器信息不同于monitor显示的信息"}]}, "error": null}