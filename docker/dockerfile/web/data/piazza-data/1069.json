{"aid": "j49h0p5v8i2co", "result": {"status": "active", "unique_views": 67, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-05-06T14:47:56Z", "data": "j2ddw434mc24ei", "uid": "ikjdo9jtz0e2jq"}, {"type": "update", "anon": "no", "when": "2017-05-06T14:49:10Z", "data": "j2ddxp946fp4tl", "uid": "ikjdo9jtz0e2jq"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-05-06T15:22:06Z", "type": "followup", "uid": "i5g31e12hcr27s"}, {"type": "update", "anon": "no", "when": "2017-05-07T06:12:55Z", "data": "j2eaxnekcfb4ei", "uid": "ikjdo9jtz0e2jq"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-05-08T13:55:11Z", "type": "followup", "uid": "izb0cbqbyzd6wf"}, {"type": "update", "anon": "no", "when": "2017-05-12T05:49:21Z", "data": "j2lfaltfshs4pw", "uid": "ikjdo9jtz0e2jq"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-06-01T16:18:33Z", "type": "followup", "uid": "hdjonbiyfs62ie"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-06-22T16:05:53Z", "type": "feedback", "uid": "i0fcjeg6hm4qw"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-06-23T02:40:52Z", "type": "feedback", "uid": "hdjonbiyfs62ie"}], "upvote_ids": [], "id": "j2ddw43190u4eh", "bookmarked": 6, "tags": ["lecture18", "student"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2017-05-06T15:22:06Z", "no_upvotes": 0, "uid": "i5g31e12hcr27s", "created": "2017-05-06T15:22:06Z", "type": "followup", "no_answer": 0, "id": "j2df429qerv2rf", "anon": "no", "bucket_name": "Week 4/30 - 5/6", "config": {}, "bucket_order": 12, "data": null, "children": [], "subject": "<p><a href=\"https://gist.github.com/mengcz13/c032ef918cf8ceb34761cc207c9a80ed\">https://gist.github.com/mengcz13/c032ef918cf8ceb34761cc207c9a80ed</a></p>\n<p></p>\n<pre>Barber is sleeping...\n1 customer entered, and 0 customers are waiting...\n1 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n1\t0\t0\t0\nBarber starts working...\n2 customer entered, and 0 customers are waiting...\n2 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n2\t0\t0\t1\n3 customer entered, and 1 customers are waiting...\n3 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n2\t3\t0\t1\nCustomer 1 has just had his hair cut!\nBarber starts working...\nCustomer 2 has just had his hair cut!\nBarber starts working...\nCustomer 3 has just had his hair cut!\nBarber is sleeping...\n4 customer entered, and 0 customers are waiting...\n4 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n4\t0\t0\t0\nBarber starts working...\n5 customer entered, and 0 customers are waiting...\n5 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n5\t0\t0\t4\n6 customer entered, and 1 customers are waiting...\n6 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n5\t6\t0\t4\nCustomer 4 has just had his hair cut!\nBarber starts working...\n7 customer entered, and 1 customers are waiting...\n7 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n7\t6\t0\t5\n8 customer entered, and 2 customers are waiting...\n8 customer sits at 2!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n7\t6\t8\t5\nCustomer 5 has just had his hair cut!\nBarber starts working...\nCustomer 6 has just had his hair cut!\nBarber starts working...\n9 customer entered, and 1 customers are waiting...\n9 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n9\t0\t8\t7\n10 customer entered, and 2 customers are waiting...\n10 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n9\t10\t8\t7\nCustomer 7 has just had his hair cut!\nBarber starts working...\nCustomer 8 has just had his hair cut!\nBarber starts working...\nCustomer 9 has just had his hair cut!\nBarber starts working...\nCustomer 10 has just had his hair cut!\nBarber is sleeping...</pre>\n<p></p>"}, {"folders": [], "updated": "2017-05-08T13:55:11Z", "no_upvotes": 0, "uid": "izb0cbqbyzd6wf", "created": "2017-05-08T13:55:11Z", "type": "followup", "no_answer": 0, "id": "j2g6vzs5en76uk", "anon": "no", "bucket_name": "Week 5/7 - 5/13", "config": {}, "bucket_order": 11, "data": null, "children": [], "subject": "<p>我使用 nodejs 重新实现了一下这个问题.</p>\n<p></p>\n<p>nodejs 的好处在于原生支持异步, 但是实际上是单线程执行, 一个函数执行过程中不会因为时钟中断而挂起, 相当于每个函数自带了锁. 所以更方便研究同步问题. </p>\n<p></p>\n<p>我使用了 sempahore 这个库的信号量. 然后先写了一个能正常输出的版本.</p>\n<p></p>\n<pre>const chairs = 5;\nconst barbers = 1;\nconst comeTime = [ 1, 2, 3, 5, 5, 5, 5, 25 ];\nconst costTime = [ 1, 1, 1, 1, 1, 1, 4, 7 ];\n\nvar Semaphore = require(&#39;semaphore&#39;);\nvar waitingQue = new Semaphore(1);\nvar waitingCount = 0;\nvar barber = new Semaphore(barbers);\n\nvar beginTime = Date.now();\n\nvar clock = function() {\n    return Date.now() - beginTime;\n};\n\nvar customerCome = function(timeConsume, callback) {\n    if (waitingCount &gt;= chairs) {\n        return callback(0, clock());\n    }\n    &#43;&#43; waitingCount;\n    callback(-1, clock());\n    waitingQue.take(function() {\n        barber.take(function() {\n            waitingQue.leave();\n            callback(1, clock());\n            -- waitingCount;\n            setTimeout(function() {\n                barber.leave();\n                callback(2, clock());\n            }, timeConsume);\n        });\n    });\n};\n\n(function() {\n    var customers = {};\n    var actmap = {\n        &#39;-2&#39;: &#39; &#39;,\n        &#39;-1&#39;: &#39;.&#39;,\n        &#39;0&#39;: &#39; &#39;,\n        &#39;1&#39;: &#39;|&#39;,\n        &#39;2&#39;: &#39; &#39;\n    };\n    var formated = [];\n    var endMark = new Semaphore(1);\n    var n = comeTime.length;\n    for (var i = 0; i &lt; n; &#43;&#43; i) {\n        customers[i] = -2;\n        endMark.take(function() {});\n        (function(i) {\n            setTimeout(function() {\n                customerCome(costTime[i], function(stat, time) {\n                    customers[i] = stat;\n                    var line = [];\n                    for (var j = 0; j &lt; n; &#43;&#43; j) {\n                        line.push(actmap[customers[j]]);\n                    }\n                    var action = &#39;unknown&#39;;\n                    if (stat === -1) {\n                        action = &#39;starts waiting&#39;;\n                    } else if (stat === 0) {\n                        action = &#39;left with anger&#39;;\n                        line[i] = &#39;g&#39;;\n                    } else if (stat === 1) {\n                        action = &#39;starts being served&#39;;\n                        line[i] = &#39;v&#39;;\n                    } else if (stat === 2) {\n                        action = &#39;finishes his barber&#39;;\n                        line[i] = &#39;^&#39;;\n                    }\n                    console.log(&#39;Customer &#39; &#43; i &#43; &#39; &#39; &#43; action &#43; &#39; at &#39; &#43; time);\n                    formated.push(line.join(&#39; &#39;));\n                    if (stat === 0 || stat === 2) {\n                        endMark.leave();\n                    }\n                });\n            }, comeTime[i]);\n        })(i);\n    }\n    endMark.take(function() {\n        console.log(formated.join(&#39;\\n&#39;));\n    });\n})();</pre>\n<p></p>\n<p>这里可以在程序开头位置自定义测试用例. 经过各种例子的测试感觉没有问题.</p>\n<p></p>\n<p>其中我用了一个初值为 1 的信号量 waitingQueue. 它的第一个可以称作 &#34;活跃顾客&#34;, 这个人会作为唯一一个正在等理发师的顾客. 而另外几个人会乖乖坐在椅子上.</p>\n<p></p>\n<p>然后我发现没有必要为 &#34;椅子&#34; (即等待队列) 单独开一个信号量. 因为 &#34;理发师&#34; 这个信号量自带了一个队列, 如果不用或者像上面一样只放一个元素, 那就浪费了. 所以直接将 &#34;理发师&#34; 这个信号量的等待队列视作 5 把椅子, 只保留 waitingCount 就可以了.</p>\n<p></p>\n<p>新的 customerCome 代码如下.</p>\n<p></p>\n<pre>var customerCome = function(timeConsume, callback) {\n    if (waitingCount &gt;= chairs) {\n        return callback(0, clock());\n    }\n    &#43;&#43; waitingCount;\n    callback(-1, clock());\n    barber.take(function() {\n        callback(1, clock());\n        -- waitingCount;\n        setTimeout(function() {\n            barber.leave();\n            callback(2, clock());\n        }, timeConsume);\n    });\n};</pre>\n<p></p>\n<p>可能这样的逻辑没有使用两个信号量清楚, 但是实现的功能是完全一样的. 更进一步, 我认为原题作者就是想让我们用 &#34;理发师&#34; 和 &#34;椅子&#34; 来更加充分地理解信号量调度同步互斥进程的过程.</p>"}, {"folders": [], "updated": "2017-06-01T16:18:33Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2017-06-01T16:18:33Z", "type": "followup", "no_answer": 1, "id": "j3emkt14u42eb", "anon": "no", "bucket_name": "Week 5/28 - 6/3", "config": {}, "bucket_order": 8, "data": null, "children": [{"folders": [], "updated": "2017-06-22T16:05:53Z", "uid": "i0fcjeg6hm4qw", "created": "2017-06-22T16:05:53Z", "type": "feedback", "d-bucket": "Yesterday", "id": "j48mdecb9hs4jh", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>在向老师的理发师问题解答的基础上&#xff0c;编写了更多的测试样例。</p>\n<p><a href=\"https://github.com/Huangjinfan/os_ucore/blob/master/barber\" target=\"_blank\">https://github.com/Huangjinfan/os_ucore/blob/master/barber</a></p>"}, {"folders": [], "updated": "2017-06-23T02:40:52Z", "uid": "hdjonbiyfs62ie", "created": "2017-06-23T02:40:52Z", "type": "feedback", "id": "j499208wa0v4cl", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p></p><p><b>在 2017年6月23日&#xff0c;上午10:39&#xff0c;xyong &lt;xyong&#64;mail.tsinghua.edu.cn&gt; 写道&#xff1a;</b></p>\n<p><b>你还需要补充如下内容&#xff1a;</b></p>\n<p><b></b></p>\n<p><b>1&#xff09;这些测试用例分别测试什么情况&#xff1f;</b></p>\n<p><b>2&#xff09;每个测试用例的运行结果如何解释&#xff1f;</b></p>\n<p><b></b></p>\n<p><b>--向勇</b></p>"}], "subject": "<p>理发店理有m位理发师、m把理发椅和n把供等候理发的顾客坐的椅子。理发师为一位顾客理完发后&#xff0c;查看是否有顾客等待&#xff0c;如有则唤醒一位为其理发&#xff1b;如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个新顾客到来时&#xff0c;首先查看理发师在干什么&#xff0c;如果理发师在理发椅上睡觉&#xff0c;他必须叫醒理发师&#xff0c;然后理发师理发&#xff0c;顾客被理发&#xff1b;如果理发师正在理发&#xff0c;则新顾客会在有空椅子可坐时坐下来等待&#xff0c;否则就会离开。请用信号量机制实现理发师问题的正确且高效的同步与互斥活动&#xff1a;请说明所定义的信号量的含义和初始值&#xff0c;描述需要进行互斥处理的各种行为&#xff0c;描述需要进行同步处理的各种行为&#xff1b;要求用类C语言的伪代码实现&#xff0c;并给出必要的简明代码注释。</p>\n<p></p>\n<p>上面是期末考试的一个题目&#xff0c;今天有同学在查阅答卷时描述一些独特的解法。在此给出一种参考回答&#xff0c;希望有兴趣的同学回复你的独特解法。</p>\n<p></p>\n<pre>// Make command: g&#43;&#43; barber.cpp -o barber -pthread\n// Ref: https://piazza.com/class/i5j09fnsl7k5x0?cid=391\n//      http://suanfazu.com/t/sleeping-barber-algorithm-with-multiple-barbers/14580/2\n// Question: Sleeping barber algorithm with multiple barbers\n\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;dispatch/dispatch.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nstruct arg_struct{\n  arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n  arg_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n  int id;\n  int start;\n  int work;\n  string indent;  \n};\n\n#define WORK_SPAN 4\nint a_task_done = -1;\nint b_task_done = -1; \n\n// Synchronization Problem Parameters:\n#define MAX_CHAIRS 2        //No. of chairs in waiting room\n#define CUT_TIME 1           //Hair Cutting Time 1 second\n#define NUM_BARB 2           //No. of barbers\n#define MAX_CUST 10          //Maximum no. of customers for simulation\n\ndispatch_semaphore_t customers;                 //Semaphore\ndispatch_semaphore_t barbers;                   //Semaphore\ndispatch_semaphore_t mutex;                     //Semaphore for providing mutially exclusive access\nint numberOfFreeSeats = MAX_CHAIRS;   //Counter for Vacant seats in waiting room\nint seatPocket[MAX_CHAIRS];           //To exchange pid between customer and barber\nint sitHereNext = 0;                  //Index for next legitimate seat\nint serveMeNext = 0;                  //Index to choose a candidate for cutting hair\nint customer_count = 0;                 //Counter of No. of customers\n\n// Synchronization user thread: UserA--Barber\nvoid* UserA(void* argv){\n  arg_struct arg = *(arg_struct*)argv;\n  int id = arg.id;\n  const char* indent = arg.indent.c_str();\n\n  sleep(arg.start);\n\n  printf(&#34;%sARRIVAL\\n&#34;, indent);\n\n  int index = strlen(indent);\n  int myNext, C;\n\n  while(1)      /*Infinite loop*/ \n  { \n      printf(&#34;%sBarber-%d Gone To Sleep.\\n&#34;, indent, index);\n      dispatch_semaphore_wait(barbers, DISPATCH_TIME_FOREVER);  //Join queue of sleeping barbers\n      dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);  //Lock mutex to protect seat changes\n        serveMeNext = (&#43;&#43;serveMeNext) % MAX_CHAIRS;  //Select next customer\n        myNext = serveMeNext;\n        C = seatPocket[myNext];                  //Get selected customer&#39;s PID\n        seatPocket[myNext] = index;     //Leave own PID for customer\n      dispatch_semaphore_signal(mutex);\n      dispatch_semaphore_signal(customers); //Call selected customer\n                /*Barber is cutting hair of customer &#39;C&#39;*/\n      printf(&#34;%sBarber-%d Wakes Up &amp; Is Cutting Hair Of Customer-%d.\\n&#34;, indent, index,C-1);\n      sleep(arg.work);\n      printf(&#34;%sBarber-%d Finishes.\\n&#34;, indent, index);\n  }\n\n  a_task_done&#43;&#43;;\n  printf(&#34;%sDONE\\n&#34;, indent);\n  \n  return NULL;\n}\n\n// Synchronization user thread: UserB--Customer\nvoid* UserB(void* argv){\n  arg_struct arg = *(arg_struct*)argv;\n  int id = arg.id;\n  const char* indent = arg.indent.c_str();\n\n  sleep(arg.start);\n\n  printf(&#34;%sARRIVAL\\n&#34;, indent);\n\n  int mySeat, B;\n    dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);  //Lock mutex to protect seat changes\n    customer_count&#43;&#43;;           //Arrival of customer\n    int index = strlen(indent);\n    printf(&#34;%sCustomer-%d[Id:%d] Entered Shop.\\n&#34;, indent, customer_count,index);\n    if(numberOfFreeSeats &gt; 0) \n    {\n      --numberOfFreeSeats;           //Sit on chairs on waiting room\n      printf(&#34;%sCustomer-%d Sits In Waiting Room.\\n&#34;, indent, customer_count);\n      sitHereNext = (&#43;&#43;sitHereNext) % MAX_CHAIRS;  //Choose a vacant chair to sit\n      mySeat = sitHereNext;\n      seatPocket[mySeat] = customer_count;\n      dispatch_semaphore_signal(mutex); //Release the seat change mutex\n      dispatch_semaphore_signal(barbers); //Wake up one barber\n      dispatch_semaphore_wait(customers, DISPATCH_TIME_FOREVER);  //Join queue of sleeping customers\n      dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);  //Lock mutex to protect seat changes\n        B = seatPocket[mySeat];    //Barber replaces customer PID with his own PID\n        numberOfFreeSeats&#43;&#43;;             //Stand Up and Go to Barber Room\n      dispatch_semaphore_signal(mutex); //Release the seat change mutex\n      /*Customer is having hair cut by barber &#39;B&#39;*/\n      printf(&#34;%sSTART\\n&#34;, indent);\n      sleep(arg.work);\n    } \n    else \n  {\n       dispatch_semaphore_signal(mutex);  //Release the mutex and customer leaves without haircut\n       printf(&#34;%sCustomer-%d Finds No Seat &amp; Leaves.\\n&#34;, indent, customer_count);\n  }\n\n  a_task_done&#43;&#43;;\n  printf(&#34;%sDONE\\n&#34;, indent);\n\n  pthread_exit(0);\n}\n\nint main(int argc, char** argv) {\n  srand((unsigned)time(NULL));\n\n  #define N MAX_CUST\n  pthread_t p_UserB[2 * N], p_UserA[2 * N];\n\n  int a_count = 0, b_count = 0;\n\n  #define USERA 0\n  #define USERB 1\n\n  // Synchronization initialization:\n  customers = dispatch_semaphore_create(0); // init with value of 0\n  barbers = dispatch_semaphore_create(0); // init with value of 0\n  mutex = dispatch_semaphore_create(1); // init with value of 1\n\n  /* For managed creation of 2 * N threads */\n\n  #define TEST 1\n  int st_time = 0;\n\n  #if TEST == 1\n  #define THREADNUM 7\n  int inst[2 * N][3] = {\n    /* { UserB or UserA to be create?, \n         When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n         How long does it work after it enters critical zone? } */\n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 4, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 1, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 5, rand()%WORK_SPAN},\n    {USERB, st_time &#43;= 1, rand()%WORK_SPAN}\n  };\n\n  #elif TEST == 2\n  #define THREADNUM 6\n  int inst[2 * N][3] = {\n    /* { UserB or UserA to be create?, \n         When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n         How long does it work after it enters critical zone? } */\n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 4, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 1, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}\n  };\n  #else\n  #define THREADNUM 6\n  int inst[2 * N][3] = {\n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 1, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 4, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}\n  };\n  #endif\n\n  /* Print the first line */\n  int tmp_a = 0, tmp_b = 0;\n  for (int i = 0; i &lt; THREADNUM; i&#43;&#43;){\n    if (inst[i][0] == USERA){\n      printf(&#34;A%d\\t&#34;, tmp_a&#43;&#43;);\n    } else if (inst[i][0] == USERB){\n      printf(&#34;B%d\\t&#34;, tmp_b&#43;&#43;);\n    }\n  }\n  printf(&#34;\\n&#34;);\n  printf(&#34;tmp_b:%d\\n&#34;,tmp_b);\n\n  /* Create UserAs and UserBs according to $inst*/\n  int rc;\n  string indent(&#34;&#34;);\n  for (int i = 0; i &lt; THREADNUM; i&#43;&#43;){\n    if (inst[i][0] == USERA){\n      rc = pthread_create(p_UserA &#43; a_count, NULL, UserA, new arg_struct(a_count, inst[i][1], inst[i][2], indent));\n      if (rc) printf(&#34;ERROR\\n&#34;);\n      a_count&#43;&#43;;\n    } else if (inst[i][0] == USERB){\n      rc = pthread_create(p_UserB &#43; b_count, NULL, UserB, new arg_struct(b_count, inst[i][1], inst[i][2], indent));\n      if (rc) printf(&#34;ERROR\\n&#34;);\n      b_count&#43;&#43;;\n    }\n    indent &#43;= &#39;\\t&#39;;\n  }\n\n  /* wait until every thread finishes*/\n  for (int i = 0; i &lt; a_count; i&#43;&#43;){\n    pthread_join(p_UserA[i], NULL);\n  }\n  for (int i = 0; i &lt; b_count; i&#43;&#43;){\n    pthread_join(p_UserB[i], NULL);  \n  }\n\n  dispatch_release(mutex);\n\n  return 0;\n}</pre>\n<p></p>"}], "nr": 1069, "bucket_order": 2, "type": "note", "folders": ["lecture18"], "no_answer_followup": 1, "num_favorites": 1, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-05-06T14:47:56Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1498199028835, "tag_good": [{"name": "Yong XIANG", "admin": true, "photo": null, "us": false, "id": "hdjonbiyfs62ie", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "email": "xyong@tsinghua.edu.cn", "admin_permission": 10}], "tag_good_arr": ["hdjonbiyfs62ie"], "history": [{"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒&#xff0c;测试用例已完善。</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 15<br />typedef struct{<br />int num;<br />int time;<br />}arg;<br />int b[]={1,10,3,9,4,8,5,6,7,6,4,6,7,8};<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />sem_t mutex;<br />int current=-1;<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;mutex);<br />\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t\tprintf(&#34;%d over\\n&#34;,current);<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tif(arg[0]%3==0)sleep(0);<br />\telse if(arg[0]%3==1)sleep(10);<br />\telse sleep(arg[1]);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;waiting\\n&#34;,arg[0]);<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备<br />\t\tcurrent=arg[0];<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;served\\n&#34;,arg[0]);<br />\t\tsem_post(&amp;mutex);<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\tsem_init(&amp;mutex,0,0);<br />\tprintf(&#34;barber\\t&#34;);<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);<br />\tprintf(&#34;\\n&#34;);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\targ*a=malloc(N*sizeof(arg));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;){<br />\t\ta[i].num=i;<br />\t\ta[i].time=b[i];<br />\t}<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(a[i]));<br />\tsleep(36);<br />\treturn 0;<br />}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t<br />\tcome<br />\twaiting<br />\t\t\t\tcome<br />\t\t\t\twaiting<br />\tserved<br />barber is serving 0<br />\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\tcome<br />\t\t\twaiting<br />0 over<br />\t\t\t\tserved<br />barber is serving 3<br />\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />3 over<br />\t\t\t\t\t\t\tserved<br />barber is serving 6<br />\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\tcome<br />\t\t\t\t\t\tleave<br />6 over<br />\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 9<br />\t\t\t\t\tcome<br />\t\t\t\t\twaiting<br />\t\tcome<br />\t\tleave<br />\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />9 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 12<br />12 over<br />\t\t\tserved<br />barber is serving 2<br />2 over<br />\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 11<br />11 over<br />\t\t\t\t\t\t\t\t\tserved<br />barber is serving 8<br />8 over<br />\t\t\t\t\tserved<br />barber is serving 4<br />4 over</pre>", "anon": "no", "created": "2017-05-12T05:49:21Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}, {"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒。&#xff08;测试用例待完善&#xff0c;目前测试是有5名顾客在第0秒到来&#xff0c;5名顾客在第10秒到来&#xff0c;其他顾客随机到来&#xff09;</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 15<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />sem_t mutex;<br />int current=-1;<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;mutex);<br />\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t\tprintf(&#34;%d over\\n&#34;,current);<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tif(arg[0]%3==0)sleep(0);<br />\telse if(arg[0]%3==1)sleep(10);<br />\telse sleep(rand()%N);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;waiting\\n&#34;,arg[0]);<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备<br />\t\tcurrent=arg[0];<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;served\\n&#34;,arg[0]);<br />\t\tsem_post(&amp;mutex);<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\tsem_init(&amp;mutex,0,0);<br />\tprintf(&#34;barber\\t&#34;);<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);<br />\tprintf(&#34;\\n&#34;);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\tint*num=malloc(N*sizeof(int));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));<br />\tsleep(36);<br />\treturn 0;<br />}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t<br />\tcome<br />\twaiting<br />\t\t\t\tcome<br />\t\t\t\twaiting<br />\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />\tserved<br />barber is serving 0<br />\t\t\t\t\t\tcome<br />\t\t\t\t\t\twaiting<br />0 over<br />\t\t\t\tserved<br />barber is serving 3<br />3 over<br />\t\t\t\t\t\t\tserved<br />barber is serving 6<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />6 over<br />\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 9<br />\t\tcome<br />\t\twaiting<br />\t\t\t\t\tcome<br />\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\tleave<br />9 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 12<br />\t\t\tcome<br />\t\t\twaiting<br />12 over<br />\t\t\t\t\t\tserved<br />barber is serving 5<br />5 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 14<br />14 over<br />\t\tserved<br />barber is serving 1<br />1 over<br />\t\t\t\t\tserved<br />barber is serving 4<br />4 over<br />\t\t\tserved<br />barber is serving 2<br />2 over</pre>", "anon": "no", "created": "2017-05-07T06:12:55Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}, {"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>Linux解法&#xff0c;设置顾客100名&#xff0c;在100秒内分散来到&#xff0c;理发时间3秒。</p>\n<pre>#include &lt;pthread.h&gt; \n#include &lt;stdio.h&gt; \n#include &lt;unistd.h&gt; \n#include &lt;stdlib.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;assert.h&gt;\n#define N 100\n//链表操作\ntypedef struct n{\n\tstruct n*next;\n\tstruct n*prev;\n\tint i;\n}node;\nnode*header,*trailer;\nint dequeue(){\n\tnode*d=header-&gt;next;\n\tassert(d!=trailer);\n\td-&gt;prev-&gt;next=d-&gt;next;\n\td-&gt;next-&gt;prev=d-&gt;prev;\n\tint result=d-&gt;i;\n\tfree(d);\n\treturn result;\n}\nvoid enqueue(int result){\n\tnode*d=malloc(sizeof(node));\n\td-&gt;i=result;\n\td-&gt;next=trailer;\n\td-&gt;prev=trailer-&gt;prev;\n\ttrailer-&gt;prev=d;\n\td-&gt;prev-&gt;next=d;\n}\n//输出链表信息\nvoid printwaiting(){\n\tprintf(&#34;waiting: &#34;);\n\tfor(node*n=header-&gt;next;n!=trailer;n=n-&gt;next)printf(&#34;%d\\t&#34;,n-&gt;i);\n\tprintf(&#34;\\n&#34;);\n}\n//信号量和控制量定义\nsem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务\nsem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请\nsem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客\nint numofseats=5;//共5个空位\n//理发师线程\nvoid*barber(){\n\twhile(1){\n\t\tsem_wait(&amp;custready);//等待顾客到来\n\t\tsem_wait(&amp;accessseats);//进入临界区\n\t\tnumofseats&#43;=1;//座位增加\n\t\tsem_post(&amp;barbeready);//理发师做好准备\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tprintwaiting();\n\t\tprintf(&#34;%d is served\\n&#34;,dequeue());//队首接受服务\n\t\tsleep(3);//3秒钟理发时间\n\t}\n\treturn NULL;\n}\nvoid*customer(void*args){\n\tint*arg=(int*)args;\n\tsleep(rand()%N);\n\tsem_wait(&amp;accessseats);//进入临界区\n\tprintf(&#34;%d comes\\n&#34;,arg[0]);//宣告到来\n\tif(numofseats&gt;0){//判断是否有空位\n\t\tnumofseats-=1;\n\t\tenqueue(arg[0]);//自己入队\n\t\tsem_post(&amp;custready);//宣告顾客到来\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tsem_wait(&amp;barbeready);//等待理发师准备;不可以和上一句颠倒&#xff0c;否则理发师进程虽然可以得到barbeready信号量做好准备&#xff0c;但不能进入临界区&#xff0c;造成死锁。\n\t}\n\telse{\n\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区\n\t\tprintf(&#34;%d leave\\n&#34;,arg[0]);\n\t}\n\treturn NULL;\n}\nint main(){\n\t//以下对链表进行初始化\n\theader=malloc(sizeof(node));\n\ttrailer=malloc(sizeof(node));\n\theader-&gt;prev=trailer-&gt;next=NULL;\n\theader-&gt;i=trailer-&gt;i=-1;\n\theader-&gt;next=trailer;\n\ttrailer-&gt;prev=header;\n\t//以下对信号量进行初始化\n\tsem_init(&amp;barbeready,0,0);\n\tsem_init(&amp;accessseats,0,1);\n\tsem_init(&amp;custready,0,0);\n\t//创建1个理发师和N个顾客线程\n\tpthread_t*barberid=malloc(sizeof(pthread_t));\n\tpthread_create(barberid,NULL,barber,NULL);\n\tint*num=malloc(N*sizeof(int));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;\n\tpthread_t*customerid=malloc(N*sizeof(pthread_t));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));\n\tsleep(110);\n\treturn 0;\n}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>31 comes\nwaiting: 31\t\n31 is served\n86 comes\nwaiting: 86\t\n86 is served\n60 comes\n65 comes\nwaiting: 60\t65\t\n60 is served\n81 comes\n20 comes\n38 comes\nwaiting: 65\t81\t20\t38\t\n65 is served\n95 comes\n50 comes\n68 comes\n68 leave\nwaiting: 81\t20\t38\t95\t50\t\n81 is served\n74 comes\n4 comes\n4 leave\n48 comes\n48 leave\nwaiting: 20\t38\t95\t50\t74\t\n20 is served\n43 comes\nwaiting: 38\t95\t50\t74\t43\t\n38 is served\n9 comes\n42 comes\n42 leave\n32 comes\n32 leave\n27 comes\n27 leave\nwaiting: 95\t50\t74\t43\t9\t\n95 is served\n47 comes\n70 comes\n70 leave\n61 comes\n61 leave\n15 comes\n15 leave\n17 comes\n17 leave\n51 comes\n51 leave\nwaiting: 50\t74\t43\t9\t47\t\n50 is served\n96 comes\n11 comes\n11 leave\n63 comes\n63 leave\n23 comes\n23 leave\n30 comes\n30 leave\n40 comes\n40 leave\n67 comes\n67 leave\nwaiting: 74\t43\t9\t47\t96\t\n74 is served\n25 comes\n90 comes\n90 leave\nwaiting: 43\t9\t47\t96\t25\t\n43 is served\n76 comes</pre>\n<p></p>", "anon": "no", "created": "2017-05-06T14:49:10Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}, {"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>Linux解法&#xff1a;</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 100<br />//链表操作<br />typedef struct n{<br />\tstruct n*next;<br />\tstruct n*prev;<br />\tint i;<br />}node;<br />node*header,*trailer;<br />int dequeue(){<br />\tnode*d=header-&gt;next;<br />\tassert(d!=trailer);<br />\td-&gt;prev-&gt;next=d-&gt;next;<br />\td-&gt;next-&gt;prev=d-&gt;prev;<br />\tint result=d-&gt;i;<br />\tfree(d);<br />\treturn result;<br />}<br />void enqueue(int result){<br />\tnode*d=malloc(sizeof(node));<br />\td-&gt;i=result;<br />\td-&gt;next=trailer;<br />\td-&gt;prev=trailer-&gt;prev;<br />\ttrailer-&gt;prev=d;<br />\td-&gt;prev-&gt;next=d;<br />}<br />//输出链表信息<br />void printwaiting(){<br />\tprintf(&#34;waiting: &#34;);<br />\tfor(node*n=header-&gt;next;n!=trailer;n=n-&gt;next)printf(&#34;%d\\t&#34;,n-&gt;i);<br />\tprintf(&#34;\\n&#34;);<br />}<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tprintwaiting();<br />\t\tprintf(&#34;%d is served\\n&#34;,dequeue());//队首接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tsleep(rand()%N);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tprintf(&#34;%d comes\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tenqueue(arg[0]);//自己入队<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备;不可以和上一句颠倒&#xff0c;否则理发师进程虽然可以得到barbeready信号量做好准备&#xff0c;但不能进入临界区&#xff0c;造成死锁。<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tprintf(&#34;%d leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对链表进行初始化<br />\theader=malloc(sizeof(node));<br />\ttrailer=malloc(sizeof(node));<br />\theader-&gt;prev=trailer-&gt;next=NULL;<br />\theader-&gt;i=trailer-&gt;i=-1;<br />\theader-&gt;next=trailer;<br />\ttrailer-&gt;prev=header;<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\tint*num=malloc(N*sizeof(int));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));<br />\tsleep(110);<br />\treturn 0;<br />}<br /></pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>31 comes<br />waiting: 31\t<br />31 is served<br />86 comes<br />waiting: 86\t<br />86 is served<br />60 comes<br />65 comes<br />waiting: 60\t65\t<br />60 is served<br />81 comes<br />20 comes<br />38 comes<br />waiting: 65\t81\t20\t38\t<br />65 is served<br />95 comes<br />50 comes<br />68 comes<br />68 leave<br />waiting: 81\t20\t38\t95\t50\t<br />81 is served<br />74 comes<br />4 comes<br />4 leave<br />48 comes<br />48 leave<br />waiting: 20\t38\t95\t50\t74\t<br />20 is served<br />43 comes<br />waiting: 38\t95\t50\t74\t43\t<br />38 is served<br />9 comes<br />42 comes<br />42 leave<br />32 comes<br />32 leave<br />27 comes<br />27 leave<br />waiting: 95\t50\t74\t43\t9\t<br />95 is served<br />47 comes<br />70 comes<br />70 leave<br />61 comes<br />61 leave<br />15 comes<br />15 leave<br />17 comes<br />17 leave<br />51 comes<br />51 leave<br />waiting: 50\t74\t43\t9\t47\t<br />50 is served<br />96 comes<br />11 comes<br />11 leave<br />63 comes<br />63 leave<br />23 comes<br />23 leave<br />30 comes<br />30 leave<br />40 comes<br />40 leave<br />67 comes<br />67 leave<br />waiting: 74\t43\t9\t47\t96\t<br />74 is served<br />25 comes<br />90 comes<br />90 leave<br />waiting: 43\t9\t47\t96\t25\t<br />43 is served<br />76 comes</pre>\n<p></p>", "anon": "no", "created": "2017-05-06T14:47:56Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}]}, "error": null}