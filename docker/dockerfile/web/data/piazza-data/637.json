{"aid": "iln9qxtmi5x13q", "result": {"folders": ["lab5", "练习纠错"], "unique_views": 72, "request_instructor_me": false, "change_log": [{"data": "il7yc3u3vd2es", "anon": "full", "when": "2016-02-29T12:18:37Z", "type": "create"}, {"data": "il7yes11qpi1wl", "anon": "full", "when": "2016-02-29T12:20:42Z", "type": "update"}, {"data": "il8qx8x8tkk5ec", "anon": "full", "when": "2016-03-01T01:38:53Z", "type": "update"}, {"uid": "i6uqzf449em3ex", "data": "il9krf2h6ri5xg", "when": "2016-03-01T15:34:09Z", "to": "il7yc3u0147er", "anon": "no", "type": "s_answer"}, {"to": "il7yc3u0147er", "anon": "full", "when": "2016-03-02T11:12:08Z", "type": "followup"}, {"to": "il7yc3u0147er", "anon": "full", "when": "2016-03-02T11:14:56Z", "type": "feedback"}, {"to": "il7yc3u0147er", "anon": "no", "when": "2016-03-02T12:47:14Z", "uid": "i6uqzf449em3ex", "type": "feedback"}], "upvote_ids": [], "id": "il7yc3u0147er", "bookmarked": 4, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-01T15:34:09Z", "config": {}, "tag_endorse_arr": ["ie7xy4gmt1p1pp"], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [{"name": "Alex Wang", "admin": false, "photo": null, "us": false, "email": "wac14@mails.tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "id": "ie7xy4gmt1p1pp"}], "bucket_order": 2, "data": {"embed_links": []}, "id": "il9krf2ekh85xe", "history": [{"content": "<p>1. 我测了下spin中的子进程和父进程之间可以调度&#xff0c;具体代码见已有的以下代码的224和279-286行</p>\n<p><a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes/lab5/kern/trap/trap.c\">https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes/lab5/kern/trap/trap.c</a></p>\n<p></p>\n<p>应该是需要实现的&#xff08;既然有&#34;LAB5 YOUR CODE&#34;的话&#xff09;。具体流程就是每过一定时钟周期need_resched就会设成1.</p>\n<p></p>\n<p>2. 想自动加载symbol可能没什么好办法。。。</p>", "anon": "no", "subject": "", "uid": "i6uqzf449em3ex", "created": "2016-03-01T15:34:09Z"}]}, {"folders": [], "updated": "2016-03-02T11:12:08Z", "no_upvotes": 0, "created": "2016-03-02T11:12:08Z", "type": "followup", "d-bucket": "Yesterday", "id": "ilaquasljbi35j", "anon": "full", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-02T11:14:56Z", "created": "2016-03-02T11:14:56Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilaqxws28iy3wy", "anon": "full", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>自动加载符号我的想法是能不能写编译脚本把不同的用户级程序加载到不同的虚拟地址, 这样就不会冲突了? 但是编译脚本不太了解, 不知道怎么弄.</p>"}, {"folders": [], "updated": "2016-03-02T12:47:14Z", "uid": "i6uqzf449em3ex", "created": "2016-03-02T12:47:14Z", "type": "feedback", "id": "ilau8lxqjpq51l", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>根据makefile中的 $(V)$(LD) $(LDFLAGS) -T tools/user.ld -o $$&#64; $$(UOBJS) $(1)</p>\n<p>链接用户程序时使用了链接脚本tools/user.ld&#xff0c;理论上你如果每个用户程序使用不同的链接脚本可以使它加载到不同地址</p>"}], "subject": "<p>原来如此.... 我合并的时候不小心把YOUR CODE那部分合并没了......</p>"}], "no_answer_followup": 0, "nr": 637, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lab5", "student", "练习纠错"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-02-29T12:18:37Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457674478266, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>grade脚本中有一个执行spin这个用户程序的测试, 该程序会fork一个子进程, 子进程死循环. 父进程yield 三次, 但是lab5还没有时钟中断切换进程的功能, 所以如果子进程不主动放弃cpu父进程不会继续执行. 请问lab5要求实现这种抢占式的进程切换吗?</p>\n<p>还有, lab5以后用户进程都是被加载到0x800020的, 进程的切换导致gdb源码调试很麻烦, 如果只调试可以用add-symbol-file把该进程的目标文件加载到0x800020处, 但是如果一个进程执行了exec加载了其他进程, 请问有什么方便的源码级调试的方法吗?</p>", "anon": "full", "subject": "lab5没有要求实现进程调度但是make grade中检测了", "created": "2016-03-01T01:38:53Z"}, {"content": "<p>grade脚本中有一个执行spin这个用户程序的测试, 该程序会fork一个子进程, 子进程死循环. 父进程yield 三次, 但是lab5还没有时钟中断切换进程的功能, 所以如果子进程不主动放弃cpu父进程不会继续执行. 请问lab5要求实现这种抢占式的进程切换吗?</p>\n<p>还有, lab5以后用户进程都是被加载到0x800020的, 进程的切换导致gdb源码调试很麻烦, 如果只调试可以用add-symbol-file把该进程的目标文件加载到0x800020处, 但是如果一个进程执行了exec加载了其他进程, 请问有什么方便的源码级调试的方法吗?</p>", "anon": "full", "subject": "lab5没有要求实现进程调度但是make grade中检测了", "created": "2016-02-29T12:20:42Z"}, {"content": "<p>grade脚本中有一个执行spin这个用户程序的测试, 该程序会fork一个子进程, 子进程死循环. 父进程yield 三次, 但是lab5还没有时钟中断切换进程的功能, 所以如果子进程不主动放弃cpu父进程不会继续执行. 请问lab5要求实现这种抢占式的进程切换吗?</p>", "anon": "full", "subject": "lab5没有要求实现进程调度但是make grade中检测了", "created": "2016-02-29T12:18:37Z"}]}, "error": null}