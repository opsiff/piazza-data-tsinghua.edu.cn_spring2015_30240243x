{"aid": "iln9qj8mdh17kb", "result": {"folders": ["lab5"], "unique_views": 75, "request_instructor_me": false, "change_log": [{"data": "il5z159pc3q52g", "anon": "no", "when": "2016-02-28T03:02:33Z", "uid": "ijf9jcjt7oslj", "type": "create"}, {"data": "il5z2cgdqat2x4", "anon": "no", "when": "2016-02-28T03:03:29Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il5zqmhjj7h3i8", "anon": "no", "when": "2016-02-28T03:22:22Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il5ztwmyqh73ev", "anon": "no", "when": "2016-02-28T03:24:55Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il60z71crjg1cw", "anon": "no", "when": "2016-02-28T03:57:01Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il612prlls43g5", "anon": "no", "when": "2016-02-28T03:59:46Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il61da6b6bymb", "anon": "no", "when": "2016-02-28T04:07:59Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il62e46briu6i3", "anon": "no", "when": "2016-02-28T04:36:37Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il62emmhuf37ly", "anon": "no", "when": "2016-02-28T04:37:01Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il62lcqpr20451", "anon": "no", "when": "2016-02-28T04:42:15Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il62onx7jvq17e", "anon": "no", "when": "2016-02-28T04:44:49Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il62ykmspd22tt", "anon": "no", "when": "2016-02-28T04:52:32Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"uid": "ijf9jcjt7oslj", "data": "il62zi9p8163en", "when": "2016-02-28T04:53:15Z", "to": "il5z159lcdp52f", "anon": "no", "type": "s_answer"}, {"data": "il630qevkit26i", "anon": "no", "when": "2016-02-28T04:54:12Z", "uid": "ijf9jcjt7oslj", "type": "s_answer_update"}, {"data": "il633zg1n3z36y", "anon": "no", "when": "2016-02-28T04:56:44Z", "uid": "ijf9jcjt7oslj", "type": "s_answer_update"}, {"data": "il65j53gt5y47n", "anon": "no", "when": "2016-02-28T06:04:30Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il68is4v316qf", "anon": "no", "when": "2016-02-28T07:28:13Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il68q8pr1ty3js", "anon": "no", "when": "2016-02-28T07:34:01Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il6idi68go353s", "anon": "no", "when": "2016-02-28T12:04:03Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il6ip6xqa957go", "anon": "no", "when": "2016-02-28T12:13:08Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il6j2kypn1j29k", "anon": "no", "when": "2016-02-28T12:23:33Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il6j9ejc9ap3b2", "anon": "no", "when": "2016-02-28T12:28:51Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il6p5dwa2p2ab", "anon": "no", "when": "2016-02-28T15:13:41Z", "uid": "ijf9jcjt7oslj", "type": "update"}, {"data": "il6p5vbxjgl273", "anon": "no", "when": "2016-02-28T15:14:04Z", "uid": "ijf9jcjt7oslj", "type": "s_answer_update"}, {"data": "il6p9cbvap218z", "anon": "no", "when": "2016-02-28T15:16:46Z", "uid": "ijf9jcjt7oslj", "type": "s_answer_update"}, {"uid": "i76z9sx78G8", "data": "il6pddb3dnt5pp", "when": "2016-02-28T15:19:54Z", "to": "il5z159lcdp52f", "anon": "no", "type": "i_answer"}, {"data": "il6pezxmtgj30l", "anon": "no", "when": "2016-02-28T15:21:09Z", "uid": "i76z9sx78G8", "type": "i_answer_update"}, {"to": "il5z159lcdp52f", "anon": "no", "when": "2016-02-28T15:29:42Z", "uid": "ijf9jcjt7oslj", "type": "followup"}, {"to": "il5z159lcdp52f", "anon": "no", "when": "2016-02-28T16:58:17Z", "uid": "i76z9sx78G8", "type": "feedback"}, {"to": "il5z159lcdp52f", "anon": "no", "when": "2016-02-29T03:13:28Z", "uid": "i0f9pvv0uxm6ko", "type": "feedback"}], "upvote_ids": [], "id": "il5z159lcdp52f", "bookmarked": 5, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-02-28T04:53:15Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "il62zi9lmkr3em", "history": [{"content": "<p>等老师解答</p>", "anon": "no", "subject": "", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T15:16:46Z"}, {"content": "<p></p>", "anon": "no", "subject": "", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T15:14:04Z"}, {"content": "<p>在线等</p>", "anon": "no", "subject": "", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:56:44Z"}, {"content": "<p></p>", "anon": "no", "subject": "", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:54:12Z"}, {"content": "<p>麻烦老师回答一下&#xff0c;在线等&#xff0c;想不通</p>\n<p></p>", "anon": "no", "subject": "", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:53:15Z"}]}, {"folders": [], "is_tag_endorse": false, "created": "2016-02-28T15:19:54Z", "config": {}, "tag_endorse_arr": ["ijf9jcjt7oslj"], "children": [], "bucket_name": "Today", "type": "i_answer", "tag_endorse": [{"name": "wangpeng", "admin": false, "photo": null, "us": false, "email": "yuans07@mails.tsinghua.edu.cn", "role": "student", "facebook_id": null, "id": "ijf9jcjt7oslj"}], "bucket_order": 2, "data": {"embed_links": []}, "id": "il6pddb3ozc5po", "history": [{"content": "<p>1. Ucore  通过用户库中的umain函数然后调转到main函数执行&#xff0c; 从main返回后在umain中调用exit</p>\n<p>2. 在Ucore中调度的发生都是在内核态&#xff0c;因为调度的程序在内核中。</p>", "anon": "no", "subject": "", "uid": "i76z9sx78G8", "created": "2016-02-28T15:21:09Z"}, {"content": "<p>1. Ucore  通过用户库中的umain函数然后调转到main函数执行&#xff0c; 从main返回后在umain中有调用exit</p>\n<p>2. 在Ucore中调度的发生都是在内核态&#xff0c;因为调度的程序在内核中。</p>", "anon": "no", "subject": "", "uid": "i76z9sx78G8", "created": "2016-02-28T15:19:54Z"}]}, {"folders": [], "updated": "2016-02-28T15:29:42Z", "no_upvotes": 0, "uid": "ijf9jcjt7oslj", "created": "2016-02-28T15:29:42Z", "type": "followup", "d-bucket": "Yesterday", "id": "il6ppzpktti6di", "anon": "no", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-02-28T16:58:17Z", "uid": "i76z9sx78G8", "created": "2016-02-28T16:58:17Z", "type": "feedback", "d-bucket": "Yesterday", "id": "il6svwnh1jh49s", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>你可以看下umain的实现以及umain的caller, umain调用main是操作系统写好的&#xff0c;不需要用户程序自己来实现。也就是说&#xff0c;某些情况下&#xff0c;从用户程序的角度来看&#xff0c;main函数中return相当于调用exit。</p>"}, {"folders": [], "updated": "2016-02-29T03:13:28Z", "uid": "i0f9pvv0uxm6ko", "created": "2016-02-29T03:13:28Z", "type": "feedback", "id": "il7ev1hc816ne", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>用户态的程序的main之外还有一个壳&#xff0c;就是umain&#xff0c;这个umain是操作系统写好的&#xff0c;负责进入main&#xff0c;main的return也会返回到umain&#xff0c;之后umain会调用syscall exit。</p>"}], "subject": "<p>老师&#xff0c;是不是没个程序都要在编写的时候自己进行exit的调用&#xff1f;</p>"}], "no_answer_followup": 0, "nr": 623, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lab5", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-02-28T03:02:33Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457674459366, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕时&#xff0c;是如何把控制权交给ucore并调用exit的&#xff1f;</p>\n<p>           </p>\n<p>                  2、调度是只有在内核态才能进行么&#xff1f;比如一个用户态进程只有通过中断或者系统调用进入内核态才能再进行调度&#xff0c;</p>\n<p>     </p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T15:13:41Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕时&#xff0c;是如何把控制权交给ucore并调用exit的&#xff1f;</p>\n<p>           </p>\n<p>                  2、调度是只有在内核态才能进行么&#xff1f;比如一个用户态进程只有通过中断或者系统调用进入内核态才能再进行调度&#xff0c;</p>\n<p>     </p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T12:28:51Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕时&#xff0c;是如何把控制权交给ucore并调用exit的&#xff1f;</p>\n<p>           </p>\n<p>                  2、调度是只有在内核态才能进行么&#xff1f;比如一个用户态进程只有通过中断或者系统调用才能再进行调度&#xff0c;</p>\n<p>     </p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T12:23:33Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?   我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、调度是只有在内核态才能进行么&#xff1f;比如一个用户态进程只有通过中断或者系统调用才能再进行调度&#xff0c;</p>\n<p>     </p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T12:13:08Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有3个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?   我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、调度是只有在内核态才能进行么&#xff1f;比如一个用户态进程只有通过中断或者系统调用才能再进行调度&#xff0c;</p>\n<p>     </p>\n<p>                  3、在创建user_main进程时我们给他分配了一个栈&#xff0c;这个栈在哪里回收了&#xff1f;</p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T12:04:03Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有3个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是调度点不止一个&#xff0c;进程中可以直接进行调度的&#xff0c;比如父进程init_main是内核进程里面有调度。如果一个用户进程选中的新进程是内核进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;或者内核线程直接调度用户进程的&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p></p>\n<p>                  3、在运行switch to之前我们先lcr3(next-&gt;cr3)&#xff0c;比如我们现在从内核进程切换到用户进程&#xff0c;我们先把页目录修改成用户进程的页目录&#xff0c;那么switch to函数在movl操作时岂不是找不到prev-&gt;context 和next-&gt;context&#xff0c;这两个进程控制块都是在内核页目录上才能找到的吧&#xff1f;</p>\n<p>                        同样在load_icode中&#xff0c;我们也lcr3了用户进程的页目录表&#xff0c;这样的话返回到do_execv的时候cs&#xff1a;eip和ss:esp在新的目录表中应该找不到原来指向的地方&#xff1f;</p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T07:34:01Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有3个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是调度点不止一个&#xff0c;进程中可以直接进行调度的&#xff0c;比如父进程init_main是内核进程里面有调度。如果一个用户进程选中的新进程是内核进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;或者内核线程直接调度用户进程的&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p></p>\n<p>                  3、在运行switch to之前我们先lcr3(next-&gt;cr3)&#xff0c;比如我们现在从内核进程切换到用户进程&#xff0c;我们先把页目录修改成用户进程的页目录&#xff0c;那么switch to函数在movl操作时岂不是找不到prev-&gt;context 和next-&gt;context&#xff0c;这两个进程控制块都是在内核页目录上才能找到的吧&#xff1f;</p>\n<p>                        同样在load_icode中&#xff0c;我们也lcr3了用户进程的页目录表&#xff0c;这样的话返回之后cs&#xff1a;eip和ss:esp在新的目录表中应该找不到原来指向的地方&#xff1f;</p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T07:28:13Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有3个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是调度点不止一个&#xff0c;进程中可以直接进行调度的&#xff0c;比如父进程init_main是内核进程里面有调度。如果一个用户进程选中的新进程是内核进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;或者内核线程直接调度用户进程的&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p></p>\n<p>                  3、在运行switch to之前我们先lcr3(next-&gt;cr3)&#xff0c;比如我们现在从内核进程切换到用户进程&#xff0c;我们先把页目录修改成用户进程的页目录&#xff0c;那么switch to函数在movl操作时岂不是找不到prev-&gt;context 和next-&gt;context&#xff0c;这两个进程控制块都是在内核页目录上才能找到的吧&#xff1f;</p>\n<p>    </p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T06:04:30Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是调度点不止一个&#xff0c;进程中可以直接进行调度的&#xff0c;比如父进程init_main是内核进程里面有调度。如果一个用户进程选中的新进程是内核进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;或者内核线程直接调度用户进程的&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:52:32Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是进程中直接进行调度的&#xff0c;比如父进程init_main是内核进程里面有调度。如果一个用户进程选中的新进程是内核进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:44:49Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是父进程中直接进行调度的&#xff0c;比如父进程init_main是内核进程里面有调度。如果一个用户进程选中的新进程是内核进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:42:15Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是父进程中直接进行调度的&#xff0c;比如父进程init_main是内核进程里面又调度&#xff0c;如果选中的新进程是用户进程&#xff08;这个进程已经不是最开始创建时入口也不是fork ret&#xff09;&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:37:01Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是父进程中直接进行调度的&#xff0c;比如父进程init_main是内核进程里面又调度&#xff0c;如果选中的新进程是用户进程&#xff08;这个进程已经不是最开始创建时如何也不是fork ret&#xff09;&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:36:37Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是父进程中直接进行调度的&#xff0c;比如父进程init_main是内核进程里面又调度&#xff0c;如果选中的新进程是用户进程&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T04:07:59Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是父进程中直接进行调度的&#xff0c;比如父进程init_main是内核进程&#xff0c;子进程是用户进程&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T03:59:46Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有2个问题&#xff1a;</p>\n<p>                  1、用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>           </p>\n<p>                  2、在中断中进行调度&#xff0c;段的切换没问题&#xff0c;我的疑问是父进程中直接进行调度的&#xff0c;假如父进程是内核进程&#xff0c;子进程是用户进程&#xff0c;数据段&#xff0c;代码段等等是如何切换的&#xff0c;switch中也没有管理这些信息。</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit 以及进程调度时段的切换", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T03:57:01Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有个问题&#xff1a;</p>\n<p>                  用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行do_exit回收的</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T03:24:55Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有个问题&#xff1a;</p>\n<p>                  用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;entry中保存do_exit的eip应该是在内核栈中。</p>\n<p>                  那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行回收的</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T03:22:22Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有个问题&#xff1a;</p>\n<p>                  用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数&#xff0c;那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行回收的</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T03:03:29Z"}, {"content": "<p>老师和同学们&#xff1a;</p>\n<p>     我有个问题&#xff1a;</p>\n<p>                  用户进程执行完毕返回时&#xff0c;如何调用do_exit?在kernerl_thread_entry_entry中有call do_exit&#xff0c;但是我们创建用户之后已经应该是不会在返回到这个函数之中了&#xff0c;所以我发通过kernnel_thread_entry调用do_exit&#xff0c;那么是如何调用do_exit的&#xff1f;我也没有看到调用中断&#xff0c;所以很不理解是如何把控制权交给内核进行回收的</p>\n<p>               谢谢&#xff01;    </p>", "anon": "no", "subject": "lab5 关于用户进程exit", "uid": "ijf9jcjt7oslj", "created": "2016-02-28T03:02:33Z"}]}, "error": null}