{"aid": "indaz21z40x41v", "result": {"folders": ["lab4", "lecture14"], "unique_views": 21, "no_answer": 1, "change_log": [{"data": "incjvm7t4uq1qa", "anon": "no", "when": "2016-04-23T02:52:09Z", "uid": "i0ccfx63sir1e", "type": "create"}, {"data": "incjy87a4k56zx", "anon": "no", "when": "2016-04-23T02:54:11Z", "uid": "i0ccfx63sir1e", "type": "update"}, {"to": "incjvm7qowf1q9", "anon": "no", "when": "2016-04-23T02:56:34Z", "uid": "i0f24oie8102cr", "type": "followup"}, {"data": "inck9zx0wei3xt", "anon": "no", "when": "2016-04-23T03:03:20Z", "uid": "i0ccfx63sir1e", "type": "update"}, {"to": "incjvm7qowf1q9", "anon": "no", "when": "2016-04-23T03:03:33Z", "uid": "i0ccfx63sir1e", "type": "feedback"}, {"to": "incjvm7qowf1q9", "anon": "no", "when": "2016-04-23T03:05:19Z", "uid": "i0f24oie8102cr", "type": "feedback"}, {"data": "inczzmm3hfk3vo", "anon": "no", "when": "2016-04-23T10:23:10Z", "uid": "i0ccfx63sir1e", "type": "update"}], "upvote_ids": [], "id": "incjvm7qowf1q9", "bookmarked": 4, "no_answer_followup": 1, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-04-23T02:56:34Z", "no_upvotes": 0, "uid": "i0f24oie8102cr", "created": "2016-04-23T02:56:34Z", "type": "followup", "no_answer": 1, "id": "inck1at3xg3bo", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [{"folders": [], "updated": "2016-04-23T03:03:33Z", "uid": "i0ccfx63sir1e", "created": "2016-04-23T03:03:33Z", "type": "feedback", "id": "inckaaa83c2412", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>我改标题了~</p>"}, {"folders": [], "updated": "2016-04-23T03:05:19Z", "uid": "i0f24oie8102cr", "created": "2016-04-23T03:05:19Z", "type": "feedback", "id": "inckcjkjhltdr", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>。。。好的</p>"}], "subject": "<p>。。。这题目。。。吓死我了</p>"}], "request_instructor_me": false, "nr": 823, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lab4", "lecture14", "student", "unanswered"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-04-23T02:52:09Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1461425439527, "tag_good": [{"name": "叶子鹏", "admin": false, "photo": null, "us": false, "email": "775193759@qq.com", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "id": "i0f24oie8102cr"}, {"admin_permission": 10, "admin": true, "photo": null, "us": false, "email": "xyong@tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "id": "hdjonbiyfs62ie", "name": "Yong XIANG"}], "tag_good_arr": ["i0f24oie8102cr", "hdjonbiyfs62ie"], "history": [{"content": "<p>这是叶子鹏同学课上提出的问题。</p>\n<p></p>\n<p>问题回顾&#xff1a;</p>\n<pre>我们写的程序可以通过main函数的return结束&#xff0c;或者任意地方的exit结束&#xff0c;那么这两种结束程序的方式有什么区别呢&#xff1f;</pre>\n<p>课上解答&#xff1a;</p>\n<pre>同学们和老师的说法是&#xff1a;。。。&#xff08;没注意听或忘记了&#xff0c;欢迎大家补充&#xff09;</pre>\n<p></p>\n<p>从以下角度阐述我的补充&#xff1a;</p>\n<p>0、google &#34;return exit&#34;</p>\n<p>1、linux的角度&#xff1a;objdump一个简单的c程序</p>\n<p>2、ucore lab4的角度&#xff1a;读lab4代码</p>\n<p></p>\n<p><strong>0、google &#34;return exit&#34;</strong></p>\n<p>喜欢直接点的同学&#xff0c;可以直接google结论</p>\n<ul><li><strong>return</strong> is an instruction of the language that returns from a function call.</li><li><strong>exit</strong> is a system call (not a language statement) that terminates the current process.</li></ul>\n<p><a href=\"http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main\">http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main</a></p>\n<p><a href=\"http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return\">http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return</a></p>\n<p></p>\n<p><strong>1、linux的角度&#xff1a;通过objdump一个简单的c程序&#xff0c;进一步理解</strong></p>\n<p>编译和反编译一个简单的hello world程序</p>\n<pre>main.c\n#include &lt;stdio.h&gt;\nint main(int argc, char** argv) {\n    printf(&#34;hello world\\n&#34;);\n    return 0;\n}\nterminal\n$ gcc main.c -o main\n$ objdump -S main &gt; main.s</pre>\n<p></p>\n<p>通过阅读汇编代码main.s。我们可以发现&#xff0c;main.s中有4个section&#xff1a;.init, .plt, .text, .fini</p>\n<p>这四个段的作用有必要说明一下。<strong>因为直接用exit结束程序&#xff0c;将导致.fini不执行&#xff0c;这是exit与return方式结束程序重要的区别。</strong></p>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"6px\"><tbody><tr><td>.init</td><td>\n<p>This section holds executable instructions that contribute to the process initialization code. That is, when a program starts to run the system arranges to execute the code in this section before the main program entry point (called <em>main</em> in C programs).</p>\n<p></p>\n<p>进入main函数之前&#xff0c;.init被调用和执行</p>\n</td></tr><tr><td>.plt</td><td>\n<p>This contains the jump table that is used when we call functions in the shared library. By default the .plt entries are all initialized by the linker not to point to the correct target functions, but instead to point to the dynamic loader itself.</p>\n<p></p>\n<p>用于解决共享库的正确调用</p>\n</td></tr><tr><td>.text</td><td>你懂的</td></tr><tr><td>.fini</td><td>\n<p>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</p>\n<p>.fini section will be executed by the system after the <em>main</em> function returns.</p>\n<p></p>\n<p>main函数return之后&#xff0c;.fini被调用和执行</p>\n</td></tr></tbody></table>\n<p>参考&#xff1a;</p>\n<p><a href=\"http://www.linuxjournal.com/article/1060\">http://www.linuxjournal.com/article/1060</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html</a></p>\n<p></p>\n<p>在main.s的.fini中&#xff0c;可以发现.fini执行__do_global_dtors_aux函数。这个函数有什么用呢&#xff1f;顾名思义&#xff0c;do global destructor auxiliary&#xff0c;用于全局析构。.init中有__do_global_ctors_aux&#xff0c;constructor。</p>\n<p></p>\n<p>看到这&#xff0c;我觉得基本清楚了&#xff0c;return和exit退出程序对c&#43;&#43;程序影响较多&#xff0c;对c影响还行。想想我们写c&#43;&#43;程序&#xff0c;进入main函数的时候&#xff0c;全局的object已经完成初始化了&#xff0c;这是在.init完成的&#xff0c;然后才进入main&#xff1b;相应的&#xff0c;出了main以后&#xff0c;全局的object在.fini完成析构。如果正常执行完main函数返回&#xff0c;那么__do_global_dtors_aux将被调用&#xff0c;析构全局的object&#xff1b;如果程序在某个地方exit&#xff0c;则直接结束进程&#xff0c;全局的object的析构函数将不被调用。constructor和destructor不配套造成的影响&#xff0c;exit也将造成。</p>\n<p></p>\n<p><strong>2、ucore lab4的角度&#xff1a;通过lab4代码来理解</strong></p>\n<p></p>\n<p>我在做lab4看do_fork代码时&#xff0c;整理了一下initproc的过程&#xff0c;如下&#xff1a;</p>\n<pre>1、proc-&gt;context.eip&#xff0c;即forkret\n    proc-&gt;context.esp 为 proc-&gt;tf\n    因此下一步为tf.tf_eip\n2、proc-&gt;tf.tf_eip&#xff0c;即kernel_thread_entry;\n    把ebx移入栈顶\n    因此下一步为tf.tf_regs.reg_ebx\n3、proc-&gt;tf.tf_regs.reg_ebx&#xff0c;即init_main</pre>\n<p><strong>当时有一个不解的地方&#xff1a;为什么要通过kernel_thread_entry&#xff0c;再进入init_main&#xff0c;而不是直接跳转到init_main&#xff1f;</strong></p>\n<p></p>\n<p>现在想明白了。<strong>目的是确保main函数在执行的前后&#xff0c;操作系统能够掌控&#xff0c;例如程序正常执行完后&#xff0c;能够执行do_exit&#xff0c;以操作系统期望的方式善后。</strong></p>\n<p></p>\n<p>kern/process/entry.S</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p></p>", "anon": "no", "subject": "关于return和exit区别的探究", "uid": "i0ccfx63sir1e", "created": "2016-04-23T10:23:10Z"}, {"content": "<p>这是叶子鹏同学课上提出的问题。</p>\n<p></p>\n<p>问题回顾&#xff1a;</p>\n<pre>我们写的程序可以通过main函数的return结束&#xff0c;或者任意地方的exit结束&#xff0c;那么这两种结束程序的方式有什么区别呢&#xff1f;</pre>\n<p>课上解答&#xff1a;</p>\n<pre>同学们和老师的说法是&#xff1a;。。。&#xff08;没注意听或忘记了&#xff0c;欢迎大家补充&#xff09;</pre>\n<p></p>\n<p>从以下角度阐述我的补充&#xff1a;</p>\n<p>0、google &#34;return exit&#34;</p>\n<p>1、linux的角度&#xff1a;objdump一个简单的c程序</p>\n<p>2、ucore lab4的角度&#xff1a;读lab4代码</p>\n<p></p>\n<p><strong>0、google &#34;return exit&#34;</strong></p>\n<p>喜欢直接点的同学&#xff0c;可以直接google结论</p>\n<ul><li><strong>return</strong> is an instruction of the language that returns from a function call.</li><li><strong>exit</strong> is a system call (not a language statement) that terminates the current process.</li></ul>\n<p><a href=\"http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main\">http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main</a></p>\n<p><a href=\"http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return\">http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return</a></p>\n<p></p>\n<p><strong>1、linux的角度&#xff1a;通过objdump一个简单的c程序&#xff0c;进一步理解</strong></p>\n<p>编译和反编译一个简单的hello world程序</p>\n<pre>main.c\n#include &lt;stdio.h&gt;\nint main(int argc, char** argv) {\n    printf(&#34;hello world\\n&#34;);\n    return 0;\n}\nterminal\n$ gcc main.c -o main\n$ objdump -S main &gt; main.s</pre>\n<p></p>\n<p>通过阅读汇编代码main.s。我们可以发现&#xff0c;main.s中有4个section&#xff1a;.init, .plt, .text, .fini</p>\n<p>这四个段的作用有必要说明一下。<strong>因为直接用exit结束程序&#xff0c;将导致.fini不执行&#xff0c;这是exit与return方式结束程序重要的区别。</strong></p>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"6px\"><tbody><tr><td>.init</td><td>\n<p>This section holds executable instructions that contribute to the process initialization code. That is, when a program starts to run the system arranges to execute the code in this section before the main program entry point (called <em>main</em> in C programs).</p>\n<p></p>\n<p>进入main函数之前&#xff0c;.init被调用和执行</p>\n</td></tr><tr><td>.plt</td><td>\n<p>This contains the jump table that is used when we call functions in the shared library. By default the .plt entries are all initialized by the linker not to point to the correct target functions, but instead to point to the dynamic loader itself.</p>\n<p></p>\n<p>用于解决共享库的正确调用</p>\n</td></tr><tr><td>.text</td><td>你懂的</td></tr><tr><td>.fini</td><td>\n<p>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</p>\n<p>.fini section will be executed by the system after the <em>main</em> function returns.</p>\n<p></p>\n<p>main函数return之后&#xff0c;.fini被调用和执行</p>\n</td></tr></tbody></table>\n<p>参考&#xff1a;</p>\n<p><a href=\"http://www.linuxjournal.com/article/1060\">http://www.linuxjournal.com/article/1060</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html</a></p>\n<p></p>\n<p>在main.s的.fini&#xff0c;可以发现其执行__do_global_dtors_aux函数。这个函数有什么用呢&#xff1f;顾名思义&#xff0c;do global destructor auxiliary&#xff0c;用于全局析构。.init中有__do_global_ctors_aux&#xff0c;constructor。</p>\n<p></p>\n<p>看到这&#xff0c;我觉得基本清楚了&#xff0c;return和exit退出程序对c&#43;&#43;程序影响较多&#xff0c;对c影响还行。想想我们写c&#43;&#43;程序&#xff0c;进入main函数的时候&#xff0c;全局的object已经完成初始化了&#xff0c;这是在.init完成的&#xff0c;然后才进入main&#xff1b;相应的&#xff0c;出了main以后&#xff0c;全局的object在.fini完成析构。如果正常执行完main函数返回&#xff0c;那么__do_global_dtors_aux将被调用&#xff0c;析构全局的object&#xff1b;如果程序在某个地方exit&#xff0c;则直接结束进程&#xff0c;全局的object的析构函数将不被调用。constructor和destructor不配套造成的影响&#xff0c;return与exit也将造成。</p>\n<p></p>\n<p><strong>2、ucore lab4的角度&#xff1a;通过lab4代码来理解</strong></p>\n<p></p>\n<p>我在做lab4看do_fork代码时&#xff0c;整理了一下initproc的过程&#xff0c;如下&#xff1a;</p>\n<pre>1、proc-&gt;context.eip&#xff0c;即forkret\n    proc-&gt;context.esp 为 proc-&gt;tf\n    因此下一步为tf.tf_eip\n2、proc-&gt;tf.tf_eip&#xff0c;即kernel_thread_entry;\n    把ebx移入栈顶\n    因此下一步为tf.tf_regs.reg_ebx\n3、proc-&gt;tf.tf_regs.reg_ebx&#xff0c;即init_main</pre>\n<p><strong>当时有一个不解的地方&#xff1a;为什么要通过kernel_thread_entry&#xff0c;再进入init_main&#xff0c;而不是直接跳转到init_main&#xff1f;</strong></p>\n<p></p>\n<p>现在想明白了。<strong>目的是确保main函数在执行的前后&#xff0c;操作系统能够掌控&#xff0c;例如程序正常执行完后&#xff0c;能够执行do_exit&#xff0c;以操作系统期望的方式善后。</strong></p>\n<p></p>\n<p>kern/process/entry.S</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p></p>", "anon": "no", "subject": "关于return和exit区别的探究", "uid": "i0ccfx63sir1e", "created": "2016-04-23T03:03:20Z"}, {"content": "<p>问题回顾&#xff1a;</p>\n<pre>我们写的程序可以通过main函数的return结束&#xff0c;或者任意地方的exit结束&#xff0c;那么这两种结束程序的方式有什么区别呢&#xff1f;</pre>\n<p>课上解答&#xff1a;</p>\n<pre>同学们和老师的说法是&#xff1a;。。。&#xff08;没注意听或忘记了&#xff0c;欢迎大家补充&#xff09;</pre>\n<p></p>\n<p>从以下角度阐述我的补充&#xff1a;</p>\n<p>0、google &#34;return exit&#34;</p>\n<p>1、linux的角度&#xff1a;objdump一个简单的c程序</p>\n<p>2、ucore lab4的角度&#xff1a;读lab4代码</p>\n<p></p>\n<p><strong>0、google &#34;return exit&#34;</strong></p>\n<p>喜欢直接点的同学&#xff0c;可以直接google结论</p>\n<ul><li><strong>return</strong> is an instruction of the language that returns from a function call.</li><li><strong>exit</strong> is a system call (not a language statement) that terminates the current process.</li></ul>\n<p><a href=\"http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main\">http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main</a></p>\n<p><a href=\"http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return\">http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return</a></p>\n<p></p>\n<p><strong>1、linux的角度&#xff1a;通过objdump一个简单的c程序&#xff0c;进一步理解</strong></p>\n<p>编译和反编译一个简单的hello world程序</p>\n<pre>main.c\n#include &lt;stdio.h&gt;\nint main(int argc, char** argv) {\n    printf(&#34;hello world\\n&#34;);\n    return 0;\n}\nterminal\n$ gcc main.c -o main\n$ objdump -S main &gt; main.s</pre>\n<p></p>\n<p>通过阅读汇编代码main.s。我们可以发现&#xff0c;main.s中有4个section&#xff1a;.init, .plt, .text, .fini</p>\n<p>这四个段的作用有必要说明一下。<strong>因为直接用exit结束程序&#xff0c;将导致.fini不执行&#xff0c;这是exit与return方式结束程序重要的区别。</strong></p>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"6px\"><tbody><tr><td>.init</td><td>\n<p>This section holds executable instructions that contribute to the process initialization code. That is, when a program starts to run the system arranges to execute the code in this section before the main program entry point (called <em>main</em> in C programs).</p>\n<p></p>\n<p>进入main函数之前&#xff0c;.init被调用和执行</p>\n</td></tr><tr><td>.plt</td><td>\n<p>This contains the jump table that is used when we call functions in the shared library. By default the .plt entries are all initialized by the linker not to point to the correct target functions, but instead to point to the dynamic loader itself.</p>\n<p></p>\n<p>用于解决共享库的正确调用</p>\n</td></tr><tr><td>.text</td><td>你懂的</td></tr><tr><td>.fini</td><td>\n<p>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</p>\n<p>.fini section will be executed by the system after the <em>main</em> function returns.</p>\n<p></p>\n<p>main函数return之后&#xff0c;.fini被调用和执行</p>\n</td></tr></tbody></table>\n<p>参考&#xff1a;</p>\n<p><a href=\"http://www.linuxjournal.com/article/1060\">http://www.linuxjournal.com/article/1060</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html</a></p>\n<p></p>\n<p>在main.s的.fini&#xff0c;可以发现其执行__do_global_dtors_aux函数。这个函数有什么用呢&#xff1f;顾名思义&#xff0c;do global destructor auxiliary&#xff0c;用于全局析构。.init中有__do_global_ctors_aux&#xff0c;constructor。</p>\n<p></p>\n<p>看到这&#xff0c;我觉得基本清楚了&#xff0c;return和exit退出程序对c&#43;&#43;程序影响较多&#xff0c;对c影响还行。想想我们写c&#43;&#43;程序&#xff0c;进入main函数的时候&#xff0c;全局的object已经完成初始化了&#xff0c;这是在.init完成的&#xff0c;然后才进入main&#xff1b;相应的&#xff0c;出了main以后&#xff0c;全局的object在.fini完成析构。如果正常执行完main函数返回&#xff0c;那么__do_global_dtors_aux将被调用&#xff0c;析构全局的object&#xff1b;如果程序在某个地方exit&#xff0c;则直接结束进程&#xff0c;全局的object的析构函数将不被调用。constructor和destructor不配套造成的影响&#xff0c;return与exit也将造成。</p>\n<p></p>\n<p><strong>2、ucore lab4的角度&#xff1a;通过lab4代码来理解</strong></p>\n<p></p>\n<p>我在做lab4看do_fork代码时&#xff0c;整理了一下initproc的过程&#xff0c;如下&#xff1a;</p>\n<pre>1、proc-&gt;context.eip&#xff0c;即forkret\n    proc-&gt;context.esp 为 proc-&gt;tf\n    因此下一步为tf.tf_eip\n2、proc-&gt;tf.tf_eip&#xff0c;即kernel_thread_entry;\n    把ebx移入栈顶\n    因此下一步为tf.tf_regs.reg_ebx\n3、proc-&gt;tf.tf_regs.reg_ebx&#xff0c;即init_main</pre>\n<p><strong>当时有一个不解的地方&#xff1a;为什么要通过kernel_thread_entry&#xff0c;再进入init_main&#xff0c;而不是直接跳转到init_main&#xff1f;</strong></p>\n<p></p>\n<p>现在想明白了。<strong>目的是确保main函数在执行的前后&#xff0c;操作系统能够掌控&#xff0c;例如程序正常执行完后&#xff0c;能够执行do_exit&#xff0c;以操作系统期望的方式善后。</strong></p>\n<p></p>\n<p>kern/process/entry.S</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p></p>", "anon": "no", "subject": "关于叶子鹏同学课上提问的return和exit区别的探究", "uid": "i0ccfx63sir1e", "created": "2016-04-23T02:54:11Z"}, {"content": "<p>问题回顾&#xff1a;</p>\n<pre>我们写的程序可以通过main函数的return结束&#xff0c;或者任意地方的exit结束&#xff0c;那么这两种结束程序的方式有什么区别呢&#xff1f;</pre>\n<p>课上解答&#xff1a;</p>\n<pre>同学们和老师的说法是&#xff1a;。。。&#xff08;没注意听或忘记了&#xff0c;欢迎大家补充&#xff09;</pre>\n<p></p>\n<p>从以下角度阐述我的补充&#xff1a;</p>\n<p>0、google &#34;return exit&#34;</p>\n<p>1、linux的角度&#xff1a;objdump一个简单的c程序</p>\n<p>2、ucore lab4的角度&#xff1a;读lab4代码</p>\n<p></p>\n<p><strong>0、google &#34;return exit&#34;</strong></p>\n<p>喜欢直接点的同学&#xff0c;可以直接google结论</p>\n<p><a href=\"http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main\">http://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main</a></p>\n<p><a href=\"http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return\">http://stackoverflow.com/questions/3463551/what-is-the-difference-between-exit-and-return</a></p>\n<p></p>\n<p><strong>1、linux的角度&#xff1a;通过objdump一个简单的c程序&#xff0c;进一步理解</strong></p>\n<p>编译和反编译一个简单的hello world程序</p>\n<pre>main.c<br />#include &lt;stdio.h&gt;<br />int main(int argc, char** argv) {<br />    printf(&#34;hello world\\n&#34;);<br />    return 0;<br />}<br />terminal<br />$ gcc main.c -o main<br />$ objdump -S main &gt; main.s</pre>\n<p></p>\n<p>通过阅读汇编代码main.s。我们可以发现&#xff0c;main.s中有4个section&#xff1a;.init, .plt, .text, .fini</p>\n<p>这四个段的作用有必要说明一下。<strong>因为直接用exit结束程序&#xff0c;将导致.fini不执行&#xff0c;这是exit与return方式结束程序重要的区别。</strong></p>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"6px\"><tbody><tr><td>.init</td><td>\n<p>This section holds executable instructions that contribute to the process initialization code. That is, when a program starts to run the system arranges to execute the code in this section before the main program entry point (called <em>main</em> in C programs).</p>\n<p></p>\n<p>进入main函数之前&#xff0c;.init被调用和执行</p>\n</td></tr><tr><td>.plt</td><td>\n<p>This contains the jump table that is used when we call functions in the shared library. By default the .plt entries are all initialized by the linker not to point to the correct target functions, but instead to point to the dynamic loader itself.</p>\n<p></p>\n<p>用于解决共享库的正确调用</p>\n</td></tr><tr><td>.text</td><td>你懂的</td></tr><tr><td>.fini</td><td>\n<p>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</p>\n<p>.fini section will be executed by the system after the <em>main</em> function returns.</p>\n<p></p>\n<p>main函数return之后&#xff0c;.fini被调用和执行</p>\n</td></tr></tbody></table>\n<p>参考&#xff1a;</p>\n<p><a href=\"http://www.linuxjournal.com/article/1060\">http://www.linuxjournal.com/article/1060</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html</a></p>\n<p><a href=\"http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html\">http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node4.html</a></p>\n<p></p>\n<p>在main.s的.fini&#xff0c;可以发现其执行__do_global_dtors_aux函数。这个函数有什么用呢&#xff1f;顾名思义&#xff0c;do global destructor auxiliary&#xff0c;用于全局析构。.init中有__do_global_ctors_aux&#xff0c;constructor。</p>\n<p></p>\n<p>看到这&#xff0c;我觉得基本清楚了&#xff0c;return和exit退出程序对c&#43;&#43;程序影响较多&#xff0c;对c影响还行。想想我们写c&#43;&#43;程序&#xff0c;进入main函数的时候&#xff0c;全局的object已经完成初始化了&#xff0c;这是在.init完成的&#xff0c;然后才进入main&#xff1b;相应的&#xff0c;出了main以后&#xff0c;全局的object在.fini完成析构。如果正常执行完main函数返回&#xff0c;那么__do_global_dtors_aux将被调用&#xff0c;析构全局的object&#xff1b;如果程序在某个地方exit&#xff0c;则直接结束进程&#xff0c;全局的object的析构函数将不被调用。constructor和destructor不配套造成的影响&#xff0c;return与exit也将造成。</p>\n<p></p>\n<p><strong>2、ucore lab4的角度&#xff1a;通过lab4代码来理解</strong></p>\n<p></p>\n<p>我在做lab4看do_fork代码时&#xff0c;整理了一下initproc的过程&#xff0c;如下&#xff1a;</p>\n<pre>1、proc-&gt;context.eip&#xff0c;即forkret\n    proc-&gt;context.esp 为 proc-&gt;tf\n    因此下一步为tf.tf_eip\n2、proc-&gt;tf.tf_eip&#xff0c;即kernel_thread_entry;\n    把ebx移入栈顶\n    因此下一步为tf.tf_regs.reg_ebx\n3、proc-&gt;tf.tf_regs.reg_ebx&#xff0c;即init_main</pre>\n<p><strong>当时有一个不解的地方&#xff1a;为什么要通过kernel_thread_entry&#xff0c;再进入init_main&#xff0c;而不是直接跳转到init_main&#xff1f;</strong></p>\n<p></p>\n<p>现在想明白了。<strong>目的是确保main函数在执行的前后&#xff0c;操作系统能够掌控&#xff0c;例如程序正常执行完后&#xff0c;能够执行do_exit&#xff0c;以操作系统期望的方式善后。</strong></p>\n<p></p>\n<p>kern/process/entry.S</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p></p>", "anon": "no", "subject": "关于叶子鹏同学课上提问的return和exit区别的探究", "uid": "i0ccfx63sir1e", "created": "2016-04-23T02:52:09Z"}]}, "error": null}