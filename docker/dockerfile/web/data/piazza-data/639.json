{"aid": "iln9qzl0pti149", "result": {"folders": ["lab1", "lab5", "工具使用"], "unique_views": 92, "request_instructor_me": false, "change_log": [{"data": "il8ngz1lbvb2z", "anon": "full", "when": "2016-03-01T00:02:15Z", "type": "create"}, {"uid": "hs2swpdtr91gu", "data": "il8ss5lbbqs5uk", "when": "2016-03-01T02:30:55Z", "to": "il8ngz1h5bw2y", "anon": "no", "type": "i_answer"}, {"to": "il8ngz1h5bw2y", "anon": "full", "when": "2016-03-01T07:19:41Z", "type": "followup"}, {"to": "il8ngz1h5bw2y", "anon": "no", "when": "2016-03-01T09:56:48Z", "uid": "hs2swpdtr91gu", "type": "feedback"}, {"to": "il8ngz1h5bw2y", "anon": "full", "when": "2016-03-01T12:13:13Z", "type": "feedback"}, {"to": "il8ngz1h5bw2y", "anon": "no", "when": "2016-03-01T12:15:51Z", "uid": "hs2swpdtr91gu", "type": "feedback"}], "upvote_ids": [], "id": "il8ngz1h5bw2y", "bookmarked": 4, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-01T02:30:55Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "i_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "il8ss5l7nk05uj", "history": [{"content": "<p>是初始的labcode&#xff1f;之前的实验已经开启了分页</p>", "anon": "no", "subject": "", "uid": "hs2swpdtr91gu", "created": "2016-03-01T02:30:55Z"}]}, {"folders": [], "updated": "2016-03-01T07:19:41Z", "no_upvotes": 0, "created": "2016-03-01T07:19:41Z", "type": "followup", "d-bucket": "Yesterday", "id": "il933ie63qg6jq", "anon": "full", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-01T09:56:48Z", "uid": "hs2swpdtr91gu", "created": "2016-03-01T09:56:48Z", "type": "feedback", "d-bucket": "Yesterday", "id": "il98pkxivkg64m", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>与lab5无关&#xff0c;实际上跳转的地址还是(x-3G)</p>\n<p>可以参考实验指导书 lab2 https://objectkuan.gitbooks.io/ucore-docs/content/lab2/lab2_3_3_5_4_maping_relations.html</p>"}, {"folders": [], "updated": "2016-03-01T12:13:13Z", "created": "2016-03-01T12:13:13Z", "config": {}, "children": [], "anon": "full", "bucket_name": "Today", "type": "feedback", "bucket_order": 2, "data": null, "id": "il9dl0jnfad1ca", "subject": "<p>非常感谢!!!</p>\n<p>我明白了, kern_entry这个地方临时换了gdt, 临时gdt的中段描述符的段起始地址是 <strong>-KERNAL_BASE</strong>, 所以是通过分段机制将0xC01xxxxx虚拟地址映射到了0x001xxxxx.</p>"}, {"folders": [], "updated": "2016-03-01T12:15:51Z", "uid": "hs2swpdtr91gu", "created": "2016-03-01T12:15:51Z", "type": "feedback", "id": "il9doe0ebmo28q", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>是这样的&#xff0c;不客气</p>"}], "subject": "<p>但是分页机制是在kernel_init函数里pmm_init里面才打开, pmm_init之前的代码是如何运行的?</p>"}], "no_answer_followup": 0, "nr": 639, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lab1", "lab5", "student", "工具使用"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-01T00:02:15Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457674480548, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>基于lab5的代码, 但是只根bootloader和kern_init有关.</p>\n<p>1. make qemu可以看到e820检测到的可用<strong>物理内存只有128M左右</strong></p>\n<p>e820map:<br /> memory: 0009fc00, [00000000, 0009fbff], type = 1. // type=1是可用物理内存, type=2是ROM或者设备占用的内存地址</p>\n<p>memory: 00000400, [0009fc00, 0009ffff], type = 2.<br /> memory: 00010000, [000f0000, 000fffff], type = 2.<br /> memory: 07ee0000, [00100000, 07fdffff], type = 1.<br /> memory: 00020000, [07fe0000, 07ffffff], type = 2.<br /> memory: 00040000, [fffc0000, ffffffff], type = 2.</p>\n<p></p>\n<p>2. 链接脚本tools/kernel.ld可以看到<strong>kernel文件的起始地址被设为0xC0100000</strong>, 这样kernel中所有汇编代码使用的地址(包括跳转指令,全局变量, 字符串等)都是0xC0100000&#43;偏移量. </p>\n<p></p>\n<p>3. mbr中的代码boot/bootmain.c中, 可以看到引用elf头中的地址都只取前16M. </p>\n<p>readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</p>\n<p>...</p>\n<p>((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</p>\n<p><strong>所以kernel实际被加载到物理内存0x100000处.</strong></p>\n<p>4. kern/init/init.c中在pmm_init之前, 没有开启分页, 所以<strong>在此之前CPU使用的所有地址都是物理地址</strong>.</p>\n<p>5. 用gdb跟踪内核, 断点在0x100000, 也就是kern/init/entry.S的kern_entry位置. 断下后可以发现一条指令&#34;ljmp $0x8,$0xc0100019&#34;, <strong>这里使用了3G以上的物理地址.  </strong>单步跟踪到这条指令, 会发现eip的确被设置成了3G以上的地址.</p>\n<p>6. 这时用gdb查看内存的指令查看3G以上的地址会发现全是0, 用bochs模拟器, 可以指定查看物理地址还是虚拟地址, 3G以上全是0xFF, 这都暗示3G以上内存应该是未使用的.</p>\n<p>7. 奇怪的是如果让内核继续运行, 不会发生内存访问错误, 明明<strong>没有启用分页却使用了超出物理内存大小的地址</strong>. </p>", "anon": "full", "subject": "关于kernel文件加载地址的疑问", "created": "2016-03-01T00:02:15Z"}]}, "error": null}