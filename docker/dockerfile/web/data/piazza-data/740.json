{"aid": "imaq37x6jj7jn", "result": {"folders": ["lecture11"], "unique_views": 21, "no_answer": 0, "change_log": [{"data": "ima07sp54am3wf", "anon": "no", "when": "2016-03-27T03:26:30Z", "uid": "i0et95bli7r7ky", "type": "create"}, {"uid": "i0f9pvv0uxm6ko", "data": "ima12a10p8w48p", "when": "2016-03-27T03:50:12Z", "to": "ima07sp3fgc3we", "anon": "no", "type": "s_answer"}, {"data": "ima17ihoq477fh", "anon": "no", "when": "2016-03-27T03:54:17Z", "uid": "i0f9pvv0uxm6ko", "type": "s_answer_update"}, {"data": "ima1hby3cs46hx", "anon": "no", "when": "2016-03-27T04:01:55Z", "uid": "hzx4nrqzey8768", "type": "s_answer_update"}, {"to": "ima07sp3fgc3we", "anon": "no", "when": "2016-03-27T04:08:09Z", "uid": "hzx4nrqzey8768", "type": "followup"}, {"uid": "hcrrjuyequh4bt", "data": "imaj7dnbxck6iu", "when": "2016-03-27T12:18:03Z", "to": "ima07sp3fgc3we", "anon": "no", "type": "i_answer"}], "upvote_ids": [], "id": "ima07sp3fgc3we", "bookmarked": 6, "no_answer_followup": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-27T03:50:12Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "ima12a0xbxi48o", "history": [{"content": "<p>和其他用户态库函数一样&#xff0c;fork()需要调用int 0x80&#xff08;syscall&#xff09;&#xff0c;此时子进程的所谓的下一条语句是syscall的后一条语句&#xff08;准确来说&#xff0c;一个进程的第一条语句一定是构造中断帧用以从内核态返回用户态&#xff0c;这里说的下一条语句是指返回后的第一条&#xff09;&#xff0c;这时候fork()还没有返回。这里子进程fork()返回的是进程初始化到可运行的值&#xff0c;这个值为0。</p>\n<p>而父进程由于在内核态执行了生成子进程等一系列的操作&#xff0c;这些操作也会最终在syscall后产生一个返回值&#xff0c;内核将这个返回值实现为pid。</p>", "anon": "no", "subject": "", "uid": "hzx4nrqzey8768", "created": "2016-03-27T04:01:55Z"}, {"content": "<p>和其他用户态库函数一样&#xff0c;fork()需要调用int 0x80&#xff08;syscall&#xff09;&#xff0c;此时子进程的所谓的下一条语句是syscall的后一条语句&#xff08;准确来说&#xff0c;一个进程的第一条语句一定是构造中断帧用以从内核态返回用户态&#xff0c;这里说的下一条语句是指返回后的第一条&#xff09;&#xff0c;这时候fork()还没有返回。这里子进程fork()返回的是进程初始化到可运行的值&#xff0c;这个值为0。</p>\n<p>而父进程由于在内核态执行了生成子进程等一系列的操作&#xff0c;这些操作也会最终在syscall后产生一个返回值&#xff0c;内核将这个返回值实现为pid。</p>", "anon": "no", "subject": "", "uid": "i0f9pvv0uxm6ko", "created": "2016-03-27T03:54:17Z"}, {"content": "<p>和其他用户态库函数一样&#xff0c;fork()需要调用int 0x80&#xff08;syscall&#xff09;&#xff0c;此时子进程的所谓的下一条语句是syscall的后一条语句&#xff0c;这时候fork()还没有返回。这里子进程fork()返回的是进程初始化到可运行的值&#xff0c;这个值为0。</p>\n<p>而父进程由于在内核态执行了生成子进程等一系列的操作&#xff0c;这些操作也会最终在syscall后产生一个返回值&#xff0c;内核将这个返回值实现为pid。</p>", "anon": "no", "subject": "", "uid": "i0f9pvv0uxm6ko", "created": "2016-03-27T03:50:12Z"}]}, {"folders": [], "updated": "2016-03-27T04:08:09Z", "no_upvotes": 0, "uid": "hzx4nrqzey8768", "created": "2016-03-27T04:08:09Z", "type": "followup", "d-bucket": "Yesterday", "id": "ima1pcy9qp7va", "anon": "no", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>哎&#xff0c;刚刚写了一个几百字的答案&#xff0c;一提交&#xff0c;没了。。。。。</p>\n<p>算了&#xff0c;李宇轩回答的已经很正确了&#xff0c;我就补充一句&#xff0c;就是 fork() 对于用户程序来讲&#xff0c;就是一个普通的系统调用&#xff0c;该有返回值还有返回值&#xff0c;不存在“跳转到下一条语句开始执行”的问题。fork() 一执行&#xff0c;会立刻复制当前进程一份&#xff0c;然后这俩进程同时开始继续执行&#xff0c;唯一的区别是&#xff0c;返回值在父进程中是大于0的&#xff0c;意思是子进程的 pid&#xff0c;返回值在子进程中等于 0。通过这个来区别父子进程。</p>"}, {"folders": [], "is_tag_endorse": false, "created": "2016-03-27T12:18:03Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "i_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "imaj7dnayqz6it", "history": [{"content": "<p>叶雨菲&#xff0c;你是在C语言的级别考虑fork返回后的下一条语句。而李宇轩是在汇编语言的级别考虑fork返回后的下一条语句&#xff0c;即inte 0x80后的那条汇编语句。这两个语句是不一样的。</p>", "anon": "no", "subject": "", "uid": "hcrrjuyequh4bt", "created": "2016-03-27T12:18:03Z"}]}], "request_instructor_me": false, "nr": 740, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lecture11", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-27T03:26:30Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1459092647130, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p></p><p>关于创建新进程的描述正确的是&#xff08;&#xff09; s2</p>\n<ul><li>[x] fork() 创建子进程中&#xff0c;会复制父进程的所有变量和内存</li><li>[x] 子进程的fork()返回0</li><li>[x] 父进程的fork()在创建子进程成功后&#xff0c;返回子进程标识符</li><li>[x] fork() 创建子进程中&#xff0c;会复制父进程的页表</li></ul>\n<p></p>\n<p>我的理解&#xff1a;fork之后得到的子进程&#xff0c;会直接从fork的下一条语句开始执行&#xff0c;为什么存在子进程的fork返回值呢&#xff1f;</p>\n<p>以及&#xff0c;fork() == 0的时候&#xff0c;不是表明这是父进程吗&#xff1f;跟bc正好反了&#xff1f;</p>\n<p></p>\n<p>希望得到解答&#xff0c;谢谢&#xff01;</p>", "anon": "no", "subject": "fork()返回值的问题", "uid": "i0et95bli7r7ky", "created": "2016-03-27T03:26:30Z"}]}, "error": null}