{"aid": "iln9rlehf571lp", "result": {"folders": ["q&amp;a"], "unique_views": 99, "request_instructor_me": false, "change_log": [{"data": "ilhjdvy0dlp2cd", "anon": "no", "when": "2016-03-07T05:17:48Z", "uid": "i6ub4vwhQXd", "type": "create"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T06:52:47Z", "type": "followup"}, {"to": "ilhjdvxo6ck2cc", "anon": "no", "when": "2016-03-07T11:29:16Z", "uid": "i0dlq4m0wjn5eo", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T11:54:05Z", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T12:10:30Z", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "no", "when": "2016-03-07T12:21:34Z", "uid": "i6ub4vwhQXd", "type": "feedback"}, {"uid": "i6uqzf449em3ex", "data": "ilj1re0tgsm1vn", "when": "2016-03-08T06:39:57Z", "to": "ilhjdvxo6ck2cc", "anon": "no", "type": "s_answer"}], "upvote_ids": [], "id": "ilhjdvxo6ck2cc", "bookmarked": 6, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-03-07T06:52:47Z", "no_upvotes": 0, "created": "2016-03-07T06:52:47Z", "type": "followup", "d-bucket": "Yesterday", "id": "ilhms13fe667id", "anon": "full", "bucket_name": "Yesterday", "no_answer": 0, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-07T11:29:16Z", "uid": "i0dlq4m0wjn5eo", "created": "2016-03-07T11:29:16Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilhwnl7jqbl5gx", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>会的啊&#xff0c;用线段树实现的话&#xff0c;如果128K的空闲在左子树&#xff0c;64K的空闲在右子树&#xff0c;那么根据一般的遍历逻辑&#xff0c;就会把左边的128K分割成两个64K&#xff0c;并将其中一个分配出去。</p>"}, {"folders": [], "updated": "2016-03-07T11:54:05Z", "created": "2016-03-07T11:54:05Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilhxjirgay6zn", "anon": "full", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>为什么要用线段树呢, 用链表不就行了吗? 而且时间常数更小?</p>"}, {"folders": [], "updated": "2016-03-07T12:10:30Z", "created": "2016-03-07T12:10:30Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilhy4m5qgte6i0", "anon": "full", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>抱歉, 上一句说的不太对, 看了老师给的这个链接<a href=\"http://coolshell.cn/articles/10427.html,\">http://coolshell.cn/articles/10427.html,</a> 貌似的确是要分割128K的块</p>"}, {"folders": [], "updated": "2016-03-07T12:21:34Z", "uid": "i6ub4vwhQXd", "created": "2016-03-07T12:21:34Z", "type": "feedback", "d-bucket": "Yesterday", "id": "ilhyiuvvmwk6ce", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>感觉还是比较模糊&#xff0c;这个链接里面的图示样例是分割64k那块的&#xff0c;但是代码是分割了128K那块&#xff0c;单纯用链表可以做到logN么&#xff1f;</p>"}], "subject": "<p>根据我对buddy system的理解, 如果需要分配64K的内存块, 应该会先从不小于64K的内存块链表上查找有没有空闲块吧? </p>\n<p>而不会出现&#34;有一个128K的空闲块在一个64K的空闲块前&#34;吧?</p>"}, {"folders": [], "is_tag_endorse": false, "created": "2016-03-08T06:39:57Z", "config": {}, "tag_endorse_arr": ["ie7xy4gmt1p1pp"], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [{"name": "Alex Wang", "admin": false, "photo": null, "us": false, "email": "wac14@mails.tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "id": "ie7xy4gmt1p1pp"}], "bucket_order": 2, "data": {"embed_links": []}, "id": "ilj1re0pn8t1vm", "history": [{"content": "<p>参考 <a href=\"http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/\">http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/</a></p>\n<p></p>\n<pre>buddy system根据参数order&#xff0c;在要求的zone中查找对应的链表。若该order的双向链表非空&#xff0c;则把该双向链表上的第一个block从buddy system中脱链&#xff0c;同时更新该双向链表上的block的数量&#xff0c;完成内存分配。若该order的双向链表为空&#xff0c;则查找order&#43;1的双向链表&#xff0c;如果order&#43;1的双向链表为空&#xff0c;则查找order&#43;2的双向链表&#xff0c;直到查找到。</pre>\n<p>所以应该会试用64K的空闲块&#xff0c;由于是链表所以不存在128K在64K内存块前的问题&#xff0c;因为两个block不在一个链表里。</p>\n<p></p>\n<p>复杂度分析的话&#xff0c;如果是你说的这种情况&#xff0c;应该是O(1)的&#xff0c;因为直接从64K对应的链表里取了一个block。</p>\n<p>最坏情况是在一个最大order为$$M=log_2 N$$的系统中取一个最小的block&#xff0c;需要分裂O(M)次。&#xff08;每次操作为分裂order K的block为两个order K-1的block&#xff0c;一个插入链表&#xff0c;另一个继续分裂&#xff09;</p>", "anon": "no", "subject": "", "uid": "i6uqzf449em3ex", "created": "2016-03-08T06:39:57Z"}]}], "no_answer_followup": 0, "nr": 661, "bucket_order": 2, "config": {}, "status": "active", "tags": ["q&amp;a", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-07T05:17:48Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457674508825, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>在用Buddy System进行内存分配时&#xff0c;如果有一个128K的空闲块在一个64K的空闲块前&#xff0c;此时需要分配一个64K的内存&#xff0c;那么会分割128K那个空闲块&#xff0c;还是直接使用后面那个64K的空闲块&#xff1f;如果需要满足最优的方案(直接用64K的那块)的话&#xff0c;貌似LogN的时间内出不来结果&#xff1f;</p>", "anon": "no", "subject": "Buddy System需要找到满足条件的最小空闲内存么&#xff1f;", "uid": "i6ub4vwhQXd", "created": "2016-03-07T05:17:48Z"}]}, "error": null}