{"aid": "jgxahwu9m9q1ai", "result": {"status": "active", "unique_views": 195, "request_instructor_me": false, "change_log": [{"data": "i9ccmyc78dd3r3", "anon": "no", "when": "2015-05-06T06:13:35Z", "uid": "hdjonbiyfs62ie", "type": "create"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:15:47Z", "uid": "i71i9b92nrr7n4", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:17:51Z", "uid": "i6uunp7jxDb", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:20:04Z", "uid": "i6rgda76fc66q4", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:20:08Z", "uid": "i6uayov5SAo", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:20:37Z", "uid": "i6ub691ffHe", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:20:57Z", "uid": "i6t1w87gRBD", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:22:03Z", "uid": "i6roqnlkmtw", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:22:21Z", "uid": "hs2sszu8rbz6jj", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:23:07Z", "uid": "i6s09f3xHOf", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:23:33Z", "uid": "i6t6y9snjx2", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:24:18Z", "uid": "i6rgda76fc66q4", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:34:28Z", "uid": "i6vkh2uqu3V", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:35:59Z", "uid": "i6uaz13iyeM", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:48:39Z", "uid": "i7oaxkxhxjo3ui", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T06:57:47Z", "uid": "i6tezdpdQbq", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:00:58Z", "uid": "i71fykcui1h2je", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:03:28Z", "uid": "i6un4iacNGX", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:04:09Z", "uid": "i7bg4v1keqE", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:04:17Z", "uid": "i71i9b92nrr7n4", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:06:44Z", "uid": "i6uayl3vEOz", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:07:23Z", "uid": "i6ut6cjo5lj4aa", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:07:57Z", "uid": "i6roqnlkmtw", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:10:41Z", "uid": "i718mp903qx", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:19:04Z", "uid": "i6t76fg9sEh", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T07:28:50Z", "uid": "i6sl02qfUgI", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T08:27:33Z", "uid": "i6rtbanwzcm5t6", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T08:38:33Z", "uid": "i6uteptdP5U", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T08:57:10Z", "uid": "i6un4iacNGX", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T09:47:58Z", "uid": "i6vkh2uqu3V", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T11:11:13Z", "uid": "i6rgfjo5j1r6c", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T14:29:28Z", "uid": "i6t1w87gRBD", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T14:58:50Z", "uid": "i6t6y9snjx2", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T14:59:51Z", "uid": "i6t6y9snjx2", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-06T15:00:22Z", "uid": "i6t6y9snjx2", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-11T05:41:19Z", "uid": "i6vkh2uqu3V", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-13T16:16:23Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-13T16:19:14Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-15T08:20:02Z", "uid": "i6t6y9snjx2", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2015-05-15T15:06:11Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"data": "ini9dsn2yjb1xr", "anon": "no", "when": "2016-04-27T02:44:58Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2017-04-28T07:39:03Z", "type": "followup", "uid": "izb0cbqbyzd6wf"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2017-05-07T00:01:50Z", "type": "followup", "uid": "izb0cbkdd5s6w9"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2017-05-07T01:00:48Z", "type": "feedback", "uid": "izb0cbqbyzd6wf"}, {"to": "i9ccmyc49aa3r2", "anon": "no", "when": "2018-05-08T00:55:18Z", "type": "feedback", "uid": "isvxeq6bspf1vn"}], "upvote_ids": [], "id": "i9ccmyc49aa3r2", "bookmarked": 29, "tags": ["instructor-note", "lecture18", "lecture19", "课堂问答"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2015-05-06T06:15:47Z", "no_upvotes": 0, "uid": "i71i9b92nrr7n4", "created": "2015-05-06T06:15:47Z", "type": "followup", "no_answer": 0, "id": "i9ccpsb2ul3562", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T07:04:17Z", "uid": "i71i9b92nrr7n4", "created": "2015-05-06T07:04:17Z", "type": "feedback", "id": "i9ceg5ptdnh6ml", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>Source Code</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n\nint iflag = 0;\nint oflag = 0;\nsem_t empty, full, mutex;\nint empty_count, full_count;\nint data_num = 0;\nint num = 0;\n\nint buffer[BUFFER_SIZE] = {};\n\nint p_task_done = -1;\nint c_task_done = -1;\t\n\nstruct arg_struct{\n\targ_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n\targ_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n\tint id;\n\tint start;\n\tint work;\n\tstring indent;\t\n};\n\nvoid* producer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\n\tsleep(arg.start);\n\n\t//printf(&#34;Producer %d waiting for EMPTY: %d\\n&#34;, id, empty_count);\n\tprintf(&#34;%sSTART\\n&#34;, indent);\n\n\tsem_wait(&amp;empty);\n\t//printf(&#34;Producer %d Waiting for MUTEX\\n&#34;, id);\n\tprintf(&#34;%saEMPTY\\n&#34;, indent);\n\n\tsem_wait(&amp;mutex);\n\t//printf(&#34;Producer %d entered Critical\\n&#34;, id);\n\tprintf(&#34;%saMUTEX\\n&#34;, indent);\n\n\tprintf(&#34;%sENTER\\n&#34;, indent);\t\n\t\n\tint time = rand()%SLEEP_SPAN;\n\t//sleep(time);\n\tsleep(arg.work);\n\n\tp_task_done&#43;&#43;;\n\t//printf(&#34;Producer %d Produced: %d\\n&#34;, id, p_task_done);\n\tprintf(&#34;%sProd %d\\n&#34;, indent, p_task_done);\n\n\tbuffer[iflag] = p_task_done;\n\n\tif (empty_count == 0) printf(&#34;Error: Produce while no empty\\n&#34;);\n\tiflag = (iflag &#43; 1) % BUFFER_SIZE;\n\tempty_count--;\n\tfull_count&#43;&#43;;\n\n\t//printf(&#34;Producer %d exited Critical\\n&#34;, id);\n\tprintf(&#34;%sEXIT\\n&#34;, indent);\n\t\n\tsem_post(&amp;mutex);\n\tprintf(&#34;%srMUTEX\\n&#34;, indent);\t\n\t//printf(&#34;Producer %d released MUTEX\\n&#34;, id);\n\n\tsem_post(&amp;full);\n\tprintf(&#34;%srFULL\\n&#34;, indent);\n\t//printf(&#34;Producer %d released FULL: %d\\n&#34;, id, full_count);\n\n\treturn NULL;\n}\n\nvoid* consumer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\n\tsleep(arg.start);\n\n\t//printf(&#34;Consumer %d Waiting for FULL: %d\\n&#34;, id, full_count);\n\tprintf(&#34;%sSTART\\n&#34;, indent);\n\n\tsem_wait(&amp;full);\n\t//printf(&#34;Consumer %d Waiting for MUTEX\\n&#34;, id);\n\tprintf(&#34;%saFULL\\n&#34;, indent);\n\n\tsem_wait(&amp;mutex);\n\tprintf(&#34;%saMUTEX\\n&#34;, indent);\n\n\t//printf(&#34;Consumer %d entered Critical\\n&#34;, id);\n\tprintf(&#34;%sENTER\\n&#34;, indent);\t\n\n\tsleep(arg.work);\n\t\t\n\t&#43;&#43;c_task_done;\n\tif (full_count == 0) printf(&#34;Error: Consume while no full\\n&#34;);\n\n\tint tmp = buffer[oflag];\n\t//printf(&#34;Consumer %d consumed: %d\\n&#34;, id, tmp);\n\tprintf(&#34;%sCons %d\\n&#34;, indent, tmp);\t\n\n\toflag = (oflag &#43; 1) % BUFFER_SIZE;\n\tif (c_task_done != tmp) printf(&#34;Error: Consume data wrong\\n&#34;);\n\tif (c_task_done &gt; p_task_done) printf(&#34;Error: Over-consume!\\n&#34;);\n\n\tfull_count--;\n\tempty_count&#43;&#43;;\n\t\t\n\t//printf(&#34;Consumer %d exited Critical\\n&#34;, id);\n\tprintf(&#34;%sEXIT\\n&#34;, indent);\n\t\n\tsem_post(&amp;mutex);\n\t//printf(&#34;Consumer %d released MUTEX\\n&#34;, id);\n\tprintf(&#34;%srMUTEX\\n&#34;, indent);\n\n\tsem_post(&amp;empty);\n\t//printf(&#34;Consumer %d released EMPTY: %d\\n&#34;, id, empty_count);\n\tprintf(&#34;%srEMPTY\\n&#34;, indent);\n\n\treturn NULL;\n}\n\nint main(int argc, char** argv) {\n\tsrand((unsigned)time(NULL));\n\n\tmemset(buffer, 0, sizeof(int) * BUFFER_SIZE);\n\n\tsem_init(&amp;mutex, 0, 1);\n\tsem_init(&amp;empty, 0, BUFFER_SIZE);\n\tsem_init(&amp;full, 0, 0);\n\n\tempty_count = BUFFER_SIZE;\n\tfull_count = 0;\n\n\t#define N 3\n\tpthread_t p_consumer[2 * N], p_producer[2 * N];\n\n\tint c_count = 0, p_count = 0;\n\n\t#define PRODUCER 0\n\t#define CONSUMER 1\n\n\t/* For managed creation of 2 * N threads */\n\n\t#define TEST1\n\n\t#ifdef TEST1\n\tint st_time = 0;\n\tint inst[2 * N][3] = {\n\t\t/* { Consumer or Producer to be create?, \n\t\t     When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n\t\t     How long does it work after it enters critical zone? } */\n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 1, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 4, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}\n\t};\n\t#else\n\tint inst[2 * N][3] = {\n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 1, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 4, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}\n\t};\n\t#endif\n\n\t/* Print the first line */\n\tint tmp_c = 0, tmp_p = 0;\n\tfor (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n\t\tif (inst[i][0] == PRODUCER){\n\t\t\tprintf(&#34;P%d\\t&#34;, tmp_p&#43;&#43;);\n\t\t} else if (inst[i][0] == CONSUMER){\n\t\t\tprintf(&#34;C%d\\t&#34;, tmp_c&#43;&#43;);\n\t\t}\n\t}\n\tprintf(&#34;\\n&#34;);\n\n\t/* Create Producers and Consumers according to $inst*/\n\tint rc;\n\tstring indent(&#34;&#34;);\n\tfor (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n\t\tif (inst[i][0] == PRODUCER){\n\t\t\t//printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n\t\t\trc = pthread_create(p_producer &#43; p_count, NULL, producer, new arg_struct(p_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tp_count&#43;&#43;;\n\t\t} else if (inst[i][0] == CONSUMER){\n\t\t\t//printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n\t\t\trc = pthread_create(p_consumer &#43; c_count, NULL, consumer, new arg_struct(c_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tc_count&#43;&#43;;\n\t\t}\n\t\tindent &#43;= &#39;\\t&#39;;\n\t}\n\n\t/* wait until every thread finishes*/\n\tfor (int i = 0; i &lt; p_count; i&#43;&#43;){\n\t\tpthread_join(p_producer[i], NULL);\n\t}\n\tfor (int i = 0; i &lt; c_count; i&#43;&#43;){\n\t\tpthread_join(p_consumer[i], NULL);\t\n\t}\n\n\treturn 0;\n}</pre>\n<p></p>\n<p>Output</p>\n<p></p>\n<pre>C0\tC1\tC2\tP0\tP1\tP2\t\nSTART\n\t\tSTART\n\tSTART\n\t\t\tSTART\n\t\t\taEMPTY\n\t\t\taMUTEX\n\t\t\tENTER\n\t\t\t\tSTART\n\t\t\t\taEMPTY\n\t\t\t\t\tSTART\n\t\t\tProd 0\n\t\t\tEXIT\n\t\t\trMUTEX\n\t\t\trFULL\n\t\t\t\taMUTEX\n\t\t\t\tENTER\naFULL\n\t\t\t\tProd 1\n\t\t\t\tEXIT\n\t\t\t\trMUTEX\n\t\t\t\trFULL\naMUTEX\nENTER\n\t\taFULL\nCons 0\nEXIT\nrMUTEX\nrEMPTY\n\t\taMUTEX\n\t\tENTER\n\t\t\t\t\taEMPTY\n\t\tCons 1\n\t\tEXIT\n\t\trMUTEX\n\t\trEMPTY\n\t\t\t\t\taMUTEX\n\t\t\t\t\tENTER\n\t\t\t\t\tProd 2\n\t\t\t\t\tEXIT\n\t\t\t\t\trMUTEX\n\t\t\t\t\trFULL\n\taFULL\n\taMUTEX\n\tENTER\n\tCons 2\n\tEXIT\n\trMUTEX\n\trEMPTY</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-13T16:16:23Z", "uid": "hdjonbiyfs62ie", "created": "2015-05-13T16:16:23Z", "type": "feedback", "id": "i9my94xkhfqu4", "anon": "no", "bucket_name": "Week 5/10 - 5/16", "config": {}, "bucket_order": 161, "data": null, "children": [], "subject": "<p></p><p>在 2015年5月14日&#xff0c;上午12:15&#xff0c;xyong &lt;xyong&#64;mail.tsinghua.edu.cn&gt; 写道&#xff1a;</p>\n<p>梁锡豪&#xff0c;你好&#xff01;</p>\n<p></p>\n<p>你的邮件中没有附件。我认为目前的代码与我的期望是一致的。如果能再加点儿注释就更好了。</p>\n<p></p>\n<p>请把你的输出放在piazza上&#xff0c;并更新代码&#xff08;我在piazza上的代码中没有看到TEST相关的代码&#xff09;。</p>\n<p></p>\n<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=391\">https://piazza.com/class/i5j09fnsl7k5x0?cid=391</a></p>\n<p></p>\n<p>--向勇</p>\n<p></p>\n<p>在 2015年5月13日&#xff0c;下午4:25&#xff0c;Sek Hou Leong &lt;<a href=\"mailto:sekhou64&#64;hotmail.com\">sekhou64&#64;hotmail.com</a>&gt; 写道&#xff1a;</p>\n<p>向老师你好, </p>\n<p></p>\n<p>我是操作系统课上的学生梁锡豪, 附件是生产者-消费者问题的测试代码(main.cpp), 可执得档案(main) [linux下生成], 以及输出样例(out.txt).</p>\n<p><br /></p>\n<p>1) 代码已经修改, 更方便人为设置各进程的运行参数(开始时间, 临界区停留时间)</p>\n<p>2) 输出格式已经修改, 形如表格, 各进程进度的时间关系更一目了然</p>\n<p>3) 预设两组测试样例, 分别使得 i)消费者等待生产者, ii)生产者等待空BUFFER, 透过对#define TEST1控制</p>\n<p><br /></p>\n<p>在ubuntu bash下的编译/执行命令为</p>\n<p>g&#43;&#43; main.cpp -o main -pthread</p>\n<p>./main</p>\n<p></p>\n<p>未知是否需要进一步修改, 请查收.<br /></p>\n<p></p>\n<p></p>\n<p></p>\n<p>祝<br /></p>\n<p>工作顺利</p>\n<p><br /></p>\n<p>学生</p>\n<p>梁锡豪</p>"}, {"folders": [], "updated": "2015-05-13T16:19:14Z", "uid": "hdjonbiyfs62ie", "created": "2015-05-13T16:19:14Z", "type": "feedback", "id": "i9mycspv3l4v4", "anon": "no", "bucket_name": "Week 5/10 - 5/16", "config": {}, "bucket_order": 161, "data": null, "children": [], "subject": "<p>一些同学的进程同步算法没有很好地进行测试。建议这些同学参考一下梁锡豪同学的算法实现和测试用例设计。对检查同步算法的正确很有必要。</p>"}], "subject": "<p>1. </p>\n<p>第一章(一)生产者一消费者问题(producer-consumerproblem)</p>\n<p>http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync0<br /><br />計22 梁锡豪　2012011290</p>"}, {"folders": [], "updated": "2015-05-06T06:17:51Z", "no_upvotes": 0, "uid": "i6uunp7jxDb", "created": "2015-05-06T06:17:51Z", "type": "followup", "no_answer": 1, "id": "i9ccsg2cck25hg", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>2.</p>\n<p>读者-写者问题</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync02\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync02</a></p>\n<p></p>\n<p>计22 沈光耀 2012011273</p>\n<p></p>\n<p>读者优先</p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;unistd.h&gt;\n\nconst int n = 5;\nsem_t write_mutex, count_mutex;\nint readcount = 0;\nconst int SLEEP_TIME = 1;\n\nvoid * read(void* arg)\n{\n        int i = *(int*)(arg);\n        sem_wait(&amp;count_mutex);\n        if(readcount ==0){\n                sem_wait(&amp;write_mutex);\n        }\n        readcount&#43;&#43;;\n        printf(&#34;read count is %d\\n&#34;, readcount);\n        sem_post(&amp;count_mutex);\n\n        printf(&#34;No.%d Reader Now Reading\\n&#34;, i);\n        sleep(SLEEP_TIME);\n        printf(&#34;No.%d Reader Now Finished\\n&#34;, i);\n\n        sem_wait(&amp;count_mutex);\n        readcount--;\n        if(readcount == 0)\n                sem_post(&amp;write_mutex);\n        sem_post(&amp;count_mutex);\n        printf(&#34;No.%d Reader Now Quit\\n&#34;, i);\n\n        return NULL;\n}\n\nvoid * write(void* arg)\n{\n        sleep(SLEEP_TIME);\n        int i = *(int*)(arg);\n        sem_wait(&amp;write_mutex);\n        printf(&#34;No.%d Writer Now Writting\\n&#34;, i);\n        sleep(SLEEP_TIME);\n        printf(&#34;No.%d Writer Now Finished\\n&#34;, i);\n        printf(&#34;No.%d Writer Now Quit\\n&#34;, i);\n\n        sem_post(&amp;write_mutex);\n        return NULL;\n}\n\nint main()\n{\n        sem_init(&amp;write_mutex, 0, 1);\n        sem_init(&amp;count_mutex, 0, 1);\n\n        pthread_t id[n];\n\n        for (int i = 0; i &lt; n/2; &#43;&#43;i) pthread_create(id&#43;i, 0, read, new int(i));\n\n        for (int i = n/2; i &lt; n; &#43;&#43;i)\n        {\n                pthread_create(id&#43;i, 0, write, new int(i));\n        }\n\n\n        for (int i = 0; i &lt; n; &#43;&#43;i) pthread_join(id[i], 0);\n\n    return 0;\n}</pre>\n<p>写者优先</p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;unistd.h&gt;\n\nconst int n = 5;\nsem_t count_mutex, write_mutex,read_mutex, write_count_mutex, first_reader_mutex;\nint readcount = 0, writecount = 0;\nconst int SLEEP_TIME = 1;\n\nvoid * read(void * args)\n{\n\tint i = *(int*)(args);\n\tsem_wait(&amp;read_mutex);\n\tsem_wait(&amp;first_reader_mutex);\n\tsem_wait(&amp;count_mutex);\n\tif(readcount ==0){\n        sem_wait(&amp;write_mutex);\n    }\n\treadcount&#43;&#43;;\n\n    printf(&#34;read count is %d\\n&#34;, readcount);\n    sem_post(&amp;count_mutex);\n    sem_post(&amp;first_reader_mutex);\n    sem_post(&amp;read_mutex);\n    \n    printf(&#34;No.%d Reader Now Reading\\n&#34;, i);\n    sleep(SLEEP_TIME);\n    printf(&#34;No.%d Reader Now Finished\\n&#34;, i);\n    sem_wait(&amp;count_mutex);\n    readcount--;\n    if(readcount == 0)\n    {\n    \tsem_post(&amp;write_mutex);\n    }\n    sem_post(&amp;count_mutex);\n}\n\nvoid * write(void * args)\n{\n\tint i = *(int*)(args);\n\tsem_wait(&amp;write_count_mutex);\n\tif(writecount == 0) sem_wait(&amp;first_reader_mutex);\n\twritecount &#43;&#43;;\n\tsem_post(&amp;write_count_mutex);\n\tsem_wait(&amp;write_mutex);\n\n\tprintf(&#34;No.%d Writer Now Writting\\n&#34;, i);\n    sleep(SLEEP_TIME);\n    printf(&#34;No.%d Writer Now Finished\\n&#34;, i);\n    printf(&#34;No.%d Writer Now Quit\\n&#34;, i);\n\tsem_post(&amp;write_mutex);\n\tsem_wait(&amp;write_count_mutex);\n\twritecount--;\n\tif(writecount == 0) sem_post(&amp;first_reader_mutex);\n\tsem_post(&amp;write_count_mutex);\n}\n\n\nint main()\n{\n\tsem_init(&amp;write_mutex, 0, 1);\n    sem_init(&amp;count_mutex, 0, 1);\n    sem_init(&amp;read_mutex, 0, 1);\n    sem_init(&amp;write_count_mutex, 0, 1);\n    sem_init(&amp;first_reader_mutex, 0, 1);\n    \n    pthread_t id[n];\n\n    for (int i = 0; i &lt; n; &#43;&#43;i) {\n    \tif(i % 2 == 0)\n    \t\tpthread_create(id&#43;i, 0, read, new int(i));\n    \telse\n    \t\tpthread_create(id&#43;i, 0, write, new int(i));\n    }\n    for (int i = 0; i &lt; n; &#43;&#43;i) pthread_join(id[i], 0);\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T06:20:04Z", "no_upvotes": 0, "uid": "i6rgda76fc66q4", "created": "2015-05-06T06:20:04Z", "type": "followup", "no_answer": 1, "id": "i9ccvaovaey1w8", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T06:24:18Z", "uid": "i6rgda76fc66q4", "created": "2015-05-06T06:24:18Z", "type": "feedback", "id": "i9cd0qgxs07ap", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p></p>\n<pre>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n\nconstexpr int n = 5;\nsem_t sem[n];\n\nvoid* func(void* arg) {\n    int i = *(int*)(arg);\n    \n    while (true) {\n        if (i % 2) {\n            sem_wait(sem &#43; i);\n            sem_wait(sem &#43; (i &#43; 1) % n);\n        } else {\n            sem_wait(sem &#43; (i &#43; 1) % n);\n            sem_wait(sem &#43; i);\n        }\n        std::cout &lt;&lt; i;\n        sem_post(sem &#43; i);\n        sem_post(sem &#43; (i &#43; 1) % n);\n    }   \n    return nullptr;\n}\n\nint main(int, char**) {\n\n    for (int i = 0; i &lt; n; &#43;&#43;i)\n        sem_init(sem &#43; i, 0, 1);\n\n    pthread_t id[n];\n\n    for (int i = 0; i &lt; n; &#43;&#43;i)\n        pthread_create(id &#43; i, 0, func, new int(i));\n    \n    for (int i = 0; i &lt; n; &#43;&#43;i)\n        pthread_join(id[i], 0);\n\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2018-05-08T00:55:18Z", "uid": "isvxeq6bspf1vn", "created": "2018-05-08T00:55:18Z", "type": "feedback", "id": "jgwyqzab4mq4zr", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p></p><pre>#define N 5\nsemaphore fork[5];\nvoid philosopher(int i ){\n    while(TRUE){\n        think();\n        P(mutex);\n        P(fork[i]);\n        P(fork[i&#43;1] %N);\n        V(mutex);\n        eat();\n        V(fork[i]);\n        V(fork[(i&#43;1) %N]);\n    }\n}</pre>\n<p>这个方法可能会有死锁&#xff0c;但我暂时没有找到&#xff0c;希望老师同学给我提醒一下</p>"}], "subject": "<p>3.</p>\n<p>哲学家进餐问题</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync03\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync03</a></p>\n<p></p>\n<p>计23 胡津铭 2012011301</p>"}, {"folders": [], "updated": "2015-05-06T06:20:08Z", "no_upvotes": 0, "uid": "i6uayov5SAo", "created": "2015-05-06T06:20:08Z", "type": "followup", "no_answer": 1, "id": "i9ccvdqzn1gip", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>4.</p>\n<p>(四)理发师问题(BarberProblem)</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync04\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync04<br /><br />计</a>23 李载隆 2012080061</p>"}, {"folders": [], "updated": "2015-05-06T06:20:37Z", "no_upvotes": 0, "uid": "i6ub691ffHe", "created": "2015-05-06T06:20:37Z", "type": "followup", "no_answer": 1, "id": "i9ccvzu0s3q28m", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>5.吸烟者问题</p>\n<p>http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync05</p>"}, {"folders": [], "updated": "2015-05-06T06:20:57Z", "no_upvotes": 0, "uid": "i6t1w87gRBD", "created": "2015-05-06T06:20:57Z", "type": "followup", "no_answer": 1, "id": "i9ccwfhwe1v6l4", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T14:29:28Z", "uid": "i6t1w87gRBD", "created": "2015-05-06T14:29:28Z", "type": "feedback", "id": "i9cucnz3hbwwf", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p></p><pre>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt; \n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;malloc.h&gt; \nusing namespace std;\n\n#define M 5\n#define N 4\n#define TIME 10\n\nsem_t AStore, BStore;\nstatic int ADecB;\n\nvoid *store(void* type)\n{\n\tint t = *((int*)type);\n\tint id = t/5;\n\tt = t%5;\n\tprintf(&#34;This thread is to store %c&#34;, &#39;A&#39;&#43;t);\n\tfor (int i = 0; i &lt; TIME; i&#43;&#43;)\n\t{\n\t\tsleep(rand()%10);\n\t\tif (t)  //B\n\t\t{\n\t\t\twhile (ADecB &gt; -M)\n\t\t\t{\n\t\t\t\tsem_wait(&amp;AStore);\n\t\t\t\tprintf(&#34;I am %c%d, now A-B = %d&#34;, &#39;B&#39;, id, ADecB);\n\t\t\t\tADecB--;\n\t\t\t\tsem_post(&amp;BStore);\n\t\t\t}\n\t\t}\n\t\telse  //A\n\t\t{\n\t\t\twhile (ADecB &lt; N)\n\t\t\t{\n\t\t\t\tsem_wait(&amp;AStore);\n\t\t\t\tprintf(&#34;I am %c%d, now A-B = %d&#34;, &#39;A&#39;, id, ADecB);\n\t\t\t\tADecB&#43;&#43;;\n\t\t\t\tsem_post(&amp;BStore);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsem_init(&amp;AStore, 0, 1);\n\tsem_init(&amp;BStore, 0, 1);\n\tpthread_t AId[5], BId[5];\n\tsrand((unsigned)time(NULL));\n\tfor (int i = 0; i &lt; 5; i&#43;&#43;)\n\t{\n\t\tpthread_create(AId&#43;i, 0, store, new int(5*i));\n\t\tpthread_create(BId&#43;i, 0, store, new int(i*5&#43;1));\n\t}\n\tfor (int i = 0; i &lt; 5; i&#43;&#43;)\n\t{\n\t\tpthread_join(AId[i], 0);\n\t\tpthread_join(BId[i], 0);\n\t}\n\treturn 0;\n}\n\n</pre>\n<p></p>"}], "subject": "<p>6.<a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync06\">第二章生产者-消费者问题扩展(一)扩展一(北大1991)</a></p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync06\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync06</a></p>\n<p>计24 王昊 2012011341</p>"}, {"folders": [], "updated": "2015-05-06T06:22:03Z", "no_upvotes": 0, "uid": "i6roqnlkmtw", "created": "2015-05-06T06:22:03Z", "type": "followup", "no_answer": 1, "id": "i9ccxuk4ean2lx", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T07:07:57Z", "uid": "i6roqnlkmtw", "created": "2015-05-06T07:07:57Z", "type": "feedback", "id": "i9cekva510244y", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p></p><pre>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n\nusing namespace std;\n\nsem_t semA;\nsem_t semB;\n\nint numA = 2;\nint numB = 2;\n\nint M = 3;\nint N = 4;\n\nvoid init(){\n    sem_init(&amp;semA, 0, 1);\n    sem_init(&amp;semB, 0, 1);\n}\n\nvoid* funcA(void* arg){\n    for(int i=0; i&lt;100; i&#43;&#43;){\n        sem_wait(&amp;semA);\n        if(numA - numB == N || numA == N){\n            sem_post(&amp;semA);\n            continue;\n        }\n        cout&lt;&lt;&#34;A in&#34;&lt;&lt;endl;\n        numA&#43;&#43;;\n        sem_post(&amp;semA);\n    }\n    return NULL;\n}\n\nvoid* funcB(void* arg){\n    for(int i=0; i&lt;100; i&#43;&#43;){\n        sem_wait(&amp;semB);\n        if(numB - numA == M || numB == N){\n            sem_post(&amp;semB);\n            continue;\n        }\n        cout&lt;&lt;&#34;B in&#34;&lt;&lt;endl;\n        numB&#43;&#43;;\n        sem_post(&amp;semB);\n    }\n    return NULL;\n}\n\nvoid* funcC(void* arg){\n    for(int i=0; i&lt;50; i&#43;&#43;){\n        sem_wait(&amp;semA);\n        sem_wait(&amp;semB);\n        if(numA == 0 || numB == 0){\n            sem_post(&amp;semA);\n            sem_post(&amp;semB);\n            continue;\n        }\n        cout&lt;&lt;&#34;C out&#34;&lt;&lt;endl;\n        numA--;\n        numB--;\n        sem_post(&amp;semA);\n        sem_post(&amp;semB);\n    }\n    return NULL;\n}\n\nint main(int argc, char const *argv[])\n{\n    init();    \n    pthread_t thread[3];\n    pthread_create(&amp;thread[0], 0, funcA, NULL);\n    pthread_create(&amp;thread[1], 0, funcB, NULL);\n    pthread_create(&amp;thread[2], 0, funcC, NULL);\n\n    for (int i = 0; i &lt; 3; &#43;&#43;i)\n        pthread_join(thread[i], 0);\n\n    return 0;\n}</pre>\n<p></p>"}], "subject": "<p>计23 李天润</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync07\">(二)扩展二(北大1995)</a></p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync07\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync07</a></p>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T06:22:21Z", "no_upvotes": 0, "uid": "hs2sszu8rbz6jj", "created": "2015-05-06T06:22:21Z", "type": "followup", "no_answer": 1, "id": "i9ccy8k0xj02ul", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>8. 进程同步问题&#xff1a;生产者-消费者-扩展三</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync08\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync08</a></p>\n<p></p>\n<p>计13 张宏辉 2011011237</p>"}, {"folders": [], "updated": "2015-05-06T06:23:07Z", "no_upvotes": 0, "uid": "i6s09f3xHOf", "created": "2015-05-06T06:23:07Z", "type": "followup", "no_answer": 1, "id": "i9ccz7mv8cs388", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>计24 李心成 2012012057</p>\n<p>10</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync10\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync10</a></p>\n<p></p>\n<pre>import time\nimport threading\nimport Queue\nimport random\n\nqueue = Queue.Queue()\t\t#thread safe\nreadThreadNum = 0\nwaitWriteThreadNum = 0\ncountMutex = threading.Lock()\nwriteMutex = threading.Lock()\nreadMutex = threading.Lock()\nwaitWriteCountMutex = threading.Lock()\ncv = threading.Condition()\n\nclass WriteThread(threading.Thread):\n\tdef __init__(self, index):\n\t\tthreading.Thread.__init__(self)\n\t\tself.mode = &#39;WRITE&#39;\n\t\tself.index = index\n\n\tdef write(self):\n\t\tglobal readThreadNum\n\t\tglobal countMutex\n\t\tglobal writeMutex\n\t\tglobal queue\n\t\tglobal waitWriteThreadNum\n\t\tglobal waitWriteCountMutex\n\t\tglobal cv\n\n\t\tisLastWriteThread = False\n\t\t#queue.put(self, True)\n\n\t\twaitWriteCountMutex.acquire()\n\t\twaitWriteThreadNum &#43;= 1\n\t\twaitWriteCountMutex.release()\n\n\t\twriteMutex.acquire()\n\n\t\twaitWriteCountMutex.acquire()\n\t\twaitWriteThreadNum -= 1\n\t\tif waitWriteThreadNum == 0:\n\t\t\tisLastWriteThread = True\n\t\twaitWriteCountMutex.release()\n\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; writing...&#39;\n\t\ttime.sleep(random.random())\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; quit&#39;\n\n\t\t#queue.get(True)\n\n\t\tif isLastWriteThread:\n\t\t\tcv.acquire()\n\t\t\tcv.notifyAll()\n\t\t\tcv.release()\n\t\telse:\n\t\t\twriteMutex.release()\n\n\tdef run(self):\n\t\tself.write()\n\nclass ReadThread(threading.Thread):\n\tdef __init__(self, index):\n\t\tthreading.Thread.__init__(self)\n\t\tself.mode = &#39;READ&#39;\n\t\tself.index = index\n\n\tdef read(self):\n\t\tglobal readThreadNum\n\t\tglobal countMutex\n\t\tglobal writeMutex\n\t\tglobal queue\n\t\tglobal waitWriteThreadNum\n\t\tglobal waitWriteCountMutex\n\t\tglobal cv\n\n\t\t#queue.put(self, True)\n\n\t\tcountMutex.acquire()\n\t\tif readThreadNum == 0 and waitWriteThreadNum == 0:\n\t\t\twriteMutex.acquire()\n\t\telif waitWriteThreadNum != 0:\n\t\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; wait after waitWriteThread&#39;\n\t\t\tcv.acquire()\n\t\t\tcv.wait()\n\t\t\tcv.release()\n\t\treadThreadNum &#43;= 1\n\t\tcountMutex.release()\n\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; reading...&#39;\n\t\ttime.sleep(random.random())\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; quit&#39;\n\n\t\t#queue.get(True)\n\t\tcountMutex.acquire()\n\t\treadThreadNum -= 1\n\t\tif readThreadNum == 0:\n\t\t\twriteMutex.release()\n\t\tcountMutex.release()\n\n\tdef run(self):\n\t\tself.read()\n\n#main test thread\ndef test():\n\tReadThread(0).start()\n\tWriteThread(1).start()\n\tWriteThread(2).start()\n\tReadThread(3).start()\n\tReadThread(4).start()\n\tReadThread(5).start()\n\n\nif __name__ == &#39;__main__&#39;:\n\ttest()</pre>\n<p>有bug&#xff0c;待修复。。。</p>"}, {"folders": [], "updated": "2015-05-06T06:23:33Z", "no_upvotes": 0, "uid": "i6t6y9snjx2", "created": "2015-05-06T06:23:33Z", "type": "followup", "no_answer": 1, "id": "i9cczrm0mvv2zx", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T14:58:50Z", "uid": "i6t6y9snjx2", "created": "2015-05-06T14:58:50Z", "type": "feedback", "id": "i9cvefwctzu2au", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>矣晓沅</p>\n<p>我做的是读写者问题的扩展一&#xff0c;这个问题在基本的读写者问题上新增了两个要求&#xff1a;一是要求平等第对待读者和写者&#xff0c;而是要求每个资源可以同时读取的线程数有限。</p>\n<p></p>\n<p>第二个要求比较简单&#xff0c;先说第二个要求吧。新增一个信号量threadReadSem&#xff0c;设置初始资源数为最大同时读取线程数。每个线程要读时&#xff0c;需要申请threadReadSem&#xff0c;读完后释放threadReadSem。当当前正在读的线程大于最大可读数时&#xff0c;新的读线程会在申请threadReadSem进入等待&#xff0c;这样就可以保证“每个资源可以同时读取的线程数有限”。</p>\n<p></p>\n<p>第二个问题稍微复杂一些。课上老师举的例子是读优先。即写需要获得WriteSemaphore。读的时候&#xff0c;第一个开始读的读者申请WriteSemaphore&#xff0c;最后一个读完的读者释放WriteSemaphore。所以写者只有等所有人读完后才能写。如何才叫“平等对待”呢&#xff1f;关于这点的理解&#xff0c;我和wiki上几个学长的观点类似&#xff0c;即&#xff1a;当前有k个读者正在读&#xff0c;若某个写着要写&#xff0c;那么写着等待这k个读者读完后开始写&#xff0c;在写着等待这k个读者的过程中&#xff0c;不再允许新的读者开始读。这样的话&#xff0c;每个写着不必等到所有读者读完&#xff0c;而只需 等已经开始读的读者读完。这种“平等”是比较合理的。</p>\n<p></p>\n<p>具体的实现上&#xff0c;和wiki上的学长有些区别。wiki上的学长是用了一个所以再设置一个排队信号量queue&#xff0c;每次读写进程要求访问文件都要在此信号量上排队&#xff0c;根据先来先得公平竟争。我的思路总体来说属于同一类&#xff0c;但是略有区别。我的思路如下&#xff1a;</p>\n<p></p>\n<p>设置一个读者增加信号量AddReadSemaphore&#xff0c;AddReadSemaphore为一个二值信号量。每个写者要写时&#xff0c;先申请AddReadSemaphore&#xff0c;写完后释放AddReadSemaphore。每个读者要读时&#xff0c;首先申请AddReadSemaphore。若申请失败&#xff0c;说明此时有写者准备要写了&#xff0c;不允许增加新的读者。只有等当前读者读完&#xff0c;等待的写者写完&#xff0c;新的读者才能获取AddReadSemaphore并开始写。若AddReadSemaphore申请成功&#xff0c;表示现在没有写者在等待写。由于AddReadSemaphore是二值信号量&#xff0c;所以不能等读完才释放&#xff0c;否则没办法同时多个读者读&#xff0c;所以读者应该在AddReadSemaphore申请成功&#xff0c;读者计数ReaderCount 加1成功后即释放&#xff0c;以便其他读者开始写。</p>\n<p></p>\n<p>具体来说&#xff0c;设计如下四个信号&#xff1a;</p>\n<p></p>\n<p>threadWriteSem 表示能否写&#xff0c;二值信号量</p>\n<p>threadCountSem 控制全局读者计数&#xff0c;二值信号量</p>\n<p>threadReadSem 表示能否度 初值为最大同时读取线程数</p>\n<p>threadAddReadSem 表示能否允许新的读者开始读&#xff0c;二值信号量</p>\n<p></p>\n<p>ReaderCount为当前正在读的线程计数</p>\n<p></p>\n<p>读写流程如下&#xff1a;</p>\n<p></p>\n<p>写者&#xff1a;</p>\n<p>申请threadAddReadSem&#xff0c;进入等待读状态&#xff0c;不再允许新的读者开始读</p>\n<p>申请threadWriteSem&#xff0c;不再允许其他读者或者写者读写</p>\n<p>临界区&#xff0c;进行写</p>\n<p>释放threadWriteSem</p>\n<p>释放threadAddReadSem</p>\n<p></p>\n<p>读者&#xff1a;</p>\n<p>申请threadAddReadSem&#xff0c;当没有写者等待写时可继续</p>\n<p>申请threadReadSem&#xff0c;当前读的线程不超最大限制数目时可继续</p>\n<p>申请threadCountSem</p>\n<p>如果ReaderCount为0&#xff0c;申请threadWriteSem&#xff0c;不允许写者再写</p>\n<p>ReaderCount加1</p>\n<p>释放threadCountSem</p>\n<p>释放threadAddReadSem</p>\n<p>临界区&#xff0c;进行读</p>\n<p>申请threadCountSem</p>\n<p>ReaderCount减1</p>\n<p>如果ReaderCount为0&#xff0c;说明当前正在读的读者都读完了&#xff0c;释放threadWriteSem&#xff0c;让等待写的写者写</p>\n<p>释放threadCountSem</p>\n<p>释放threadReadSem</p>\n<p></p>\n<p>测例如下&#xff0c;设置最大同时读线程数为2</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(0),threadCountSem,threadWriteSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(1),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(2),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(3),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(4),threadCountSem,threadWriteSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(5),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p></p>\n<p>for thread in threads:</p>\n<p>thread.start()</p>\n<p></p>\n<p>先让一个写者开始写&#xff0c;又让三个读者开始读&#xff0c;又当一个写者开始写&#xff0c;又让一个读者开始读。读写的临界区了做了1000*1000次的循环&#xff0c;确保下一个thread start时上一个start尚未执行完毕。打印输出结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread0 is waiting for writing!</p>\n<p>Thread thread0 is writing!</p>\n<p>Thread thread0 &#39;s writing finish!</p>\n<p>Thread thread1 is waiting for reading!</p>\n<p>Thread thread1 is reading! ReaderCount is 1 now</p>\n<p>Thread thread2 is waiting for reading!</p>\n<p>Thread thread2 is reading! ReaderCount is 2 now</p>\n<p>Thread thread3 is waiting for reading!</p>\n<p>Thread thread1 &#39;s reading finish! ReaderCount is 2 now</p>\n<p>Thread thread3 is reading! ReaderCount is 2 now</p>\n<p>Thread thread4 is waiting for writing!</p>\n<p>Thread thread2 &#39;s reading finish! ReaderCount is 2 now</p>\n<p>Thread thread3 &#39;s reading finish! ReaderCount is 1 now</p>\n<p>Thread thread4 is writing!</p>\n<p>Thread thread4 &#39;s writing finish!</p>\n<p>Thread thread5 is waiting for reading!</p>\n<p>Thread thread5 is reading! ReaderCount is 1 now</p>\n<p>Thread thread5 &#39;s reading finish! ReaderCount is 1 now</p>\n<p></p>\n<p>对上述结果做简要说明&#xff1a;线程0&#xff0c;4是写者&#xff0c;其余是读者&#xff0c; “is waiting for writing!”是在申请threadAddReadSem成功后打印的&#xff0c; “is waiting for reading”是在threadAddReadSem申请成功后打印的。从上述结果可看出&#xff0c;线程0写完&#xff0c;线程1开始写&#xff0c;进入临界区&#xff1b;线程二开始写&#xff0c;进入临界区&#xff1b;线程三申请threadAddReadSem成功&#xff0c;但是最大同时读线程为2&#xff0c;threadReadSem申请失败。等到1读完&#xff0c;3才进入临界区。此时4要写&#xff0c;申请threadAddReadSem成功&#xff0c;进入等待状态。5应该要开始写&#xff0c;但是4进入等待写&#xff0c;5申请threadAddReadSem失败&#xff0c;所以此时没有打印5的信息。而是看到&#xff0c;2和3都读完后&#xff0c;4进入写临界区。等4写完&#xff0c;5才开始读。</p>\n<p></p>\n<p>写者代码&#xff1a;</p>\n<p>#coding=utf-8<br />import threading  <br />import random  <br />import time  <br /><br />class Writer(threading.Thread):  <br />    &#34;&#34;&#34;class using semaphore&#34;&#34;&#34;  <br /><br />    def __init__(self,threadName,CountSem,WriteSem,AddRead):  <br />       <br />       &#34;&#34;&#34;initialize thread&#34;&#34;&#34;  <br /><br />       threading.Thread.__init__(self,name=threadName)  <br />       #self.sleepTime = random.randrange(1,6)  <br />       <br />       #set the semaphore as a data attribute of the class  <br />    &amp;nb</p>"}, {"folders": [], "updated": "2015-05-06T14:59:51Z", "uid": "i6t6y9snjx2", "created": "2015-05-06T14:59:51Z", "type": "feedback", "id": "i9cvfqflw165t1", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>self.CountSemaphore = CountSem<br />       self.WriteSemaphore = WriteSem<br />       self.AddReadSemaphore = AddRead<br /><br /><br />   <br />    def run(self):  <br />       &#34;&#34;&#34;Print message and release semaphore&#34;&#34;&#34;  <br /><br />       #acquire write mutex<br />       self.AddReadSemaphore.acquire()<br />       print &#34; Thread %s  is waiting for writing!&#34; % (self.getName()) <br />       self.WriteSemaphore.acquire() <br />       print &#34; Thread %s  is writing!&#34; % (self.getName()) <br />       for i in range(1,1000):<br />        for j in range(1,1000):<br />          (i&#43;j) % 23<br />       print &#34; Thread %s  &#39;s writing finish!&#34; % (self.getName()) <br />       <br />       #release the  write mutex  <br />       self.WriteSemaphore.release()  <br />       self.AddReadSemaphore.release()</p>"}, {"folders": [], "updated": "2015-05-06T15:00:22Z", "uid": "i6t6y9snjx2", "created": "2015-05-06T15:00:22Z", "type": "feedback", "id": "i9cvgef83osyz", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>读者代码&#xff1a;</p>\n<p>class Reader(threading.Thread):  <br />    &#34;&#34;&#34;class using semaphore&#34;&#34;&#34;  <br /><br />    def __init__(self,threadName,CountSem,WriteSem,ReadSem,AddRead):  <br /><br />      &#34;&#34;&#34;initialize thread&#34;&#34;&#34;  <br /><br /><br />      threading.Thread.__init__(self,name=threadName)  <br />      #self.sleepTime=random.randrange(1,6) <br />      #self.sleepTime = random.randrange(1,6)  <br />       <br />      #set the semaphore as a data attribute of the class  <br />       <br />      self.CountSemaphore = CountSem<br />      self.WriteSemaphore = WriteSem<br />      self.ReadSemaphore = ReadSem<br />      self.AddReadSemaphore = AddRead<br /><br />    def run(self):<br />      #acquire write mutex<br />      global ReaderCount<br />      self.AddReadSemaphore.acquire()<br />      print &#34; Thread %s  is waiting for  reading!&#34; % (self.getName()) <br />      self.ReadSemaphore.acquire()<br />      <br />      self.CountSemaphore.acquire() <br />      if ReaderCount == 0:<br />        self.WriteSemaphore.acquire()<br />      <br />      ReaderCount = ReaderCount &#43; 1<br /><br />      self.CountSemaphore.release()<br />      self.AddReadSemaphore.release()<br /><br /><br /><br />      print &#34; Thread %s  is reading! ReaderCount is %d now&#34; % (self.getName(),ReaderCount)<br />      for i in range(1,1000):<br />        for j in range(1,1000):<br />          (i&#43;j) % 23<br />      print &#34; Thread %s  &#39;s reading finish! ReaderCount is %d now&#34; % (self.getName(),ReaderCount)<br /><br />      self.CountSemaphore.acquire()<br />      ReaderCount = ReaderCount - 1<br />      if (ReaderCount == 0):<br />          self.WriteSemaphore.release(); <br />      #release the  write mutex  <br />      self.CountSemaphore.release()  <br />      self.ReadSemaphore.release()</p>"}, {"folders": [], "updated": "2015-05-15T08:20:01Z", "uid": "i6t6y9snjx2", "created": "2015-05-15T08:20:01Z", "type": "feedback", "id": "i9pc48boob36qx", "anon": "no", "bucket_name": "Week 5/10 - 5/16", "config": {}, "bucket_order": 161, "data": null, "children": [], "subject": "<p>按向老师的建议&#xff0c;在Reader和Writer的构造函数里加入了读/写时间的参数设置&#xff0c;已控制读者写者的读写顺序。新的测试用例及结果说明如下&#xff1a;</p>\n<p>github的地址是&#xff1a;<a href=\"https://github.com/MtMoon/os_exercises/blob/master/all/ReaderWriteProblem/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%8F%8A%E7%BB%93%E6%9E%9C.md\">https://github.com/MtMoon/os_exercises/blob/master/all/ReaderWriteProblem/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%8F%8A%E7%BB%93%E6%9E%9C.md</a></p>\n<p></p>\n<p></p>\n<p>信号量说明&#xff1a;</p>\n<p></p>\n<p>threadWriteSem 表示能否写&#xff0c;二值信号量&#xff0c;用于读写互斥控制</p>\n<p>threadCountSem 控制全局读者计数&#xff0c;二值信号量</p>\n<p>threadReadSem 表示能否读 初值为最大同时读取线程数&#xff0c;用于最大同时读线程数目控制</p>\n<p>threadAddReadSem 表示能否允许新的读者开始读&#xff0c;二值信号量&#xff0c;用于写者等待是锁定</p>\n<p></p>\n<p></p>\n<p>*1.* 测试最大同时读者数限制</p>\n<p></p>\n<p>设定最大同时读者数为2&#xff0c;测例如下&#xff0c;其中&#xff0c;Reader构造函数的3是读时间设置&#xff0c;设为3秒</p>\n<p></p>\n<p>threads.append( Reader(&#34;thread&#34;&#43;str(1), threadCountSem, threadWriteSem, threadReadSem, threadAddReadSem, 3) )</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(2),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem,3 ))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(3),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem,3))</p>\n<p></p>\n<p>运行结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread1 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread1 is waiting for ReadSemaphore!</p>\n<p>Thread thread2 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread3 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread1 is waiting for WriteSemaphore!</p>\n<p>Thread thread1 is reading! ReaderCount is 1 now</p>\n<p>Thread thread2 is waiting for ReadSemaphore!</p>\n<p>Thread thread2 is reading! ReaderCount is 2 now(1)</p>\n<p>Thread thread3 is waiting for ReadSemaphore!(2)</p>\n<p>Thread thread2 &#39;s reading finish!(3)</p>\n<p>Thread thread3 is reading! ReaderCount is 2 now(4)</p>\n<p>Thread thread1 &#39;s reading finish!</p>\n<p>Thread thread3 &#39;s reading finish!</p>\n<p></p>\n<p></p>\n<p>测试结果说明&#xff1a;从上述测试结果可以看到&#xff0c;线程1,2正在读时&#xff0c;(1)处可以看到ReadCount为2&#xff0c;表面现在有两个读者同时读&#xff0c;而(2)处的读者3只能等在ReadSemaphore信号量上&#xff0c;直到(3)处有一个读者读完&#xff0c;(4)处的读者三才能开始读</p>\n<p></p>\n<p>*2.* 测试写者互斥</p>\n<p></p>\n<p>测试用例如下&#xff1a;</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(0),threadCountSem,threadWriteSem,threadAddReadSem,5))</p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(1),threadCountSem,threadWriteSem,threadAddReadSem,5))</p>\n<p></p>\n<p>输出结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread0 is waiting for writing!</p>\n<p>Thread thread0 is writing!</p>\n<p>Thread thread0 &#39;s writing finish!</p>\n<p>Thread thread1 is waiting for writing!</p>\n<p>Thread thread1 is writing!</p>\n<p>Thread thread1 &#39;s writing finish!</p>\n<p></p>\n<p>可以看到两个写者不同同时进入临界区&#xff0c;只有前一个finish后一个才开始写。</p>\n<p></p>\n<p></p>\n<p>*3.* 测试写者写时读者不能读且写者不能被读者打断(读写互斥)</p>\n<p></p>\n<p>测试用例如下&#xff0c;先后启动一个读者和一个写者&#xff0c;写者写时间设定为5s</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(0),threadCountSem,threadWriteSem,threadAddReadSem,5))</p>\n<p>threads.append( Reader(&#34;thread&#34;&#43;str(1), threadCountSem, threadWriteSem, threadReadSem, threadAddReadSem, 3) )</p>\n<p></p>\n<p>结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread0 is waiting for writing!</p>\n<p>Thread thread0 is writing!</p>\n<p>Thread thread1 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread0 &#39;s writing finish!</p>\n<p>Thread thread1 is waiting for ReadSemaphore!</p>\n<p>Thread thread1 is waiting for WriteSemaphore!</p>\n<p>Thread thread1 is reading! ReaderCount is 1 now</p>\n<p>Thread thread1 &#39;s reading finish!</p>\n<p></p>\n<p>测试结果说明&#xff1a;写者0开始写之后&#xff0c;读者1进入了run()函数&#xff0c;但是写者写时&#xff0c;锁定了AddReadSemaphore信号量&#xff0c;读者无法开始读&#xff0c;自导写者写完&#xff0c;读者才能相继获得其他信号量开始读。</p>\n<p></p>\n<p>*4.* 测试写者申请写时&#xff0c;新的读者不能再加入</p>\n<p></p>\n<p>测试用例如下&#xff1a;</p>\n<p></p>\n<p>threads.append( Reader(&#34;thread&#34;&#43;str(1), threadCountSem, threadWriteSem, threadReadSem, threadAddReadSem, 5) )</p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(2),threadCountSem,threadWriteSem,threadAddReadSem,3))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(3),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem,3 ))</p>\n<p></p>\n<p>先启动一个读者1&#xff0c;读者1正在读时启动一个写者2&#xff0c;写者2申请写&#xff0c;再启动一个读者3.输出结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread1 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread1 is waiting for ReadSemaphore!</p>\n<p>Thread thread1 is waiting for WriteSemaphore!</p>\n<p>Thread thread1 is reading! ReaderCount is 1</p>"}, {"folders": [], "updated": "2015-05-15T15:06:11Z", "uid": "hdjonbiyfs62ie", "created": "2015-05-15T15:06:11Z", "type": "feedback", "id": "i9pqmjzgoah2f", "anon": "no", "bucket_name": "Week 5/10 - 5/16", "config": {}, "bucket_order": 161, "data": null, "children": [], "subject": "<p>这个测试用例设计是很好的&#xff0c;可以发现算法的可能错误。建议其他同学仿照这里的做法&#xff0c;测试自己的同学算法。</p>"}], "subject": "<p>9 读者写者问题扩展&#xff08;一&#xff09;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync09\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync09</a></p>\n<p></p>\n<p>计25 矣晓沅 2012011364</p>"}, {"folders": [], "updated": "2015-05-06T06:34:28Z", "no_upvotes": 0, "uid": "i6vkh2uqu3V", "created": "2015-05-06T06:34:28Z", "type": "followup", "no_answer": 1, "id": "i9cddt2yxox6c9", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T09:47:58Z", "uid": "i6vkh2uqu3V", "created": "2015-05-06T09:47:58Z", "type": "feedback", "id": "i9ckanzmlwb3fs", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p></p><pre>package test;\n\nimport java.util.Random;\nimport java.util.concurrent.Semaphore;\n\n\npublic class question11 {\n\t\n    public static void main(String[] args) {\n    \tSemaphore sem_seller = new Semaphore(1);\n    \tSemaphore sem_goods1 = new Semaphore(0);\n\t\tSemaphore sem_goods2 = new Semaphore(0);\n\t\tSemaphore sem_goods3 = new Semaphore(0);\n\n\t\tseller a = new seller(sem_seller, sem_goods1, sem_goods2, sem_goods3);\n    \tlistener listener1 = new listener(&#34;group one&#34;,0, sem_seller, sem_goods1);\n    \tlistener listener2 = new listener(&#34;group two&#34;,1, sem_seller, sem_goods2);\n    \tlistener listener3 = new listener(&#34;group three&#34;,2, sem_seller, sem_goods3);\n    \t\n    \ta.start();\n    \tlistener1.start();\n    \tlistener2.start();\n    \tlistener3.start();\n    \t\n    }\n}\nclass seller extends Thread{\n\tSemaphore sem_seller;\n\tSemaphore sem_goods1;\n\tSemaphore sem_goods2;\n\tSemaphore sem_goods3;\n\tseller(Semaphore sem_seller,Semaphore sem_goods1, Semaphore sem_goods2,Semaphore sem_goods3){\n\t\tthis.sem_seller = sem_seller;\n\t\tthis.sem_goods1 = sem_goods1;\n\t\tthis.sem_goods2 = sem_goods2;\n\t\tthis.sem_goods3 = sem_goods3;\n\t}\n\t\n\tpublic void run(){\n\t\twhile(true){\n\t\t\ttry {\n\t\t\t\tthis.sem_seller.acquire();\n\t\t\t\tint max=3;\n\t\t        int min=0;\n\t\t        Random random = new Random();\n\t\t        int s = random.nextInt(max)%(max-min&#43;1) &#43; min;\n\t\t        System.out.println(&#34;-------------Seller-------------&#34;);\n\t            if(s == 0){\n\t            \tSystem.out.println(&#34;Sell Tape, Battery&#34;);\n\t                this.sem_goods1.release();\n\t            }\n\t            if(s == 1){\n\t            \tSystem.out.println(&#34;Sell Walkman, Battery&#34;);\n\t                this.sem_goods2.release();\n\t            }\n\t            if(s == 2){\n\t            \tSystem.out.println(&#34;Sell Walkman, Tape&#34;);\n\t                this.sem_goods3.release();\n\t            }\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass listener extends Thread{\n\tint need;\n\tSemaphore sem_seller;\n\tSemaphore sem_goods;\n\tString name;\n\tlistener(String name,int need,Semaphore sem_seller,Semaphore sem_goods){\n\t\t this.need = need;\n\t\t this.sem_seller = sem_seller;\n\t\t this.name = name;\n\t     this.sem_goods = sem_goods;\n\t}\n\tpublic void run(){\n\t\twhile(true){\n            try {\n\t            this.sem_goods.acquire();\n\t\t    if (need == 0){\n\t\t\tSystem.out.println(&#34;-------------&#34; &#43; this.name &#43; &#34;-------------&#34;);\n\t\t\tSystem.out.println(&#34;Buy Tape, Battery.&#34;);\n\t\t    }\n\t            if(need == 1){\n\t            \tSystem.out.println(&#34;-------------&#34; &#43; this.name &#43; &#34;-------------&#34;);\n\t            \tSystem.out.println(&#34;Buy Walkman, Battery.&#34;);\n\t            }\n\t            if(need == 2){\n\t            \tSystem.out.println(&#34;-------------&#34; &#43; this.name &#43; &#34;-------------&#34;);\n\t            \tSystem.out.println(&#34;Buy Walkman, Tape.&#34;);\n\t            }\n\t            sleep(2);\n\t            this.sem_seller.release();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-11T05:41:19Z", "uid": "i6vkh2uqu3V", "created": "2015-05-11T05:41:19Z", "type": "feedback", "id": "i9jgoqbg32w6tk", "anon": "no", "bucket_name": "Week 5/10 - 5/16", "config": {}, "bucket_order": 161, "data": null, "children": [], "subject": "<p>-------------Seller-------------<br />Sell Walkman, Tape<br />-------------group three-------------<br />Buy Walkman, Tape.<br />-------------Seller-------------<br />Sell Walkman, Battery<br />-------------group two-------------<br />Buy Walkman, Battery.<br />-------------Seller-------------<br />Sell Tape, Battery<br />-------------group one-------------<br />Buy Tape, Battery.<br />-------------Seller-------------<br />Sell Walkman, Tape<br />-------------group three-------------<br />Buy Walkman, Tape.<br />-------------Seller-------------<br />Sell Tape, Battery<br />-------------group one-------------<br />Buy Tape, Battery.<br />-------------Seller-------------<br />Sell Walkman, Tape<br />-------------group three-------------<br />Buy Walkman, Tape.</p>"}], "subject": "<p>11.进程同步问题&#xff1a;吸烟者问题拓展一 &#xff08;北大1999&#xff09;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync11\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync11</a></p>\n<p></p>\n<p>计22 滕爽 2012011270</p>"}, {"folders": [], "updated": "2015-05-06T06:35:59Z", "no_upvotes": 0, "uid": "i6uaz13iyeM", "created": "2015-05-06T06:35:59Z", "type": "followup", "no_answer": 1, "id": "i9cdfracelt7g6", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>12. 电影院问题&#xff08;吸烟者问题扩展2&#xff09;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync12\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync12</a></p>\n<p></p>\n<p>计25 董欣 2012011361</p>"}, {"folders": [], "updated": "2015-05-06T06:48:39Z", "no_upvotes": 0, "uid": "i7oaxkxhxjo3ui", "created": "2015-05-06T06:48:39Z", "type": "followup", "no_answer": 1, "id": "i9cdw24pn323y5", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>罗鸿胤 2012011319</p>\n<p></p>\n<p>29. 阅览室问题 有一个阅览室&#xff0c;共有100个座位&#xff0c;读者进入时必须先在一张登记表上登记&#xff0c;该表为每一个座位列一表目&#xff0c;包括座号和读者姓名等&#xff0c;读者离开时要消掉登记的信息&#xff0c;试问&#xff1b;</p>\n<p></p>\n<p>(1)为描述读者的动作&#xff0c;应编写几个程序&#xff0c;设置几个进程&#xff1f;</p>\n<p>编写一个程序&#xff0c;用锁描述登记表&#xff0c;用线程描述人&#xff0c;因此一个程序&#xff0c;一个进程即可</p>\n<p></p>\n<p>(2)试用PV操作描述各个进程之间的同步互斥关系。</p>\n<p></p>\n<pre>#coding=utf-8\nimport threading\nimport random\nimport time\n\nmutex = threading.Lock()\n\nclass TableThread(threading.Thread):\n\n    availableTables = range(100)\n\n    def __init__(self,threadName,semaphore):\n        &#34;&#34;&#34;initialize thread&#34;&#34;&#34;\n        threading.Thread.__init__(self,name = threadName)\n        self.sleepTime=random.randrange(1,6)\n        #set the semaphore as a data attribute of the class\n        self.threadSemaphore = semaphore\n    def run(self):\n        &#34;&#34;&#34;Print message and release semaphore&#34;&#34;&#34;\n\n        #acquire the semaphore\n        if mutex.acquire():\n            print &#34;%s is using the check area&#34; %(self.getName())\n            print &#34;%s is leaving the check area&#34; %(self.getName())\n            mutex.release()\n            self.threadSemaphore.acquire()\n            #remove a table from the list\n            table = TableThread.availableTables.pop()\n            print &#34;%s entered;seated at table %s.&#34; %(self.getName(),table),\n            print len(TableThread.availableTables)\n            time.sleep(self.sleepTime)\n            if mutex.acquire():\n                #free a table\n                print &#34;%s is using the check area&#34; %(self.getName())\n                print &#34;%s exiting;freeing table %s.&#34; %(self.getName(),table),\n                TableThread.availableTables.append(table)\n                print len(TableThread.availableTables)\n                #release the semaphore after execution finishes\n                self.threadSemaphore.release()\n                print &#34;%s is leaving the check area&#34; %(self.getName())\n                mutex.release()\n\nthreads = [] #list of threads\n#semaphore allows five threads to enter critical section\n#checkSemaphore = threading.Semaphore(len(CheckThread.availableCheck))\ntableSemaphore = threading.Semaphore(len(TableThread.availableTables))\n#创建一个threading.Semaphore对象&#xff0c;他最多允许5个线程访问临界区。\n#Semaphore类的一个对象用计数器跟踪获取和释放信号量的线程数量。\n#create ten threads\nfor i in range(1,11):\n    #threads.append([CheckThread(&#34;thread&#34;&#43;str(i),checkSemaphore),TableThread(&#34;thread&#34; &#43; str(i),tableSemaphore)])\n    threads.append(TableThread(&#34;thread&#34; &#43; str(i),tableSemaphore))\n#创建一个列表&#xff0c;该列表由SemaphoreThread对象构成&#xff0c;start方法开始列表中的每个线程\n#start each thread\nfor thread in threads:\n    thread.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T06:57:47Z", "no_upvotes": 0, "uid": "i6tezdpdQbq", "created": "2015-05-06T06:57:47Z", "type": "followup", "no_answer": 1, "id": "i9ce7stq2fwt9", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>周昊 2012011326</p>\n<p>11.在一间酒吧里有三个音乐爱好者队列&#xff0c;第一队的音乐爱好者只有随身听&#xff0c;第二队的只有音乐磁带&#xff0c;第三队只有电池。而要听音乐就必须随身听&#xff0c;音乐磁带和电池这三种物品俱全。酒吧老板依次出售这三种物品中的任意两种。当一名音乐爱好者得到这三种物品并听完一首乐曲后&#xff0c;酒吧老板才能再一次出售这三种物品中的任意两种。于是第二名音乐爱好者得到这三种物品&#xff0c;并开始听乐曲。全部买卖就这样进行下去。试用P&#xff0c;V操作正确解决这一买卖。</p>\n<p></p>\n<p>code-semaphore</p>\n<pre>#coding=utf-8\n#semaphore\nimport threading  \nimport random  \nimport time  \n\nclass Producer(threading.Thread):\n    goods = [1, 2, 3]\n\n    def __init__(self, threadName, semaphore0, semaphore1, semaphore2, semaphore3):\n        threading.Thread.__init__(self,name=threadName)  \n        self.semaphore0 = semaphore0\n        self.semaphore1 = semaphore1\n        self.semaphore2 = semaphore2\n        self.semaphore3 = semaphore3\n\n    def run(self):\n        while True:\n            self.semaphore0.acquire()\n            good = random.randrange(1, 4)\n            if good == 1:\n                print &#39;Produce Tape, Battery&#39;\n                self.semaphore1.release()\n            elif good == 2:\n                print &#39;Produce Walkman, Battery&#39;\n                self.semaphore2.release()\n            else:\n                print &#39;Produce Walkman, Tape&#39;\n                self.semaphore3.release()\n\nclass Listener(threading.Thread):\n    \n    def __init__(self, threadName, need, semaphore0, semaphore):\n        threading.Thread.__init__(self,name=threadName)  \n        self.need = need\n        self.semaphore0 = semaphore0\n        self.semaphore = semaphore\n        \n    def run(self):\n        while True:\n            self.semaphore.acquire()\n            if self.need == 1:\n                print self.getName()&#43;&#39;: Buy Tape, Battery. Listening&#39;\n            elif self.need == 2:\n                print self.getName()&#43;&#39;: Buy Walkman, Battery. Listening&#39;\n            else:\n                print self.getName()&#43;&#39;: Buy Walkman, Tape. Listening&#39;\n            time.sleep(2)\n            self.semaphore0.release()\n            \n\nthreads=[]\nsemaphore0 = threading.Semaphore(1)\nsemaphore1 = threading.Semaphore(0)\nsemaphore2 = threading.Semaphore(0)\nsemaphore3 = threading.Semaphore(0)\n\nthreads.append(Producer(&#34;Producer&#34;, semaphore0, semaphore1, semaphore2, semaphore3))\nthreads.append(Listener(&#34;Listener1&#34;, 1, semaphore0, semaphore1))\nthreads.append(Listener(&#34;Listener2&#34;, 2, semaphore0, semaphore2))\nthreads.append(Listener(&#34;Listener3&#34;, 3, semaphore0, semaphore3))\n\nfor thread in threads: \n   thread.start() </pre>\n<p>code-condition</p>\n<pre>#coding=utf-8<br />#condition<br />import threading  <br />import random  <br />import time  <br /><br />condition = threading.Condition()<br />product = 0<br />class Producer(threading.Thread):<br />    goods = [1, 2, 3]<br /><br />    def __init__(self, threadName):<br />        threading.Thread.__init__(self,name=threadName)  <br />        <br />    def run(self):<br />        global condition, product<br />        while True:<br />            if condition.acquire():<br />                if product == 0:<br />                    product = random.randrange(1, 4)<br />                    if product == 1:<br />                        print &#39;Produce Tape, Battery&#39;<br />                    elif product == 2:<br />                        print &#39;Produce Walkman, Battery&#39;<br />                    else:<br />                        print &#39;Produce Walkman, Tape&#39;<br />                    condition.notifyAll()<br />                else:<br />                    condition.wait()<br />                condition.release()<br />                <br />class Listener(threading.Thread):<br />    <br />    def __init__(self, threadName, need):<br />        threading.Thread.__init__(self,name=threadName)  <br />        self.need = need<br />               <br />    def run(self):<br />        global condition, product<br />        while True:<br />            if condition.acquire():<br />                if product == self.need:<br />                    if self.need == 1:<br />                        print self.getName()&#43;&#39;: Buy Tape, Battery. Listening&#39;<br />                    elif self.need == 2:<br />                        print self.getName()&#43;&#39;: Buy Walkman, Battery. Listening&#39;<br />                    else:<br />                        print self.getName()&#43;&#39;: Buy Walkman, Tape. Listening&#39;<br />                    product = 0<br />                    time.sleep(2)<br />                    condition.notifyAll()<br />                else:<br />                    condition.wait()<br />                condition.release()<br /><br />threads=[]<br />semaphore0 = threading.Semaphore(1)<br />semaphore1 = threading.Semaphore(0)<br />semaphore2 = threading.Semaphore(0)<br />semaphore3 = threading.Semaphore(0)<br /><br />threads.append(Producer(&#34;Producer&#34;))<br />threads.append(Listener(&#34;Listener1&#34;, 1))<br />threads.append(Listener(&#34;Listener2&#34;, 2))<br />threads.append(Listener(&#34;Listener3&#34;, 3))<br /><br />for thread in threads: <br />   thread.start() </pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:00:58Z", "no_upvotes": 0, "uid": "i71fykcui1h2je", "created": "2015-05-06T07:00:58Z", "type": "followup", "no_answer": 1, "id": "i9cebw0pnu2538", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>章浚源 第7题</p>\n<p></p>\n<p>见github&#xff1a;</p>\n<p><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-condition.py\">https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-condition.py</a></p>\n<p><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-semaphore.py\">https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-semaphore.py</a></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:03:28Z", "no_upvotes": 0, "uid": "i6un4iacNGX", "created": "2015-05-06T07:03:28Z", "type": "followup", "no_answer": 1, "id": "i9cef47uf316tr", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T08:57:10Z", "uid": "i6un4iacNGX", "created": "2015-05-06T08:57:10Z", "type": "feedback", "id": "i9cihbkkdyr6te", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>信号量方法&#xff1a; <a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py\">https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py</a><a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py\" target=\"_blank\"></a></p>\n<p>condition方法&#xff1a;<a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/condition.py\" target=\"_blank\">https://github.com/Azalea94/os_exercises/blob/master/all/related/condition.py</a></p>"}], "subject": "<p>生产流水线问题 设自行车生产线上有一只箱子&#xff0c;其中有N 个位置( N ≥3)&#xff0c;每个位置可存放一个车架或一个车轮; 又设有三个工人&#xff0c;其活动分别为: 工人1活动: do{ 加工一个车架; 车架放入箱中; }while(1) 工人2活动&#xff1a; do{ 加工一个车轮; 车轮放入箱中; }while(1) 工人1活动&#xff1a; do{ 箱中取一个车架; 箱中取两个车轮; 组装为一台车; }while(1) 试分别用信号灯与PV 操作实现三个工人的合作&#xff0c;要求解中不含死锁。</p>\n<p>杜鹃  2012011354 第39题</p>\n<p></p>\n<pre>#coding=utf-8\n#!/usr/bin/env python\n  \nimport threading  \nimport time  \n   \ncondition1 = threading.Condition()  \n\ncondition2 = threading.Condition()  \nproducts1 = 0  \nproducts2 = 0  \nN = 10\n\nclass Producer1(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global condition1, products1 \n        while True:  \n            if condition1.acquire():  \n                if products1 &lt; N - 1:  \n                    products1 &#43;= 1;  \n                    print &#34;Producer1(%s):deliver one1, now products:%s&#34; %(self.name, products1) \n                    print &#34;&#34; \n                    condition1.notify()  \n                else:  \n                    print &#34;Producer1(%s):already 9, stop deliver, now products:%s&#34; %(self.name, products1)  \n                    condition1.wait();  \n                condition1.release()  \n                time.sleep(2)  \n\nclass Producer2(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global condition2, products2  \n        while True:  \n            if condition2.acquire():  \n                if products2 &lt; N-2:  \n                    products2 &#43;= 1;  \n                    print &#34;Producer2(%s):deliver one2, now products:%s&#34; %(self.name, products2)  \n                    print &#34;&#34;\n                    condition2.notify()  \n                else:  \n                    print &#34;Producer2(%s):already 8, stop deliver, now products:%s&#34; %(self.name, products2)  \n                    condition2.wait();  \n                condition2.release()  \n                time.sleep(2)           \nclass Consumer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global condition1, condition2, products1,products2\n        while True:  \n            if condition1.acquire():  \n                if products1 &gt; 1:  \n                    products1 -= 1 \n                    print &#34;Consumer(%s):consume frame, now products1:%s, products2:%s&#34; %(self.name, products1,products2)  \n                    condition1.notify()\n                else:\n                    print &#34;Consumer(%s): stop consume frame, products1:%s,products2:%s&#34; %(self.name, products1,products2)  \n                    condition1.wait();  \n                condition1.release()\n                time.sleep(2) \n            if condition2.acquire():\n                if products2 &gt; 2:\n                    products2-=2\n                    print &#34;Consumer(%s):consume wheels and create a car, now products1:%s, products2:%s&#34; %(self.name, products1,products2)  \n                    condition2.notify()\n                else:\n                    print &#34;Consumer(%s): stop consume wheels, products1:%s,products2:%s&#34; %(self.name, products1,products2)  \n                    condition2.wait();  \n                condition2.release() \n                time.sleep(2)  \n                  \nif __name__ == &#34;__main__&#34;:  \n    p1 = Producer1()\n    p1.start()\n    p2 = Producer2()\n    p2.start()\n    c = Consumer()\n    c.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:04:09Z", "no_upvotes": 0, "uid": "i7bg4v1keqE", "created": "2015-05-06T07:04:09Z", "type": "followup", "no_answer": 1, "id": "i9cefzrs4853e7", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p></p>\n<ol><li>第20题</li><li>\n<p>两人公用一个账号&#xff0c;每次限存或取10元&#xff1b;</p>\n<pre>&lt;code&gt;begin\nvar mutex=1:semaphore;\namount =0:integer;\ncobegin\n  process save\n    m1: integer;\n    begin\n    repeat\n    p(mutex);\n    m1= amount ;\n    m1 = m1 &#43;10;\n    amout = m1;\n    v(mutex);\n    end\n  process take\n    m2: integer;\n    begin\n    repeat;\n    p(mutex);\n    m2= amount ;\n    m2 = m2 -10;\n    amout = m2;\n    v(mutex);\n    end\ncoend\n&lt;/code&gt;</pre>\n</li></ol>\n<p>output&#xff1a;</p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/semaphone-output.txt\">https://github.com/yanwang9411/os_exercises/blob/master/semaphone-output.txt</a></p>\n<p></p>\n<p></p>\n<p>implemention&#xff1a;</p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/condition.py\">https://github.com/yanwang9411/os_exercises/blob/master/condition.py</a></p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/semaphore.py\">https://github.com/yanwang9411/os_exercises/blob/master/semaphore.py</a></p>\n<p></p>\n<p></p>\n<p>2012011352 计24 王妍</p>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:06:44Z", "no_upvotes": 0, "uid": "i6uayl3vEOz", "created": "2015-05-06T07:06:44Z", "type": "followup", "no_answer": 1, "id": "i9cejazzpo77mc", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>第15题</p>\n<p>在南开大学至天津大学间有一条弯曲的路&#xff0c;每次只允许一辆自行车通过&#xff0c;但中间有小的安全岛M&#xff08;同时允许两辆车&#xff09;&#xff0c;可供两辆车在已进入两端小车错车&#xff0c;设计算法并使用P&#xff0c;V实现。</p>\n<p></p>\n<p></p>\n<p>信号量</p>\n<pre>#coding=utf-8<br />import threading <br />import random <br />import time\ndef BikeT2N():<br /> name = threading.currentThread().getName()<br /> T2N.acquire()<br /> print &#34;%s get into road\\n&#34; % name<br /> L.acquire()<br /> print &#34;%s get into L&#34; % name<br /> M.acquire()<br /> print &#34;%s get into M&#34; % name<br /> L.release()<br /> K.acquire()<br /> print &#34;%s get into K&#34; % name<br /> M.release()<br /> print &#34;%s get out of M&#34; % name<br /> K.release()<br /> T2N.release()<br /> print &#34;%s get out of road\\n&#34; % name<br />def BikeN2T():<br /> name = threading.currentThread().getName()<br /> N2T.acquire()<br /> print &#34;%s get into road\\n&#34; % name<br /> K.acquire()<br /> print &#34;%s get into k&#34; % name<br /> M.acquire()<br /> print &#34;%s get into M&#34; % name<br /> K.release()<br /> L.acquire()<br /> M.release()<br /> print &#34;%s get out of M&#34; % name<br /> L.release()<br /> print &#34;%s get out of M&#34; % name<br /> N2T.release()<br /> print &#34;%s get out of road\\n&#34; % name\nif __name__ == &#39;__main__&#39;:<br /> threads = []<br /> T2N = threading.Semaphore(1)<br /> N2T = threading.Semaphore(1)<br /> L = threading.Semaphore(1)<br /> K = threading.Semaphore(1)<br /> M = threading.Semaphore(2)<br /> for i in xrange(10):<br /> if i%2 == 0:<br /> thread = threading.Thread(target = BikeT2N, name=&#34;bikeT2N&#34;&#43;str(i/2))<br /> thread.start()<br /> threads.append(thread)<br /> else:<br /> thread = threading.Thread(target = BikeN2T, name=&#34;bikeN2T&#34;&#43;str(i))<br /> thread.start()<br /> threads.append(thread)<br /> for item in threads:<br /> item.join()</pre>\n<p></p>\n<p>条件变量</p>\n<pre>import threading\nT2N_num = 0<br />N2T_num = 0<br />M_num = 0\ndef BikeT2N():<br /> global T2N_num,N2T_num,M_num<br /> name = threading.currentThread().getName()<br /> T2Ncond.acquire()<br /> if T2N_num == 1:<br /> T2Ncond.wait()<br /> T2N_num &#43;= 1<br /> print &#34;%s get into T\\n&#34; % name<br /> Mcond.acquire()<br /> if M_num == 2:<br /> Mcond.wait()<br /> M_num &#43;= 1<br /> print &#34;%s get into M\\n&#34; % name<br /> Mcond.release()<br /> T2N_num -= 1<br /> T2Ncond.notify()<br /> T2Ncond.release()<br /> print &#34;%s get out of T\\n&#34; % name<br /> Mcond.acquire()<br /> assert(M_num &gt;0)<br /> M_num -= 1<br /> Mcond.notify()<br /> Mcond.release()<br /> print &#34;%s get out of M\\n&#34; % name<br /> #print &#34;vars : %d %d %d&#34; % (T2N_num, N2T_num, M_num)<br /> N2Tcond.acquire()<br /> if N2T_num == 1:<br /> N2T_num.wait()<br /> N2T_num &#43;= 1\nprint &#34;%s get into N\\n&#34; % name<br /> N2T_num -= 1<br /> N2Tcond.notify()<br /> N2Tcond.release()<br /> print &#34;%s get out of N\\n&#34; % name\n<br />def BikeN2T():<br /> global T2N_num,N2T_num,M_num<br /> name = threading.currentThread().getName()<br /> N2Tcond.acquire()<br /> if N2T_num == 1:<br /> N2Tcond.wait()<br /> N2T_num &#43;= 1<br /> print &#34;%s get into N\\n&#34; % name<br /> Mcond.acquire()<br /> if M_num == 2:<br /> Mcond.wait()<br /> M_num &#43;= 1<br /> print &#34;%s get into M\\n&#34; % name<br /> Mcond.release()<br /> N2T_num -= 1<br /> N2Tcond.notify()<br /> N2Tcond.release()<br /> print &#34;%s get out of N\\n&#34; % name<br /> Mcond.acquire()<br /> assert(M_num&gt;0)<br /> M_num -= 1<br /> Mcond.notify()<br /> Mcond.release()<br /> print &#34;%s get into M\\n&#34; % name<br /> T2Ncond.acquire()<br /> if T2N_num == 1:<br /> T2N_num.wait()<br /> T2N_num &#43;= 1<br /> <br /> print &#34;%s get into T\\n&#34; % name<br /> T2N_num -= 1<br /> T2Ncond.notify()<br /> T2Ncond.release()<br /> print &#34;%s get out of T\\n&#34; % name\n<br />if __name__ == &#39;__main__&#39;:<br /> T2Ncond = threading.Condition()<br /> N2Tcond = threading.Condition()<br /> Mcond = threading.Condition()<br /> threads = []<br /> for i in xrange(10):<br /> if i%2 == 0:<br /> thread = threading.Thread(target=BikeT2N, name=&#34;thread&#34;&#43;str(i))<br /> thread.start()<br /> threads.append(thread)<br /> else:<br /> thread = threading.Thread(target=BikeN2T, name=&#34;thread&#34;&#43;str(i))<br /> thread.start()<br /> threads.append(thread)<br /> for item in threads:<br /> item.join()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:07:23Z", "no_upvotes": 0, "uid": "i6ut6cjo5lj4aa", "created": "2015-05-06T07:07:23Z", "type": "followup", "no_answer": 1, "id": "i9cek5imoppr9", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>第36题  计21班   韦福超  2012011392</p>\n<pre><code>var\ns, Sa.Sb, mutexa, mutexb: semaphore;\ns: = mutexa &#xff1a;=mutexb: = 1;\nsa: = sb: = 0;\nbox: (PaPer, Pen);\ncobegin\n    process 保管员\n        begin\n            repeat\n            P(S);\n            take a material intobox ;\n            if (box)=Paper then V(Sa);\n            else V(Sb);\n            untile false ;\n        end\n\nProcess A组学生\n    begin\n        repeat\n        P(Sa);\n        P(mutexa);\n        take the pen from box ;\n        V(mutexa);\n        V(S);\n        write a letter;\n        untile false ;\n    end\n\nProcess B组学生\n    begin\n        repeat\n        P(Sb);\n        P(mutexb);\n        take the paper from box ;\n        V(mutexb);\n        V(S);\n        wnte a letter ;\n        untile false ;\n    end\nCoend.</code></pre>\n<p># coding=utf-8<br />import threading<br />import random<br />import time</p>\n<p>s = mutexa = mutexb = 1<br />sa = sb = 0<br />box = random.choice([0, 1])</p>\n<p><br />class processAdmin(threading.Thread):</p>\n<p>def __init__(self, threadName, semaphore):<br /> threading.Thread.__init__(self, name=threadName)<br /> self.sleepTime = random.randrange(1, 6)<br /> self.threadSemaphore = semaphore</p>\n<p>def run(self):<br /> self.threadSemaphore.acquire()<br /> # critical zone<br /> self.threadSemaphore.release()</p>"}, {"folders": [], "updated": "2015-05-06T07:10:41Z", "no_upvotes": 0, "uid": "i718mp903qx", "created": "2015-05-06T07:10:41Z", "type": "followup", "no_answer": 1, "id": "i9ceoef1w7o5bv", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>李日灵 2012011332  第7题</p>\n<p>题目描述如下&#xff1a;(操作系统之PV金典)设有一个可以装A、B两种物品的仓库,其容量有限(分别为N),但要求仓库中A、B两种物品的数量满足下述不等式: -M≤A物品数量-B物品数量≤N 其中M和N为正整数。另外,还有一个进程消费A,B,一次取一个A,B组装成C。 试用信号量和PV操作描述A、B两种物品的入库过程。</p>\n<p>因为0&lt;=A,B&lt;=N,所以A-B&lt;=恒成立&#xff0c;所以可以去掉一个条件。另&#xff0c;原题所附的伪代码有误&#xff0c;修改后semaphore和lock两种方式的伪代码如下&#xff1a;</p>\n<p>1、semaphore</p>\n<p>semaphore mutex=1,diff=m,empty1=N,empty2=N,full1,full2=0;<br />cobegin<br /> process(A);<br /> process(B);<br /> process(C)<br />coend<br />// A物品入库<br />process A<br />begin<br /> while(TRUE)<br /> begin<br /> p(empty1);<br /> p(mutex);<br /> A物品入库;<br /> v(mutex);<br /> v(full1);</p>\n<p>v(diff);<br /> end<br />end<br />// B物品入库&#xff1a;<br />process B<br />begin<br /> while(TRUE)<br /> begin<br /> p(empty2);<br /> p(diff);<br /> <br /> p(mutex);<br /> B物品入库;<br /> v(mutex);<br /> v(full2);<br /> end<br />end<br />// process C<br />begin<br /> while(TRUE)<br /> begin<br /> p(full1);<br /> p(full2);<br /> p(mutex);<br /> 组装;<br /> v(mutex);<br /> v(empty1);<br /> v(empty2);<br /> end<br />end</p>\n<p></p>\n<p>2、lock伪代码</p>\n<p><br />procedure producerA() {<br /> lock-&gt;Acquire();<br /> while (countA == n)<br /> admit_A.Wait(&amp;lock);<br /> <br /> Add A to the buffer;<br /> countA&#43;&#43;;<br /> <br /> admit_B.Signal();<br /> admit_C.signal();<br /> lock-&gt;Release();<br /> }</p>\n<p><br />procedure producerB() {<br /> lock-&gt;Acquire();<br /> while (countB == n || countA-countB&lt;=-M)<br /> admit_B.Wait(&amp;lock);<br /> <br /> Add B to the buffer;<br /> countB&#43;&#43;;</p>\n<p>admit_A.Signal();<br /> admit_C.signal();<br /> lock-&gt;Release();<br />}</p>\n<p>procedure consumer() {<br /> lock-&gt;Acquire();<br /> while (countA==0 || countB == 0)<br /> admit_C.Signal();<br /> countA--;<br /> countB--;</p>\n<p>admit_A.Signal();<br /> admit_B.signal();<br /> lock-&gt;Release(); <br />}</p>\n<p></p>\n<p><em><strong>对应的python代码</strong></em></p>\n<p>semaphore方法&#xff1a;</p>\n<pre>import multiprocessing\nimport time\ndef producerA(mutex,empty1,full1,diff,i):\n    print(&#34;ready to produce A&#34;)\n    empty1.acquire()\n    mutex.acquire()\n    # print(multiprocessing.current_process().name &#43; &#34; acquire&#34;)\n    print(&#34;producing A succeed&#34;)\n    time.sleep(i)\n    # print(multiprocessing.current_process().name &#43; &#34; release&#34;)\n    mutex.release()\n    full1.release()\n\n    diff.release()\n\ndef producerB(mutex,empty2,full2,diff,i):\n    print(&#34;ready to produce B&#34;)\n    empty2.acquire()\n    diff.acquire()\n    mutex.acquire()\n\n    print(&#34;producing B succeed&#34;)\n    time.sleep(i)\n    \n    mutex.release()\n    full2.release()\n\ndef consumer(mutex,empty1,empty2,full1,full2,i):\n    print(&#34;ready to cosume&#34;)\n    full1.acquire()\n    full2.acquire()\n    mutex.acquire()\n    \n    print(&#34;cosuming suceed&#34;)\n    time.sleep(i)\n\n    mutex.release()\n    empty1.release()\n    empty2.release()\n    \nif __name__ == &#34;__main__&#34;:\n    N = 10\n    m = 5\n    full1 = multiprocessing.Semaphore(0)\n    full2 = multiprocessing.Semaphore(0)\n    empty1 = multiprocessing.Semaphore(N)\n    empty2 = multiprocessing.Semaphore(N)\n    \n    diff = multiprocessing.Semaphore(m)\n    mutex = multiprocessing.Semaphore(1)\n\n    for i in range(5):\n        pa = multiprocessing.Process(target=producerA, args=(mutex,empty1,full1,diff,i*2))\n        pa.start()\n        pb = multiprocessing.Process(target=producerB, args=(mutex,empty2,full2,diff,i*2))\n        pb.start()\n        c = multiprocessing.Process(target=consumer, args=(mutex,empty1,empty2,full1,full2,i*2))</pre>\n<p>condition代码&#xff1a;</p>\n<pre>import multiprocessing\nimport time\ndef producerA(mutex,empty1,full1,diff,i):\n    print(&#34;ready to produce A&#34;)\n    empty1.acquire()\n    mutex.acquire()\n    # print(multiprocessing.current_process().name &#43; &#34; acquire&#34;)\n    print(&#34;producing A succeed&#34;)\n    time.sleep(i)\n    # print(multiprocessing.current_process().name &#43; &#34; release&#34;)\n    mutex.release()\n    full1.release()\n\n    diff.release()\n\ndef producerB(mutex,empty2,full2,diff,i):\n    print(&#34;ready to produce B&#34;)\n    empty2.acquire()\n    diff.acquire()\n    mutex.acquire()\n\n    print(&#34;producing B succeed&#34;)\n    time.sleep(i)\n    \n    mutex.release()\n    full2.release()\n\ndef consumer(mutex,empty1,empty2,full1,full2,i):\n    print(&#34;ready to cosume&#34;)\n    full1.acquire()\n    full2.acquire()\n    mutex.acquire()\n    \n    print(&#34;cosuming suceed&#34;)\n    time.sleep(i)\n\n    mutex.release()\n    empty1.release()\n    empty2.release()\n    \nif __name__ == &#34;__main__&#34;:\n    N = 10\n    m = 5\n    full1 = multiprocessing.Semaphore(0)\n    full2 = multiprocessing.Semaphore(0)\n    empty1 = multiprocessing.Semaphore(N)\n    empty2 = multiprocessing.Semaphore(N)\n    \n    diff = multiprocessing.Semaphore(m)\n    mutex = multiprocessing.Semaphore(1)\n\n    for i in range(5):\n        pa = multiprocessing.Process(target=producerA, args=(mutex,empty1,full1,diff,i*2))\n        pa.start()\n        pb = multiprocessing.Process(target=producerB, args=(mutex,empty2,full2,diff,i*2))\n        pb.start()\n        c = multiprocessing.Process(target=consumer, args=(mutex,empty1,empty2,full1,full2,i*2))</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:19:04Z", "no_upvotes": 0, "uid": "i6t76fg9sEh", "created": "2015-05-06T07:19:04Z", "type": "followup", "no_answer": 1, "id": "i9cez61au753n1", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>28.有n&#43;1个进程A1&#xff0c;A2&#xff0c;... ,An和B&#xff1a; A1,A2,... ,An通过同一个缓冲池各自不断地向B发送消息&#xff0c;B不断地取消息&#xff0c;它必须取走 发来的每个消息&#xff0c;刚开始时缓冲区为空&#xff0c;使用P,V操作实现之。 若缓冲区个数增至M个&#xff0c;试用P,V实现正确通讯。</p>\n<p>semaphore</p>\n<pre>#coding = utf-8\n\nimport threading\nimport time\nimport random\n\nproducts = 0\nN = 5  #producer number\nM = 20  #buffer size\n\nclass Producer(threading.Thread):\n\tdef __init__(self, threadName, ifull, iempty, imutex):\n\t\tthreading.Thread.__init__(self, name=threadName)\n\t\tself.sleepTime = random.randrange(1,6)\n\t\tself.full = ifull\n\t\tself.empty = iempty\n\t\tself.mutex = imutex\n\n\tdef run(self):\n\t\tglobal products\n\t\twhile True:\n\t\t\tself.empty.acquire()\n\t\t\tself.mutex.acquire()\n\t\t\tproducts &#43;= 1\n\t\t\tprint &#34;Producer(%s):deliver one, now products:%s&#34; %(self.name, products)\n\t\t\tself.mutex.release()\n\t\t\tself.full.release()\n\t\t\t#print full._Semaphore__value\n\t\t\ttime.sleep(self.sleepTime)\n\nclass Comsumer(threading.Thread):\n\tdef __init__(self, threadName, ifull, iempty, imutex):\n\t\tthreading.Thread.__init__(self, name=threadName)\n\t\tself.sleepTime = random.randrange(1,6)\n\t\tself.full = ifull\n\t\tself.empty = iempty\n\t\tself.mutex = imutex\n\n\tdef run(self):\n\t\tglobal products\n\t\twhile True:\n\t\t\tself.full.acquire()\n\t\t\tself.mutex.acquire()\n\t\t\tproducts -= 1\n\t\t\tprint &#34;Comsumer(%s):comsume one, now products:%s&#34; %(self.name, products)\n\t\t\tself.mutex.release()\n\t\t\tself.empty.release()\n\t\t\ttime.sleep(self.sleepTime)\n\n\nfull = threading.Semaphore(0)\nempty = threading.Semaphore(M)\nmutex = threading.Semaphore(1)\n\nfor i in range(N):\n\tp = Producer(str(i&#43;1),full, empty, mutex)\n\tp.start()\n\nc = Comsumer(&#34;one&#34;, full, empty, mutex)\nc.start()\n\n\n</pre>\n<p>condition</p>\n<pre>#coding=utf-8\n#!/usr/bin/env python\n\nimport threading  \nimport time  \n\nM = 10\nN = 5\ncondition = threading.Condition()  \nproducts = 0  \n\nclass Producer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition, products , M\n        while True:  \n            if condition.acquire():  \n                if products &lt; M:  \n                    products &#43;= 1;  \n                    print &#34;Producer(%s):deliver one, now products:%s&#34; %(self.name, products)  \n                    condition.notify()  \n                else:  \n                    print &#34;Producer(%s):already %d, stop deliver, now products:%s&#34; %(self.name, M, products)  \n                    condition.wait();  \n                condition.release()  \n                time.sleep(1)  \n\nclass Consumer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition, products  \n        while True:  \n            if condition.acquire():  \n                if products &gt; 1:  \n                    products -= 1  \n                    print &#34;Consumer(%s):consume one, now products:%s&#34; %(self.name, products)  \n                    condition.notify()  \n                else:  \n                    print &#34;Consumer(%s):only 1, stop consume, products:%s&#34; %(self.name, products)  \n                    condition.wait();  \n                condition.release()  \n                time.sleep(2)  \n\nif __name__ == &#34;__main__&#34;:  \n    for p in range(0, N):  \n        p = Producer()  \n        p.start()  \n\n    for c in range(1):  \n        c = Consumer()  \n        c.start() </pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:28:50Z", "no_upvotes": 0, "uid": "i6sl02qfUgI", "created": "2015-05-06T07:28:50Z", "type": "followup", "no_answer": 1, "id": "i9cfbqf9rdd290", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>计22 黄杰 2012011272</p>\n<p> 博物馆-公园问题 Jurassic公园有一个恐龙博物馆和一个花园&#xff0c;有m 个旅客租卫辆车&#xff0c;每辆车仅能乘 一个一旅客。旅客在博物馆逛了一会&#xff0c;然后&#xff0c;排队乘坐旅行车&#xff0c;挡一辆车可用喊飞它载 入一个旅客&#xff0c;再绕花园行驶任意长的时间。若n 辆车都己被旅客乘坐游玩&#xff0c;则想坐车的 旅客需要等待。如果一辆车己经空闲&#xff0c;但没有游玩的旅客了&#xff0c;那么&#xff0c;车辆要等待。试用 信号量和P 、V 操作同步m 个旅客和n 辆车子。<br /> <br /> 这是一个汇合机制&#xff0c;有两类进程&#xff1a;顾客进程和车辆进程&#xff0c;需要进行汇合、即顾客要坐进车辆后才能游玩&#xff0c;开始时让车辆进程进入等待状态<br /> <br /> 解答:</p>\n<p><a href=\"https://github.com/THUHJ/os_exercises/blob/master/all/07-2-spoc-discussion.md\" target=\"_blank\">https://github.com/THUHJ/os_exercises/blob/master/all/07-2-spoc-discussion.md</a></p>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T08:27:33Z", "no_upvotes": 0, "uid": "i6rtbanwzcm5t6", "created": "2015-05-06T08:27:33Z", "type": "followup", "no_answer": 1, "id": "i9chf8s6vi51lp", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [{"folders": [], "updated": "2015-05-06T08:38:33Z", "uid": "i6uteptdP5U", "created": "2015-05-06T08:38:33Z", "type": "feedback", "id": "i9chtdpugsr28z", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>题目(第25题):</p>\n<p>把学生和监考老师都看做进程&#xff0c;学生有N个人&#xff0c;教师1人&#xff0c;考场门口每次只能进出一个人&#xff0c;进 考场原则是先来先进&#xff0c;当N个学生都进入考场后&#xff0c;教师才能发试卷。学生交卷后可以离开考 场&#xff0c;教师要等收上来全部试卷并封装试卷后才能离开考场。问共需设置几个进程&#xff1f;使用P&#xff0c;V 操作解决上述问题中的同步和互斥关系。</p>\n<p>需要开N&#43;1个进程&#xff1b;</p>\n<p>代码如下&#xff1a;</p>\n<pre>#信号量方法<br />#coding=utf-8\nimport threading  \n\nN = 10\nmutex = threading.Semaphore(1)\nBeginready = threading.Semaphore(0)\nTestready = threading.Semaphore(0)\nEndready = threading.Semaphore(0)\n\ndef thread_run(name):\n\tif(name == &#34;teacher&#34;):\n\t\tmutex.acquire()\n\t\tprint &#34;老师进教室!\\n&#34;\n\t\tmutex.release()\n\t\tfor i in range(N):\n\t\t\tBeginready.acquire()\n\t\tprint &#34;开始发卷!\\n&#34;\n\t\tTestready.release()\n\t\tfor i in range(N):\n\t\t\tEndready.acquire()\n\t\tprint &#34;老师离开!\\n&#34;\n\telse:\n\t\tmutex.acquire()\n\t\tprint &#34;学生进教室!\\n&#34;\n\t\tmutex.release()\n\t\tBeginready.release()\n\t\tTestready.acquire()\n\t\tTestready.release()\n\t\tprint &#34;答题\\n&#34;\n\t\tprint &#34;交卷\\n&#34;\n\t\tprint &#34;离开\\n&#34;\n\t\tEndready.release()\n\ndef main(thread_num):  \n    thread_list = list();  \n    # 先创建线程对象  \n    for i in range(0, thread_num):\n \t\tif(i == 0):\n \t\t\tthread_name = &#34;teacher&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n \t\telse:\n \t\t\tthread_name = &#34;student&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n      \n    # 启动所有线程     \n    for thread in thread_list:  \n        thread.start()  \n      \n    # 主线程中等待所有子线程退出  \n    for thread in thread_list:  \n        thread.join()  \n  \nif __name__ == &#34;__main__&#34;:  \n    main(N&#43;1)  \n#条件量方法<br />#coding=utf-8\nimport threading  \n\nN = 10#学生数量\nmutex = threading.Condition()\ncond = threading.Condition()\nend = threading.Condition()\nBeginready = -9\nTestready = 0\nEndready = -9\n\ndef thread_run(name):\n\tglobal Testready\n\tglobal Beginready\n\tglobal Endready\n\tif(name == &#34;teacher&#34;):\n\t\tmutex.acquire()\n\t\tprint &#34;老师进教室!\\n&#34;\n\t\tmutex.release()\n\t\tcond.acquire()\n\t\tif(Beginready &lt; 1):\n\t\t\tcond.wait()\n\t\tprint &#34;开始发卷!\\n&#34;\n\t\tTestready &#43;= 1\n\t\tcond.notify()\n\t\tcond.release()\n\t\tend.acquire()\n\t\tif(Endready != 1):\n\t\t\tend.wait()\n\t\tprint &#34;老师离开!\\n&#34;\n\t\tend.release()\n\telse:\n\t\tmutex.acquire()\n\t\tprint &#34;学生进教室!\\n&#34;\n\t\tBeginready &#43;= 1\n\t\tmutex.release()\n\t\tcond.acquire()\n\t\tcond.notifyAll()\n\t\tif(Testready != 1):\n\t\t\tcond.wait()\n\t\tprint &#34;答题\\n&#34;\n\t\tprint &#34;交卷\\n&#34;\n\t\tprint &#34;离开\\n&#34;\n\t\tcond.release()\n\t\tend.acquire()\n\t\tEndready &#43;= 1\n\t\tend.notify()\n\t\tend.release()\n\ndef main(thread_num):  \n    thread_list = list();  \n    # 先创建线程对象  \n    for i in range(0, thread_num):\n \t\tif(i == 0):\n \t\t\tthread_name = &#34;teacher&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n \t\telse:\n \t\t\tthread_name = &#34;student&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n      \n    # 启动所有线程     \n    for thread in thread_list:  \n        thread.start()  \n      \n    # 主线程中等待所有子线程退出  \n    for thread in thread_list:  \n        thread.join()  \n  \nif __name__ == &#34;__main__&#34;:  \n    main(N&#43;1)  </pre>\n<p></p>"}], "subject": "<p>陈振寰 2012012390</p>\n<p>24题&#xff0c;题目&#xff1a;设公共汽车上&#xff0c;司机和售票员的活动分别如下&#xff1a;司机的活动&#xff1a;启动车辆&#xff1a;正常行车&#xff1b;到站停车。售票员的活动&#xff1a;关车门&#xff1b;售票&#xff1b;开车门。在汽车不断地到站、停车、行驶过程中&#xff0c;这两个活动有什么同步关系&#xff1f;用信号量和P 、V 操作实现它们的同步。</p>\n<p></p>\n<p>解答&#xff1a;</p>\n<p>sem:</p>\n<pre>#coding=utf-8\nimport threading \nimport random\nimport time\n\nclass driverThread(threading.Thread):\n\tdef __init__(self,threadName,semaphore1,semaphore2):\n\t\tthreading.Thread.__init__(self,name=threadName)  \n\t\tself.sleepTime=random.randrange(1,6)  \n\t\t#set the semaphore as a data attribute of the class  \n\t\tself.threadSemaphore1 = semaphore1\n\t\tself.threadSemaphore2 = semaphore2\n\tdef run(self):\n\t\twhile True:\n\t\t\tself.threadSemaphore1.acquire() \n\t\t\tprint &#34;bus start running&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;bus is running&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;bus stop running&#34;\n\t\t\tself.threadSemaphore2.release()\n\n\nclass conductorThread(threading.Thread):\n\tdef __init__(self,threadName,semaphore1,semaphore2):\n\t\tthreading.Thread.__init__(self,name=threadName)  \n\t\tself.sleepTime=random.randrange(1,6)  \n\t\t#set the semaphore as a data attribute of the class  \n\t\tself.threadSemaphore1 = semaphore1\n\t\tself.threadSemaphore2 = semaphore2\n\tdef run(self):\n\t\twhile True:\n\t\t\tprint &#34;close the bus door&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tself.threadSemaphore1.release() \n\t\t\tprint &#34;sale ticket&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tself.threadSemaphore2.acquire()\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;open the bus door&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;passenger on and off&#34;\n<br />threadSemaphore1=threading.Semaphore(0)\nthreadSemaphore2=threading.Semaphore(0)\ndriver_thread = driverThread(&#34;driver&#34;,threadSemaphore1,threadSemaphore2)\nconductor_thread = conductorThread(&#34;conductor&#34;,threadSemaphore1,threadSemaphore2)\ndriver_thread.start()\nconductor_thread.start()</pre>\n<p>condition:</p>\n<pre>import threading\nimport random\nimport time\n\ncondition = threading.Condition()\nbusStatus = &#34;&#34;\n\nclass Driver(threading.Thread):\n    def __init__(self,threadName):\n        threading.Thread.__init__(self,name=threadName)\n        self.sleepTime = random.randrange(1,6)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#34;Start&#34;:\n                    print &#34;Driver: bus start running&#34;\n                    busStatus = &#34;Running&#34;\n                    time.sleep(self.sleepTime)\n                    print &#34;Driver: bus stop&#34;\n                    busStatus = &#34;Stop&#34;\n                    time.sleep(self.sleepTime)\n                    condition.notify()\n                elif busStatus == &#34;doorOpened&#34;:\n                    time.sleep(self.sleepTime)\n                    print &#34;Driver: door not closed, waiting.&#34;\n                    condition.wait()\n                condition.release()\n\nclass Conductor(threading.Thread):\n    def __init__(self,threadName):\n        threading.Thread.__init__(self,name=threadName)\n        self.sleepTime = random.randrange(1,6)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#34;Stop&#34;:\n                    print &#34;Conductor: Bus stopped, open the door,passenger on and off&#34;\n                    busStatus = &#34;doorOpened&#34;\n                    time.sleep(self.sleepTime)\n                    print &#34;Conductor: close the door,sell tickets&#34;\n                    busStatus = &#34;Start&#34;\n                    time.sleep(self.sleepTime)\n                    condition.notify()\n                elif busStatus == &#34;Running&#34;:\n                    time.sleep(self.sleepTime)\n                    print &#34;Condutor: bus not stopped, cannot open the door.&#34;\n                    condition.wait()\n                condition.release()\n\nif __name__ == &#39;__main__&#39;:\n    busStatus = &#34;Start&#34;  \n    Driver(&#34;driver&#34;).start()\n    Conductor(&#34;conductor&#34;).start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T11:11:13Z", "no_upvotes": 0, "uid": "i6rgfjo5j1r6c", "created": "2015-05-06T11:11:13Z", "type": "followup", "no_answer": 1, "id": "i9cn9pshybv5zk", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 162, "data": null, "children": [], "subject": "<p>2012011375 梁俊邦 第16题</p>\n<p></p>\n<p>16.在一个盒子里&#xff0c;混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白子分开&#xff0c;设分拣系统有二个进程P1 和P2 &#xff0c;其中P1 拣白子&#xff1b;P2 拣黑子。规定每个进程每次拣一子&#xff1b;当一个进程在拣时&#xff0c;不允许另一个进程去拣&#xff1b;当一个进程拣了一子时&#xff0c;必须让另一个进程去拣&#xff0e;试写出两进程P1 和P2 能并发正确执行的程序。</p>\n<p></p>\n<p>信号量方法&#xff1a; <a href=\"https://github.com/williamljb/os_exercises/blob/master/all/semaphore.py\" target=\"_blank\">https://github.com/williamljb/os_exercises/blob/master/all/semaphore.py</a><a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py\" target=\"_blank\"></a></p>\n<p>condition方法&#xff1a;<a href=\"https://github.com/williamljb/os_exercises/blob/master/all/condition.py\" target=\"_blank\">https://github.com/williamljb/os_exercises/blob/master/all/condition.py</a></p>"}, {"folders": [], "updated": "2017-04-28T07:39:03Z", "no_upvotes": 0, "uid": "izb0cbqbyzd6wf", "created": "2017-04-28T07:39:03Z", "type": "followup", "no_answer": 1, "id": "j21j1qzx17x3rn", "anon": "no", "bucket_name": "Week 4/23 - 4/29", "config": {}, "bucket_order": 59, "data": null, "children": [{"folders": [], "updated": "2017-05-07T01:00:48Z", "uid": "izb0cbqbyzd6wf", "created": "2017-05-07T01:00:48Z", "type": "feedback", "id": "j2dzs9r673o4ii", "anon": "no", "bucket_name": "Week 5/7 - 5/13", "config": {}, "bucket_order": 57, "data": null, "children": [], "subject": "<p>更新了一下输出方式. 做了一个比较好看的输出. 另外如果只有 3 个椅子的时候比较容易看出优先级的分配.</p>"}], "subject": "<p>2016011279 何家傲 打印机问题:</p>\n<p></p>\n<p>问题概述: 有五台打印机, 请求有优先级, 保证优先级高的先得到打印机.</p>\n<p></p>\n<p>思路: 把队列换成优先队列就好了.</p>\n<p></p>\n<p>实现: 第一次用cpp的thread. 坑比较多, 比如最后要 join 否则会直接退出, 得不到各子线程的输出. 用 yield 和全局变量实现了一个差不多是轮询的等待和唤醒. 用8个进程(其实是线程模拟的) 和 5台打印机 可以比较好地体现出优先级的高低.</p>\n<p></p>\n<p>代码: <a href=\"https://gist.github.com/laekov/348a49b8894856622e902d49c4523631\" target=\"_blank\">https://gist.github.com/laekov/348a49b8894856622e902d49c4523631</a></p>"}, {"folders": [], "updated": "2017-05-07T00:01:50Z", "no_upvotes": 0, "uid": "izb0cbkdd5s6w9", "created": "2017-05-07T00:01:50Z", "type": "followup", "no_answer": 1, "id": "j2dxofyec4c22r", "anon": "no", "bucket_name": "Week 5/7 - 5/13", "config": {}, "bucket_order": 57, "data": null, "children": [], "subject": "<p>练习题4&#xff1a;理发师问题</p>\n<p>假设有5把椅子&#xff0c;20位顾客&#xff0c;在50s的时间内申请理发。每次理发的时间4s</p>\n<pre>#include&lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;math.h&gt;\n #define CHAIRS 5 //椅子数\n#define TOTALTIME 50\nsem_t customers; //等待服务的顾客信号量\nsem_t barbers; //等待顾客的理发师信号量\nsem_t mutex; //互斥变量\nint waiting = 0; //正在等待的顾客数\nvoid *barber(void);\nvoid *customer();\nvoid cut_hair(void);\n\nvoid *barber(void*) {\n\tint i;\n\twhile(1) {\n\tsem_wait(&amp;customers);//顾客信号量-1\n\tsem_wait(&amp;mutex);\n\twaiting = waiting -1;\n\tsem_post(&amp;barbers);\n\tsem_post(&amp;mutex);\n\tcut_hair();//理发\n\t}\n}\nvoid cut_hair(void) {\nprintf(&#34; Barber is busy now.\\n&#34;);\nsleep(4);//理发时间\nprintf(&#34; Haircut is over.\\n&#34;);\n}\nvoid *customer(void* arg) {\n\tsleep(rand()%TOTALTIME);\n\tsem_wait(&amp;mutex);\n\tif(waiting&lt;CHAIRS) {\n\t\tprintf(&#34;Customer %d starts waiting. Length of waiting line:%d\\n&#34;,*(int*)(arg),&#43;&#43;waiting);\n\t\tsem_post(&amp;customers);\n\t\tsem_post(&amp;mutex);\n\t\tsem_wait(&amp;barbers);\n\t\tprintf(&#34;Customer %d is having haircut. Length of waiting line:%d\\n&#34;,*(int*)(arg),waiting);\n\t\tsleep(5);\n\t}\n\telse {\n\t\tprintf(&#34;Customer %d:So much customers,not enough chairs.\\n&#34;,*(int*)(arg));\n\t\tsem_post(&amp;mutex);\n\t\tsleep(5);\n\t} //释放占用的资源\n}\nint main(int argc,char** argv ){\n\tsem_init(&amp;customers,0,0);\n\tsem_init(&amp;barbers,0,0);\n\tsem_init(&amp;mutex,0,1);\n\tpthread_t barber_t,customer_t[20];  //20个顾客线程\n\tpthread_create(&amp;barber_t,NULL,barber,NULL);\n\tfor(int i=0;i&lt;20;i&#43;&#43;){\n\t\tpthread_create(&amp;customer_t[i],NULL,customer,new int(i));\n\t}\n\tpthread_join(barber_t,NULL);\n\tfor(int i=0;i&lt;20;i&#43;&#43;){\n\t\tpthread_join(customer_t[i],NULL);\n\t}\n\treturn 0;\n}</pre>\n<p></p>"}], "nr": 391, "bucket_order": 2, "type": "note", "folders": ["lecture18", "lecture19", "课堂问答"], "no_answer_followup": 25, "num_favorites": 2, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2015-05-06T06:13:35Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1525760650881, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>下面链接列出了47个同步互斥问题。请每个同学在此回复自己的回答。</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7</a></p>\n<p></p>\n<p>题目要求见下面链接。</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>", "anon": "no", "created": "2016-04-27T02:44:58Z", "uid": "hdjonbiyfs62ie", "subject": "第18和19讲的课堂练习回答"}, {"content": "<p>下面链接列出了47个同步互斥问题。请每个同学在此回复自己的回答。</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7</a></p>\n<p></p>\n<p>题目要求见下面链接。</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>", "anon": "no", "created": "2015-05-06T06:13:35Z", "uid": "hdjonbiyfs62ie", "subject": "第18和19讲的课堂练习回答"}]}, "error": null}