{"aid": "j014fdrizib45r", "result": {"status": "active", "unique_views": 15, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-03-07T08:00:39Z", "data": "izz8x8u6ez47gn", "uid": "ie7xy8gtpwk1t5"}, {"type": "update", "anon": "no", "when": "2017-03-08T13:11:06Z", "data": "j00zgbqka512wn", "uid": "ie7xy5sipx51qz"}], "upvote_ids": [], "id": "izz8x8u25qk7gm", "bookmarked": 6, "tags": ["lecture5", "student", "unanswered"], "i_edits": [], "is_bookmarked": false, "children": [], "nr": 1000, "bucket_order": 2, "type": "note", "folders": ["lecture5"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-03-07T08:00:39Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1488987020142, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>题外话&#xff1a;为什么叫“伙伴”&#xff1f;因为每块只能和特定的另一块合并。</p>\n<p></p>\n<p>参考了wiki上伙伴系统实现的<a href=\"http://coolshell.cn/articles/10427.html\">链接</a>&#xff0c;在此做一简单总结</p>\n<p>这里采用二叉树管理内存单元&#xff0c;分配和释放的搜索时间复杂度O(logN)&#xff0c;在这一点上优于最先匹配、最佳匹配和最差匹配。</p>\n<p> </p>\n<p>每个节点标记对应的<strong>可用</strong>内存块大小</p>\n<p>分配&#xff1a;</p>\n<ol><li>传入size&#xff0c;将size调整到2的幂大小&#xff0c;检查是否超过根节点的标记。</li><li>深度优先搜索&#xff0c;找到恰为<strong>size大小</strong>的空闲内存块&#xff08;标记等于size且该层每个节点对应内存块大小为size&#xff09;&#xff0c;修改标记为0。根据size和该节点对应二叉树中的序号以及总大小&#xff0c;可以计算出内存块索引offset。</li><li>之后回溯&#xff0c;更新祖先节点的标记&#xff0c;取左右子树较大值&#xff0c;完成分割。</li></ol>\n<p> </p>\n<p>释放&#xff1a;</p>\n<p>传入offset。从最底层节点向上回溯&#xff0c;遇到标记为0的节点即对应当初分配的内存块&#xff0c;恢复标记为块大小&#xff0c;继续回溯&#xff0c;如果左右子树标记相加等于父节点对应的块大小&#xff0c;则恢复父节点标记为块大小。</p>\n<p></p>", "anon": "no", "created": "2017-03-08T13:11:06Z", "uid": "ie7xy5sipx51qz", "subject": "第五讲 伙伴系统总结"}, {"content": "<p>题外话&#xff1a;为什么叫“伙伴”&#xff1f;因为每块只能和特定的另一块合并。</p>\n<p></p>\n<p>参考了wiki上伙伴系统实现的<a href=\"http://coolshell.cn/articles/10427.html\">链接</a>&#xff0c;在此做一简单总结</p>\n<p>这里采用二叉树管理内存单元&#xff0c;分配和释放的搜索时间复杂度O(logN)&#xff0c;在这一点上优于最先匹配、最佳匹配和最差匹配。</p>\n<p> </p>\n<p>每个节点标记对应的<strong>可用</strong>内存块大小</p>\n<p>分配&#xff1a;</p>\n<ol><li>传入size&#xff0c;将size调整到2的幂大小&#xff0c;检查是否超过根节点的标记。</li><li>深度优先搜索&#xff0c;找到恰为<strong>size大小</strong>的空闲内存块&#xff08;标记等于size且该层每个节点对应内存块大小为size&#xff09;&#xff0c;修改标记为0。根据size和该节点对应二叉树中的序号以及总大小&#xff0c;可以计算出内存块索引offset。</li><li>之后回溯&#xff0c;更新祖先节点的标记&#xff0c;取左右子树较大值&#xff0c;完成分割。</li></ol>\n<p> </p>\n<p>释放&#xff1a;</p>\n<p>传入offset。从最底层节点向上回溯&#xff0c;遇到标记为0的节点即对应当初分配的内存块&#xff0c;恢复标记为块大小&#xff0c;继续回溯&#xff0c;如果左右子树标记相加等于父节点对应的块大小&#xff0c;则恢复父节点标记为块大小。</p>\n<p></p>", "anon": "no", "created": "2017-03-07T08:00:39Z", "uid": "ie7xy8gtpwk1t5", "subject": "第五讲 伙伴系统总结"}]}, "error": null}